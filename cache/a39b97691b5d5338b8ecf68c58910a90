O:9:"MagpieRSS":21:{s:6:"parser";i:0;s:12:"current_item";a:0:{}s:5:"items";a:50:{i:0;a:11:{s:5:"title";s:48:"Laravel 5系列教程十：实现文章的修改";s:4:"link";s:42:"http://segmentfault.com/a/1190000003753320";s:2:"id";s:42:"http://segmentfault.com/a/1190000003753320";s:7:"updated";s:25:"2015-09-16T12:27:58+08:00";s:9:"published";s:25:"2015-09-16T12:27:58+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:9:"JellyBool";s:10:"author_uri";s:35:"http://segmentfault.com/u/jellybool";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:9830:"
<blockquote><p>原文来自<a href="https://laravist.com/article/20"></a><a href="https://laravist.com/article/20">https://laravist.com/article/20</a></p></blockquote>
<p><a href="https://laravist.com/">Laravist</a>是我刚刚上线的Laravel社区，有任何与Laravel相关的问题可以到这里来问我，我会尽力去帮大家解决问题，后期会尝试录制一些视频教程，形式大概是这样的</p>
<p><a href="https://laravist.com/lesson/2">https://laravist.com/lesson/2</a></p>
<p>我们之前的一系列文章综合起来就实现了一个发布文章的整个流程，但是万一我们需要修改某篇文章的内容呢？我们该如何去实现呢？其实，有了怎么创建一篇文章之后，我们实现编辑(更新)文章的思路很类似。这里可以值得注意的知识点就是<code>Form::model</code>和<code>getAttribute</code>了。来看看具体的步骤：</p>
<h2>注册路由</h2>
<p>在<code>routes.php</code>中，注册我们的编辑页面的路由：</p>
<pre><code>Route::get('article/edit/{id}','ArticleController@edit');</code></pre>
<p>这个路由接受一个参数：<code>id</code>，意为文章的<code>id</code>，我们会需要根据这个<code>id</code>来查询我们要修改的文章。</p>
<h2>编写edit方法</h2>
<p>根据路由，我们在<code>ArticleController</code>添加<code>edit()</code>方法：</p>
<pre><code>public function edit($id)
    {
        $article = Article::findOrFail($id);
        $tags = Tag::lists('name', 'id');
        return view('articles.edit',compact('article','tags'));
    }
</code></pre>
<p>很熟悉地，我们首先根据<code>id</code>来查询到我们需要编辑的文章，对于<code>$tags</code>，我们采取跟<code>create()</code>方法一样的方法，得到我们的<code>$tags</code>列表。然后渲染视图，并将查询到的<code>$article</code>和<code>$tags</code>传给视图。</p>
<h2>创建视图</h2>
<p>上面的<code>edit()</code>方法指定了渲染<code>articles.edit(resources/views/articles/edit.blade.php)</code>这个视图，我们来创建之，这里为了便利，我们可以直接将<code>create.blade.php</code>这个视图文件拷贝过来：</p>
<pre><code>@extends('app')
@section('content')
    &lt;h1&gt;修改文章:{{ $article-&gt;title }}&lt;/h1&gt;
    {!! Form::model($article,['url'=&gt;'article/update']) !!}
    {!! Form::hidden('id',$article-&gt;id) !!}
    &lt;div class="form-group"&gt;
        {!! Form::label('title','标题:') !!}
        {!! Form::text('title',$article-&gt;title,['class'=&gt;'form-control']) !!}
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        {!! Form::label('content','正文:') !!}
        {!! Form::textarea('content',$article-&gt;content,['class'=&gt;'form-control']) !!}
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        {!! Form::label('published_at','发布日期') !!}
        {!! Form::input('date','published_at',$article-&gt;published_at-&gt;format('Y-m-d'),['class'=&gt;'form-control']) !!}
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        {!! Form::label('tag_list','选择标签') !!}
        {!! Form::select('tag_list[]',$tags,null,['class'=&gt;'form-control js-example-basic-multiple','multiple'=&gt;'multiple']) !!}
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        {!! Form::submit('修改文章',['class'=&gt;'btn btn-success form-control']) !!}
    &lt;/div&gt;
    {!! Form::close() !!}
    @if($errors-&gt;any())
        &lt;ul class="alert alert-danger"&gt;
            @foreach($errors-&gt;all() as $error)
                &lt;li&gt;{{ $error }}&lt;/li&gt;
            @endforeach
        &lt;/ul&gt;
    @endif
    &lt;script type="text/javascript"&gt;
        $(function() {
            $(".js-example-basic-multiple").select2({
                placeholder: "添加标签"
            });
        });
    &lt;/script&gt;
@endsection
</code></pre>
<p>这里我们注意下面这几点：</p>
<p><strong>我们使用了Form::hidden()</strong></p>
<p>这里我们使用这个目的<code>(因为hidden表单并不会展示给用户看)</code>就是为了后面在更新的时候更加便捷和暴力，因为有了<code>id</code>，我们一切的事情都很好办。</p>
<p><strong>我们给Form input表单设置了初始值</strong></p>
<p>通过类似<code>{!! Form::text('title',$article-&gt;title,['class'=&gt;'form-control']) !!}</code>中的<code>$article-&gt;title</code>的形式，我们给表单赋予了初始值。</p>
<p><strong>我们使用了Form::model()</strong></p>
<p>在声明Form的时候，我们并不是简单的使用<code>Form::open()</code>,<code>Form::model()</code>首先需要将你要绑定的<code>model</code>传进来，这里我们用的是<code>$article</code>，也就是我们在<code>edit()</code>方法查找到的<code>$article</code>，这个有什么好处呢？</p>
<p>一旦绑定<code>Form::model()</code>，在后面的<code>input</code>表单中即使你没有设置初始值，laravel也会自动为你匹配，然后<br>为你赋予初始值，这也是使用Form的好处之一，就比如上面的<code>{!! Form::text('title',$article-&gt;title,['class'=&gt;'form-control']) !!}</code>，在<code>Form::model()</code>下，你完全可以像之前那样写：</p>
<pre><code>{!! Form::text('title',null,['class'=&gt;'form-control']) !!}
</code></pre>
<p>你依然会得到相同的效果，但是这里为了更清晰，我直接赋了<code>$article-&gt;title</code>初始值。</p>
<p><strong>我们又使用Carbon</strong></p>
<p>在文章的<code>published_at</code>这个字段，我们借<code>$article-&gt;published_at-&gt;format('Y-m-d')</code>又一次感受到了Carbon的便利。</p>
<p>最后来看看我们的编辑页面有没有好：</p>
<p><img src="https://wt-prj.oss.aliyuncs.com/0d06af79c49d4e08abb1ab3f7ab6e860/2ed4c2bb-66f0-482f-bf20-ea24c7b6a79e.gif" alt="替代文字" title="替代文字"></p>
<p>仔细看其实就会发现，这样还没有完全实现编辑，因为我们的标签还没有同步过来，我们看到的标签<code>select</code>都是空的，但是原来的文章是有标签的啊，这个怎么办呢？</p>
<h2>getAttribute</h2>
<p><code>getAttribute</code>就可以登场了，借助<code>tag_list[]</code>这个便利特性，我们可以在<code>Article.php</code>中为其设置一个<code>getAttribute</code>方法：</p>
<pre><code> public function getTagListAttribute()
    {
        // laravel 5.1 needs all()
        return $this-&gt;tags-&gt;lists('id')-&gt;all();
        // tags means tags() many-to-many relationship with tag
    }
</code></pre>
<p>这里需要说明一下，类似<code>getAttribute</code>都统一使用驼峰法。然后取值的时候就统一使用下划线的方法，比如这里的<code>tag_list</code>就是对应<code>TagList</code>，如果你写成<code>tag_involved</code>，方法就是<code>getTagInvolvedAttribute()</code>。这样写laravel会自动获取这个值。</p>
<blockquote><p>注意，laravel 5.0版本，写成这样<code>return $this-&gt;tags-&gt;lists('id');</code></p></blockquote>
<p>我们来看看效果：</p>
<p><img src="https://wt-prj.oss.aliyuncs.com/0d06af79c49d4e08abb1ab3f7ab6e860/67913bb1-cf29-4fd1-b25e-164e0559de07.gif" alt="替代文字" title="替代文字"></p>
<p>OK,这里我们实现完编辑页面之后，我们根据<code>Form::model()</code>的<code>url</code>来注册一个<code>post</code>路由</p>
<h2>注册post路由</h2>
<p>来到routes.php中，为update方法增加post路由：</p>
<pre><code>Route::post('article/update','ArticleController@update');</code></pre>
<p>修改文章的表单会提交到<code>article/update</code>，然后触发<code>ArticleController</code>的<code>update()</code>方法。</p>
<h2>编写update()</h2>
<p>在<code>ArticleController</code>中增加<code>update()</code>方法:</p>
<pre><code>public function update(Requests\StoreArticleRequest $request)
    {
        //这里使用同样地验证规则
       dd($request-&gt;all());
    }
</code></pre>
<p>我们来看看有没有拿到提交过来的数据：</p>
<p><img src="https://wt-prj.oss.aliyuncs.com/0d06af79c49d4e08abb1ab3f7ab6e860/efd1eb3b-ede0-428a-8417-8992b63e2da3.gif" alt="替代文字" title="替代文字"></p>
<p>OK，我们争取拿到数据了，接下来就是实现更新了。修改我们的<code>update()</code>方法：</p>
<pre><code>public function update(Requests\StoreArticleRequest $request)
    {
        //根据id查询到需要更新的article
        $article = Article::find($request-&gt;get('id'));
        //使用Eloquent的update()方法来更新，
        //request的except()是排除某个提交过来的数据，我们这里排除id
        $article-&gt;update($request-&gt;except('id'));
        // 跟attach()类似，我们这里使用sync()来同步我们的标签
        $article-&gt;tags()-&gt;sync($request-&gt;get('tag_list'));
        
        return redirect('/');
    }
</code></pre>
<p>OK，代码逻辑实现完了之后，我们来看看是否能更新成功：</p>
<p><img src="https://wt-prj.oss.aliyuncs.com/0d06af79c49d4e08abb1ab3f7ab6e860/9514d041-c330-46dd-b7b7-13ba89cb3da3.gif" alt="替代文字" title="替代文字"></p>
<p>Bang，大工告成！！</p>
<h2>总结</h2>
<p>如果你一直都跟着教程来，这个修改文章的过程应该思路很清晰。我们在这里再一次感受到：</p>
<pre><code>注册路由---&gt;控制器写方法---&gt;加载视图
</code></pre>
<p>这一个神奇的轮回。这里还是需要强调的是<code>Form::model()</code>和<code>getAttribute</code>这两个知识点。</p>
<p>最后，到这里，貌似我们的整个教程就可以结束了。下面我打算再开一个系列说说laravel 5.1的新特性.</p>
<p><strong>Happy Hacking</strong></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003753320";}i:1;a:11:{s:5:"title";s:81:"Microsoft Azure研发经理胡鲁辉：技术总是相通的，不同的是产品";s:4:"link";s:42:"http://segmentfault.com/a/1190000003753150";s:2:"id";s:42:"http://segmentfault.com/a/1190000003753150";s:7:"updated";s:25:"2015-09-16T11:43:48+08:00";s:9:"published";s:25:"2015-09-16T11:43:48+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:12:"图灵访谈";s:10:"author_uri";s:42:"http://segmentfault.com/u/turing_interview";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:7437:"
<blockquote><p>非商业转载请注明作译者、出处，并保留本文的原始链接：<a href="http://www.ituring.com.cn/article/203595">http://www.ituring.com.cn/article/203595</a></p></blockquote>
<p><strong>胡鲁辉</strong>，美国微软总部首席研发经理，云计算电子商务和移动物联网专家。他现任美国微软公司首席研发经理，管理团队进行Microsoft Azure的研发。他曾就职于美国亚马逊公司达五年多，从事AWS和电子商务的研究和开发，曾管理和带领多个研发团队推出Amazon.cn新一代SOA平台和CRM系统，曾负责Kindle项目直接汇报给贝索斯（亚马逊创始人）。胡鲁辉毕业于清华大学和美国弗吉尼亚理工大学。</p>
<p><img src="/img/bVpUwN" alt="图片描述" title="图片描述"></p>
<p><strong>问：您曾在清华大学和美国弗吉尼亚理工大学接受过教育，在您看来，在计算机教育领域，中美最大的差异在哪里？</strong></p>
<p>我觉得应该是各有特点。美国的计算机教育更注重于实践和应用，甚至还会鼓励一些不错的创业，例如Snapchat和Facebook都是大学里的项目，甚至可以说就是从大学里玩出来的。而且美国大学也有很多直接与工业界相关的研究，以及当前最前沿的技术研发，例如大数据开源项目Spark和Apache Mesos，这两个项目都是从加州大学伯克利分校开始的。这些例子在中国大学里很少，不过我觉得中国的计算机教育发展很快，国內产生了不少一流的高科技公司。而且国內创业气氛很浓，我相信在不远的将来国內的大学计算机教育会上一个台阶。</p>
<p><strong>问：您曾在亚马逊带领过新一代SOA平台和CRM系统的研发，也负责过AWS大数据项目的研发，在这些项目中您印象最深刻的是哪个项目？遇到的最大困难是什么？</strong></p>
<p>这些项目都给我留下了深刻的印象，其实它们的技术和设计原理也是相通的，不同的主要是产品应用和用户群体。比如我一开始从事的是亚马逊电商的研发，后来开始亚马逊云计算和大数据的研发。这些项目对可扩展性的高标准和对用户至上的高要求，至今仍令我记忆犹新。而这些指标也直接影响了研发的方式，以及产品和服务的好与坏，同时也为项目的实施带来了巨大的挑战。</p>
<p><strong>问：您在负责Kindle电商项目的时候曾跟亚马逊的创始人杰夫·贝索斯（Jeff Bezos）有过直接的接触和合作，从您的角度看，他是一个什么样的人？</strong></p>
<p>我觉得他是个很了不起的人。他的远见和理念深深地影响了整个亚马逊，也影响了我对产品、服务、客户，以及带领团队的原则和方法的理解。他办公室里的一面墙上挂满他的专利，由此可以看出他对技术的重视和热情。另外他对别人的态度也和我以前接触的创始人，比如比尔·盖茨，截然不同，他总是面带笑容，让人觉得轻松自然，另外，他还能从技术上和用户的角度上提出中肯的建议。</p>
<p><strong>问：亚马逊的AWS和微软的Azure相比，产品类型有什么不同？研发的侧重点又有什么不同？</strong></p>
<p>亚马逊的AWS和微软的Azure应该说是同一类云，他们的产品有许多类似之处，而且它们都是用公有云来提供不同的工具和服务。不同的是，虽然两者都以服务应用和解决方案来分类，但是开始时亚马逊只提供IaaS计算服务（EC2），而微软是从PaaS（Service Role）开始的。这两个项目的主要研发工具也不一样，比如亚马逊主要用开源和Java，而微软用.net和C#。</p>
<p><strong>问：Microsoft Azure是首个在中国落地的全球公有云，请问Azure在国内落地的现状如何？未来面临着什么样的挑战？</strong></p>
<p>微软Azure在中国的发展很迅速，我们现在在研发上也很重视。应该说这是另一个数据中心和云服务区域的发展，不过国内会受许多因素的影响，比如政府政策和地方合规性。云的许多应用是与企业合作在行业中实现的应用，国內企业的公有云，比如阿里云和腾讯云，由于他们在地方和行业上的优势，例如去IOE，所以他们也是很具有挑战性的。</p>
<p><strong>问：去年11月Azure发生了将近11个小时的故障，现在问题已经解决，而且Azure团队在处理问题过程中公开透明的做法也很值得赞赏。请问在这次故障后，Azure团队获得了哪些经验和教训？</strong></p>
<p>大家常常会听到类似的云故障，这主要是由云本身的规模性和复杂性造成的，但是近来云服务已经变得越来越稳定了。上次故障的主要原因是Blob front-ends的配置更改有个bug，一开始虽然只影响了一部分，但是后来问题不幸扩大了。微软内部很重视这个问题，总结了许多宝贵的云开发经验，比如：</p>
<ul>
<li><p>确保部署工具执行总是跟随申请增量批次生产变化的标准协议；</p></li>
<li><p>提高以最小化恢复时间的恢复方法；</p></li>
<li><p>提高服务状况仪表板的架构和协议；</p></li>
<li><p>发布前必须修复无限循环的bug。</p></li>
</ul>
<p><strong>问：微软是否会开放COSMOS技术到Azure上供外部用户使用？COSMOS是一种什么样的技术？这样的开放会造成什么样的影响？</strong></p>
<p>微软COSMOS是微软自己研发的大数据分析平台，它在微软内部使用很广。可以说COSMOS经历过微软大数据的广泛应用和考验，它有点类似开源项目Hadoop，可以说是对大数据生态系统的一个很好的补充。据说COSMOS最近会通过Azure HDInsights对外提供服务。</p>
<p><strong>问：NoSQL数据已经成为开发者开发应用过程中不可或缺的有力工具，请问Azure对NoSQL的支持主要体现在哪几个方面上？</strong></p>
<p>Azure广泛地支持NoSQL 服务，比如caching、Redis、大数据存储HBase、DBaaS DocumentDB，甚至Azure典型的云存储Blob和Table也是属于这一类。</p>
<p><strong>问：Azure已经开始支持R语言，请问微软未来是否有可能要开发自己的R语言？</strong></p>
<p>微软对机器学习的重视和战略部署是众人皆知的。今年微软收购了Revolution Analytics, 这是对微软云机器学习很好的补充，自然R语音也成为了其中的一部分。现在你可以直接在Azure ML上使用R，由于微软开始兼容开源，并参与开源项目的开发，所以我们对R的改变应该是增加而不是分枝。</p>
<p><strong>问：您认为云计算未来发展的方向和趋势是什么？</strong></p>
<p>云计算是对传统计算和数据中心的重新定义，同时云计算也是一种全新的解决方案，它处理了以前许多无法解决的问题，其中包括计算、存储，以及网络等。所以，我认为云计算这种优化和变革在未来大有可为。</p>
<blockquote><p>胡鲁辉将在9月19-20日的MPD深圳软件工作坊，以及12月4-6日的TOP100summit上做分享，感兴趣的朋友可以关注一下。</p></blockquote>
<hr>
<h2>更多精彩，加入图灵访谈微信！</h2>
<p><img src="/img/bVkfQ4" alt="图片描述" title="图片描述"></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003753150";}i:2;a:11:{s:5:"title";s:18:"单元测试简述";s:4:"link";s:42:"http://segmentfault.com/a/1190000003752743";s:2:"id";s:42:"http://segmentfault.com/a/1190000003752743";s:7:"updated";s:25:"2015-09-16T10:43:38+08:00";s:9:"published";s:25:"2015-09-16T10:43:38+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"lhcpig";s:10:"author_uri";s:32:"http://segmentfault.com/u/lhcpig";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:8770:"
<p>最开始项目中是没有单元测试的，基本都是自己通过各种方式来实现测试的。比如修改代码，测完再改回来；再比如直接模拟用户操作，直接当黑盒测试，然后自己去看相应的逻辑有没有，状态有没有改变。</p>
<blockquote><p><strong>这些方式有几个缺点:</strong></p></blockquote>
<blockquote><ul>
<li><p>测试不完整，挖有一些隐藏的坑</p></li>
<li><p>改代码测试，在该回来的时候可能引入新bug</p></li>
<li><p>手工测试比较耗时</p></li>
<li><p>下次改需求时，需要再次手工测试</p></li>
</ul></blockquote>
<p>这个里面多次手工测试比较难受，太浪费时间了。以前由于一个逻辑牵扯比较多，构造对象比较复杂，仅仅用JUnit写测试的工作量还是太大，所以单元测试一直没有进行下去。<br>后来引入的mockito框架来用于新代码的测试，powermock用于以前的代码测试。下面将介绍一下mockito和powermock框架，就明白为什么要用这两个框架了。</p>
<hr>
<h2>Mockito</h2>
<p>mockito是用的比较广的mock框架。mock技术的目的和作用是模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试与测试边界以外的对象隔离开。<br>为了说明使用方法，先引入一下基本对象</p>
<pre><code class="java">public class User {
    private int userId;
    private ComplexObject complexObject;
    
    public int getUserId() {
        return userId;
    }
    //... construction getter
}</code></pre>
<pre><code class="java">public class Service {
    public boolean checkUser(User user) {
        if(user.getUserId() &lt; 100){
            return true;
        }
        return false;
    }
}</code></pre>
<p>默认的static import</p>
<pre><code class="java">import static org.mockito.Mockito.*;
import static org.junit.Assert.*;</code></pre>
<h3>Mock</h3>
<p>如果要测试<code>Service#checkUser</code>方法，我们就要构造User对象。假设ComplexObject构造很复杂，如果不用mock，测试将寸步难行。下面来看看mockito是如何构造一个假的User并进行测试的吧。</p>
<pre><code class="java">@Test
public void testCheckUser() throws Exception {
    Service service = new Service();
    User user = mock(User.class);
    when(user.getUserId()).thenReturn(2);
    boolean checkResult = service.checkUser(user);
    assertTrue(checkResult);
}</code></pre>
<p>上面可以看到只用mock方法就可以了，然后设置一下getUserId方法的返回就行了。when的语法理解很容易，就不解释了。<br>上面的when语句也可以换成</p>
<pre><code>doReturn(2).when(user).getUserId();
</code></pre>
<p>在这个例子中，这两种when的写法都是可行的。<br>一共有以下几种方式来模拟一个方法。</p>
<ul>
<li><p>doReturn</p></li>
<li><p>doCallRealMethod</p></li>
<li><p>doNothing</p></li>
<li><p>doThrow</p></li>
<li><p>doAnswer</p></li>
</ul>
<p>当然也有thenXXX这种形式。</p>
<h3>Spy</h3>
<p>spy和mock很像，都是模拟一个对象。但是mock是把所有方法都接管了，spy是默认调用对象的方法。如果先mock出一个对象，然后对每一个方法调用<code>doCallRealMethod</code>，这就相当于spy出一个对象。<br>所以spy和mock只是初始模拟对象的默认设置不一样而已，其他行为都是一样的。</p>
<h3>Annotation</h3>
<p>可以直接用注解来实现mock：</p>
<pre><code class="java">@Mock
User user;

@Before
public void initMocks() {
    MockitoAnnotations.initMocks(this);
}

@Test
public void testCheckUser() throws Exception {
    Service service = new Service();
    doReturn(2).when(user).getUserId();
    boolean checkResult = service.checkUser(user);
    assertTrue(checkResult);
}</code></pre>
<p>这个需要调用<code>initMocks(this)</code>来注入，这里是通过<code>@Before</code>，也可以通过<code>@RunWith</code>来调用<code>initMocks</code>方法。</p>
<p>也可以用Spy注解：</p>
<pre><code>@Spy User user;</code></pre>
<p>还有一个注解比较有用<code>@InjectMocks</code>，这个可以把对象注入到其他对象中去的。<br>下面稍微添加一下代码：</p>
<pre><code class="java">public class ComplexObject {
    @Override
    public String toString() {
        return "Complex lhcpig";
    }
    //...
}</code></pre>
<pre><code class="java">public class Service {
    public String handleUser(User user){
        return user.getComplexObject() + "";
    }
    //...
}</code></pre>
<pre><code class="java">public class TestService {

    @InjectMocks
    User user;
    @Spy
    ComplexObject complexObject;

    @Before
    public void initMocks() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testHandleUser() throws Exception {
        Service service = new Service();
        String s = service.handleUser(user);
        assertThat(s, is("Complex lhcpig"));
    }
    //...
}</code></pre>
<ul>
<li><p>注1：这里和之前的那个test有冲突，因为User的注解不一样，所以第一个test会报NotAMockException或者MissingMethodInvocationException异常。</p></li>
<li><p>注2：这里用Spy，可以不用额外代码，就CallRealMethod。</p></li>
</ul>
<h3>Verify</h3>
<p>这个是用来判断方法是否被调用，调用是否超时，调用了多少次等测试。</p>
<pre><code class="java">@Test
public void testCheckUser() throws Exception {
    Service service = new Service();
    when(user.getUserId()).thenReturn(2);
    boolean checkResult = service.checkUser(user);
    assertTrue(checkResult);
    verify(user).getUserId();
    verify(user, timeout(100)).getUserId();
    user.getUserId();
    verify(user, times(2)).getUserId();
}</code></pre>
<p>如果方法有参数，也可以验证参数。<br>这里只是简介，如果想详细了解Mockito，建议还是看<a href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html">官网文档</a>。</p>
<hr>
<h2>PowerMock</h2>
<p>Mockito不支持final方法，私有方法，静态方法，而PowerMock支持。所以这里也要介绍一下。但是还是不建议项目中使用，如果需要使用PowerMock才能测试，说明代码的可测试性不好，需要改进代码。一般都是历史遗留代码或者第三方库相关测试的时候才需要使用。</p>
<p>下面是使用方式</p>
<pre><code class="java">@RunWith(PowerMockRunner.class)
@PrepareForTest( { YourClassWithEgStaticMethod.class })
public class YourTestCase {
...
}</code></pre>
<p>给个例子，大家就理解了</p>
<pre><code class="java">@RunWith(PowerMockRunner.class)
@PrepareForTest( { Service.class })
public class TestService {

    @Before
    public void initMocks() {
        mockStatic(Service.class);
    }

    @Test
    public void testTestStaticFinal() throws Exception {
        PowerMockito.when(Service.testStaticFinal()).thenReturn("mock1");
        assertEquals("mock1", Service.testStaticFinal());
    }

    @Test
    public void testPrivate() throws Exception {
        Service t = mock(Service.class);
        PowerMockito.when(t, "testPrivate").thenReturn("xxx");
        doCallRealMethod().when(t).testPrivateForPublic();
        assertEquals("xxx", t.testPrivateForPublic());
    }

    @Test
    public void testTestPrivateWithArg() throws Exception {
        Service t = spy(new Service());
        String arg = "dd";
        PowerMockito.when(t, "testPrivateWithArg", arg).thenReturn("lhc");
        assertEquals("lhc", t.getTestPrivateWithArg(arg));
    }
}</code></pre>
<pre><code class="java">public class Service {

    public static final String testStaticFinal() {
        System.out.println("testStaticFinal");
        return "static final";
    }

    private String testPrivate() {
        System.out.println("testPrivate");
        return "private";
    }

    public String testPrivateForPublic() {
        System.out.println("testPrivateForPublic");
        return testPrivate();
    }

    private String testPrivateWithArg(String arg) {
        System.out.println("testPrivateWithArg");
        return arg + "x";
    }
}</code></pre>
<p>私有方法用PowerMock测试后，如果要修改名字就会很麻烦，重构起来也可能会影响测试用例。所PowerMock的正确使用方式是尽量不使用。</p>
<p>因为要反射调用私有方法，所以写法没有mockito那么优雅。我这里使用的是基于Mockito的PowerMock，所以可以混合使用，比如上面用到的spy，when等。当然PowerMock还有基于其他mock框架（EasyMock）的扩展，这里就不再进一步介绍了。</p>
<p>想让测试更加高效，测试框架还是其次，写出可测试性的代码才是最重要的。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003752743";}i:3;a:11:{s:5:"title";s:55:"关于 mac OSX 10.11 下 Rootless 模式的一些见解";s:4:"link";s:42:"http://segmentfault.com/a/1190000003751923";s:2:"id";s:42:"http://segmentfault.com/a/1190000003751923";s:7:"updated";s:25:"2015-09-16T01:40:00+08:00";s:9:"published";s:25:"2015-09-16T01:40:00+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:10:"NaixSpirit";s:10:"author_uri";s:36:"http://segmentfault.com/u/naixspirit";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:3078:"
<p>最近, 有用户反应在 OS X 10.11(以下简称 10.11)下安装 <a href="https://github.com/FIRHQ/fir-cli">fir-cli</a> 报错, 报错的截图如下:<br><img src="http://7rf35s.com1.z0.glb.clouddn.com/0.png" alt="报错截图" title="报错截图"></p>
<p>从报错信息上来看, 是操作系统权限的问题, 可是用户执行命令的时候已经使用了 sudo 了, 为什么还报错呢? <br>事实上, 这就是 10.11 新增的 <strong>Rootless</strong> 引起的.</p>
<p>那么什么是 Rootless 呢? <br>知乎上有篇 <a href="http://www.zhihu.com/question/31116473">文章</a> 解释的很清楚, 简单的来说, Rootless 机制限制了 Root 账户的权限, 使其没有了对系统的完全控制权.</p>
<p>受到权限影响的有以下几点:</p>
<ul>
<li><p>禁止直接对 <code>/System</code>, <code>/bin</code>, <code>/sbin</code>, <code>/usr</code> 目录的修改(<code>/usr/local</code> 目录除外). 只有通过苹果开发者认证的 app 才有权限对其修改.</p></li>
<li><p>禁止注入系统进程. 某些需要注入系统进程(finder, messages 等等系统级别的进程)的程序, debugger 无法使用了.</p></li>
<li><p>禁止加载内核扩展(kexts), 除非它们被苹果开发者正确的签名</p></li>
</ul>
<p>这些修改最明显的好处就是: 恶意 app 无法通过用户授权的方式从而获得所有系统权限了.</p>
<p>当然, 它带来的副作用也是巨大的, 一些合法的 app 也无法获得系统权限了. 比如: Homebrew, CocoaPods 以及所有需要在 <code>/usr/bin</code> 目录下有可执行权限的 app.</p>
<p>如何解决合法 app 也报错的问题呢?</p>
<ul>
<li>
<p>对于 CocoaPods, fir-cli 等以 Ruby Gem 包形式发布的 app, 有以下三种解决办法:</p>
<ol>
<li>
<p>使用 <a href="https://rvm.io/">RVM</a> 安装 Ruby, 再安装 fir-cli(推荐)</p>
<pre><code class="shell"># Install RVM:
$ \curl -sSL https://get.rvm.io | bash -s stable --ruby

$ gem install fir-cli</code></pre>
</li>
<li>
<p>指定 fir-cli 中 bin 文件的 PATH</p>
<pre><code class="shell">$ export PATH=/usr/local/bin:$PATH;sudo gem install -n /usr/local/bin fir-cli</code></pre>
</li>
<li>
<p>重写 Ruby Gem 的 bindir</p>
<pre><code class="shell">$ echo 'gem: --bindir /usr/local/bin' &gt;&gt; ~/.gemrc
$ sudo gem install fir-cli</code></pre>
</li>
</ol>
</li>
<li><p>对于 homebrew 安装的某些 app, 需要 app 作者修改其安装路径, 修改为 <code>/usr/local/bin</code></p></li>
<li><p>开机按住Command＋R 直接关闭 Rootless(由于 osx 系统的升级, 这种方式不一定能生效)</p></li>
</ul>
<p>我个人认为, Rootless 这种做法, 使得 OS X 系统越来越趋于封闭, 越来越像 Windows.</p>
<blockquote><p><strong>What is the freedom?</strong><br>Freedom is the power to decide what your computer does, and the only way to have this freedom is to know what your computer is doing. <br>Freedom is a computer that is without secrets, one where everything can be known if you care enough to find out.<br>-- The Linux Command Line</p></blockquote>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003751923";}i:4;a:11:{s:5:"title";s:68:"前端之Angular2实战：基于Webpack与ES6的Angular2工程搭建";s:4:"link";s:42:"http://segmentfault.com/a/1190000003751829";s:2:"id";s:42:"http://segmentfault.com/a/1190000003751829";s:7:"updated";s:25:"2015-09-15T23:56:02+08:00";s:9:"published";s:25:"2015-09-15T23:56:02+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:6350:"
<p>​笔者在之前的开发流中习惯了Webpack+ES6+React的Workflow，Angular2本身也是秉持的模块的思想，因此笔者在学习Angular2的时候首先想到的也就是将原本流程里的React变为Angular2。Angular2官网上的Quick Start是用的TypeScript，准确的说，是AtScript的规范。Angular2本身引入了大量的第三方库，就像官方示例上面的，有JSPM的System、Reflect等等，这也给搭建环境时造成了一定的困扰。本节的代码笔者已经上传到了<a href="https://github.com/wxyyxc1992/angular2-es6-webpack-quickstart">Github</a>。Webpack的安装与基本使用就不在这边赘述，没学过的小伙伴可以看笔者其他的博文。</p>
<h1>Setup</h1>
<h2>Directory(文件目录)</h2>
<pre><code>|package.son 存放nom相关的配置

|webpack.config.js 存放webpack相关的配置

|assets 存放代码以及资源文件

├── common 存放通用的资源文件

│   ├── font 字体文件

│   ├── css 通用样式文件

│   └── img 图片文件

├── components 组件

│   ├── hello

│   │   └── hello.js

│   └── helloTemplate

│       ├── helloTemplate.html

│       └── helloTemplate.js

├── main.js 入口文件

├── models 模型以及数据类

├── services 服务

├── utils 工具类

└── widgets 界面插件类</code></pre>
<h2>package.json</h2>
<p>搭建环境需要大量的Npm依赖项，都列举在了下面：</p>
<pre><code class="json">{
  "name": "angular2-es6-webpack-quickstart",
  "version": "0.0.1",
  "description": "repository for starter with angular2,es6 and webpack",
  "main": "main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [
    "angular2",
    "es6",
    "webpack"
  ],
  "author": "chevalier",
  "license": "ISC",
  "dependencies": {
    "angular2": "^2.0.0-alpha.37",
    "reflect-metadata": "^0.1.1",
    "rx": "^2.5.3",
    "zone.js": "^0.5.4"
  },
  "devDependencies": {
    "a1atscript": "^0.4.4",
    "autoprefixer-loader": "^2.0.0",
    "babel": "^5.8.23",
    "babel-core": "^5.8.23",
    "babel-loader": "^5.3.2",
    "css-loader": "^0.16.0",
    "file-loader": "^0.8.4",
    "image-webpack-loader": "^1.6.1",
    "imagemin": "^3.2.0",
    "node-sass": "^3.3.2",
    "react-mixin": "^1.7.0",
    "sass-loader": "^2.0.1",
    "scss-loader": "^0.0.1",
    "style-loader": "^0.12.3",
    "url-loader": "^0.5.6",
    "webpack": "^1.12.0",
    "typescript": "^1.6.0-beta",
    "typescript-simple-loader": "^0.3.7",
    "es6-shim": "^0.33.1",
    "ng-annotate": "^1.0.2",
    "raw-loader": "^0.5.1",
    "ng-annotate-webpack-plugin": "^0.1.2"
  }
}
</code></pre>
<h2>webpack.config.js</h2>
<p>存放Webpack配置：</p>
<pre><code class="javascript">var path = require('path');
module.exports = {
    entry: path.resolve(__dirname, 'assets/main.js'),
    // Config for our build files
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: "bundle.js"
    },
    module: {
        loaders: [
            {test: /\.jsx$/, exclude: /(libs|node_modules)/, loader: 'babel?stage=0'},
            {test: /\.(es6|js)$/, exclude: /(libs|node_modules)/, loader: 'babel?stage=0'},
            {test: /\.(png|jpg|ttf|woff|svg|eot)$/, loader: 'url-loader?limit=8192'},// inline base64 URLs for &lt;=8k images, direct URLs for the rest
            {
                test: /\.css$/,
                loader: 'style-loader!css-loader!autoprefixer-loader?browsers=last 2 versions'
            },
            // support for .html as raw text
            {test: /\.html$/, loader: 'raw'},
            {
                test: /\.(scss|sass)$/,
                loader: 'style-loader!css-loader!autoprefixer-loader?browsers=last 2 versions!sass?sourceMap'
            },
            {
                test: /\.ts$/,
                exclude: /(libs|node_modules)/,
                loader: 'typescript-simple',
                query: {
                    'ignoreWarnings': [
                        2300, // 2300 -&gt; Duplicate identifier
                        2309, // 2309 -&gt; An export assignment cannot be used in a module with other exported elements.
                        2346, // 2346 -&gt; Supplied parameters do not match any signature of call target.
                        2432  // 2432 -&gt; In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.
                    ]
                }
            }
        ],
    },
    externals: {
        jquery: "jQuery",
        pageResponse: 'pageResponse'
    },
    resolve: {
        alias: {
            libs: path.resolve(__dirname, 'libs'),
            nm: path.resolve(__dirname, "node_modules")
        }
    }
};</code></pre>
<h1>HelloWorld</h1>
<p>环境搭建完毕，自然要开始写我们的HelloWorld。这里组件的模块化以及引入都是用的ES6的语法，然后通过Webpack统一编译。利用Webpack同样可以支持AtScript的语法：</p>
<p>hello.js</p>
<pre><code class="javascript">/**
 * Created by apple on 15/9/14.
 */
import 'nm/reflect-metadata/Reflect.js';
import 'nm/zone.js/lib/zone.js';
import 'nm/es6-shim';
import { Component, View, bootstrap } from 'nm/angular2/angular2';

@Component({
    selector: 'my-app'
})

@View({
    template: '&lt;h1&gt;Hello {{ name }}&lt;/h1&gt;'
})

class MyAppComponent {
    constructor() {
        this.name = 'World';
    }
}

bootstrap(MyAppComponent);</code></pre>
<p>main.js</p>
<pre><code class="java">import {MyAppComponent} from "./components/hello/hello.js";

import {HelloTemplateComponent} from "./components/helloTemplate/helloTemplate.js";

import {Component, View, bootstrap} from 'nm/angular2/angular2';

bootstrap(MyAppComponent);</code></pre>
<p>index.html</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;my-app&gt;&lt;/my-app&gt;
&lt;/body&gt;
&lt;script src="dist/bundle.js"&gt;&lt;/script&gt;
&lt;/html&gt;</code></pre>
<h2>Run</h2>
<pre><code>npm install http-server -g
http-server</code></pre>
<p>然后打开localhost:8080即可以看到Angular2为我们渲染的新界面。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003751829";}i:5;a:11:{s:5:"title";s:49:"正则表达式巧用 Unicode 匹配特殊字符 ";s:4:"link";s:42:"http://segmentfault.com/a/1190000003751415";s:2:"id";s:42:"http://segmentfault.com/a/1190000003751415";s:7:"updated";s:25:"2015-09-15T21:57:36+08:00";s:9:"published";s:25:"2015-09-15T21:57:36+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:4:"zwhu";s:10:"author_uri";s:30:"http://segmentfault.com/u/zwhu";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:4231:"
<h1>正则表达式巧用 Unicode 匹配特殊字符</h1>
<p>作者 @<a href="http://github.com/zwhu">zwhu</a></p>
<p>原文章 @<a href="https://github.com/zwhu/blog/issues/4">github</a></p>
<p>首先声明，本文所有的代码都是在 ES6 下面运行，ES5需要修改之后才能运行，但是本文没有涉及到太多的ES6新特性，而且由于v8对u修饰符不支持，最后的实现也基本是用ES5的知识写的代码。</p>
<p>最初我只是想记录下正则表达式用unicode的方式来匹配特殊字符，写着写着发现 v8 对 u 修饰符的不支持，又转而去研究怎么转换字符串到utf-16的格式，在研究怎么转换的过程中发现ES5的正则对 unicode 编码单元 &gt; 0x10000 的字符串不支持，再转而去实现了一遍对大于 0x10000 的字符串的转换，特此记录。</p>
<p>之前有遇到过一个实用正则表达式匹配特殊字符的需求，例如一段文本 <code>'ab*cd$你好我也好]\nseg$me*ntfault\nhello,world'</code>，用户可以选择用 * 或者 $ 来分割字符串。</p>
<p>在javascript中，<code>$</code> 和 <code>*</code> 都是预定义的特殊字符，不能直接写在正则表达式中，而需要转义，写成 <code>/\$/</code>或者<code>/\*/</code>。<br>我们需要根据用户的选择来写正则表达式，封装成一个函数就是:</p>
<pre><code class="js">function reg(input) {
    return new RegExp(`\\${input}`)
}</code></pre>
<p>这种写法初看上去很美好，将字符都转义之后遇到一些特殊的字符可以匹配，然而现实是残酷的：当用户输入的是<code>n</code>或者<code>t</code>这一类的字符的话，返回的正则表达式为<code>/\n/</code>或者<code>/\t/</code>,匹配的就是所有的制表符，这就违背了用户的初衷。</p>
<p>通常有一种写法就是把所有需要转义的特殊字符都列出来，然后再逐一匹配，这种写法很耗费精力，而且可能因为没有统计到的特殊字符而出现漏匹配的情况。</p>
<p>这个时候unicode就隆重登场了，在 <code>JavaScript</code> 中，我们也可以用unicode来表示一个字符，例如 'a' 可以写成'\u{61}'， '你' 也可以写成 '\u{4f60}'。</p>
<p>关于unicode的介绍大家可以看 <a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode与JavaScript详解</a></p>
<p><code>ES5</code>中提供了 <code>charCodeAt()</code> 方法来返回指定索引处字符的 Unicode 数值，但是 Unicode 编码单元 &gt; 0x10000 的除外，<code>ES2015</code> 中又增加了一个新的方法 <code>codePointAt()</code> 可以返回大于 0x10000 字符串的数值。返回的数值是十进制的，此时我们还需要通过<code>toString(16)</code>转成16进制。<br>封装之后的函数如下</p>
<pre><code class="js">function toUnicode(s) {
    return `\\u{${s.codePointAt().toString(16)}}`
}

toUnicode('$') -&gt; '\u{24}'
</code></pre>
<p>重新封装reg函数为</p>
<pre><code class="js">function reg(input) {
    return new RegExp(`${toUnicode(input)}`, 'u')
}</code></pre>
<p>其实写到这里，我希望是对的，但是很不幸，V8 不支持 RegExp 的 u 修饰符。V8支持的话，写到这里就应该结束了，没关系，这里只是提供一种用unicode的方式来转义特殊字符的思想。</p>
<p>虽然v8不支持u修饰符，作为一个有追求的码农，当然不能止步于此，我们也可以使用其他方法继续把这个完善</p>
<pre><code class="js">function toUnicode(s) {
  var a = `\\u${utf(s.charCodeAt(0).toString(16))}`
  if(s.charCodeAt(1))
    a = `${a}\\u${utf(s.charCodeAt(1).toString(16))}` 
  return a      
}

function utf(s) {
    return Array.from('00').concat(Array.from(s)).slice(-4).join('')
}

// 这里用var而没有用let声明，是因为这些代码直接复制到 chrome 的控制台下就可以看到执行结果
// 测试一下
// toUnicode('a')   --&gt; "\u0061"
// toUnitcode('𠮷')  --&gt; "\ud842\udfb7"

function reg(input) {
    return new RegExp(`${toUnicode(input)}`)
}
// 再测试一下
reg('$').test('$') --&gt; true</code></pre>
<p>写完啦，看到最后的同学，如果觉得对你有帮助的话，就点个推荐呗。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003751415";}i:6;a:11:{s:5:"title";s:48:"[译]事件循环，Node.js背后的核心概念";s:4:"link";s:42:"http://segmentfault.com/a/1190000003751278";s:2:"id";s:42:"http://segmentfault.com/a/1190000003751278";s:7:"updated";s:25:"2015-09-15T21:15:26+08:00";s:9:"published";s:25:"2015-09-15T21:15:26+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:12:"菜菜蔡伟";s:10:"author_uri";s:38:"http://segmentfault.com/u/caicaicaiwei";s:2:"re";a:1:{s:4:"rank";s:1:"2";}s:7:"summary";s:4334:"
<h2>前言</h2>
<p>如果你了解过<code>Node.js</code>，那么你一定听说过事件循环。你一定想知道它为什么那么特殊，并且为什么你需要关注它？此时此刻的你，可能已经写过许多基于<code>Express.js</code>的后端代码，但没有接触到任何的循环。</p>
<p>在下文中，我们会先在一个更高的，无关操作系统的层面上了解事件循环，然后再去深入到<code>Node.js</code>中观察它。</p>
<h2>事件和事件处理器</h2>
<p>在事件循环里，有两个主要角色：</p>
<ul>
<li><p>事件</p></li>
<li><p>事件处理器，即这些事件的订阅者</p></li>
</ul>
<p>事件，可以是十分底层的操作系统事件，如“文件已经准备好被写入”或“收到了一个新的HTTP请求”。<br>事件处理器，则是当指定事件触发时，执行的一段代码。</p>
<h2>事件循环中，事件的获取和事件处理器的执行</h2>
<p><img src="http://bytearcher.com/articles/event-loop-10-000ft/event-loop.svg" alt="eventloop" title="eventloop"></p>
<p>事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。</p>
<p>当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。</p>
<p>即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p>
<h2>在事件处理器的执行代码中触发了事件</h2>
<p>一个有趣而且常会出现的情况是，在执行一个事件处理器的代码里，代码触发了另一个事件。例如，在文件可以被读之后，这个事件的处理器开始读取内容，期间处理器又触发了一个写事件，来将这个文件中已读取的这部分内容响应给正在处理的HTTP请求。写入完毕之后，继续读取文件。这就是事件循环保持运作的方式。</p>
<p>事件被触发，然后以订阅顺序执行处理器，不断往复。这个循环圈就是事件循环控制流的关键 ，在没有更多的订阅事件的处理器之后，<code>Node.js</code>就会退出。</p>
<h2>操作系统的帮助</h2>
<p>事件在实质上是从哪里来？事件循环会不断获取下一个被触发的事件，这是如何发生的？你是对的，这需要操作系统的帮助。幸运的是，现代操作系统中有许多方式可以实现这些（<code>select</code>，<code>epoll</code>，<code>kqueue</code>，<code>IOCP</code>）。在日常使用时，通常会在操作系统提供的这些方式上会再抽象出一层（在<code>Node.js</code>中，就是<code>libuv</code>）。</p>
<p>另一个需要操作系统帮助的，就是事件的订阅，如注册在特定的事件发生时需要执行的代码。这也是事件循环中必须要实现的。</p>
<h2>
<code>Node.js</code>中的事件循环</h2>
<p>事件循环是<code>Node.js</code>中非常核心的组成部分，许多<code>Node.js</code>的特性都依赖于它，它既有积极的影响也不好的影响。比如在处理I/O密集任务时的性能提升和缺乏足够信息量的错误堆栈信息。<code>Node.js</code>异步回调驱动的编程范式，便直接是源于事件循环的存在。</p>
<p>每一个<code>Node.js</code>进程中都存在一个事件循环。只要进程存在，它就存在，一直不间断地调度执行着你程序中的方法和操作系统方法。事件循环以一个无限循环的形式启动，存在于<code>Node.js</code>二进制文件里<code>main</code>函数的最后，当没有更多可被执行的事件处理器时，它就退出。它运行于单个线程中，并且事件处理器是一个接一个顺序执行的。</p>
<h2>原文链接</h2>
<p><a href="http://bytearcher.com/articles/event-loop-10-000ft/">http://bytearcher.com/articles/event-loop-10-000ft/</a></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003751278";}i:7;a:11:{s:5:"title";s:28:"深入理解javascript函数";s:4:"link";s:42:"http://segmentfault.com/a/1190000003751038";s:2:"id";s:42:"http://segmentfault.com/a/1190000003751038";s:7:"updated";s:25:"2015-09-15T19:57:49+08:00";s:9:"published";s:25:"2015-09-15T19:57:49+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:13:"yuhualingfeng";s:10:"author_uri";s:39:"http://segmentfault.com/u/yuhualingfeng";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4892:"
<p>函数实际上是对象,每个函数都是Function类型的实例,且与其他类型一样具有属性和方法.由于函数是对象,故函数名即为指向函数的指针,正是由于这一点,函数没有重载,重复定义函数只会后者替换前者.</p>
<h2>函数的定义</h2>
<p>函数的定义有三种:</p>
<ul><li><p>函数声明</p></li></ul>
<pre><code class="javascript">function sum(num1,num2){
return num1+num2;
}</code></pre>
<ul><li><p>函数表达式</p></li></ul>
<pre><code class="javascript">var sum=function(sum1,sum2){
 return sum1+sum2;
}</code></pre>
<ul><li><p>使用Function构造函数(不推荐使用)</p></li></ul>
<pre><code class="javascript">var sum=new Function('num1','num2','return num1 + num2;');</code></pre>
<p><code>注:</code>函数声明和函数表达式的唯一区别是函数声明会提前.意即函数调用在函数声明之前可以正常运行.</p>
<h2>作为值的函数</h2>
<p>前面提到函数是对象,所以函数也可以作为参数值或返回值.</p>
<pre><code class="javascript">//作为参数
function callSomeFunction(someFunction,someArgument){
reuturn someFunction(someArgument);
}

function add10(num){
return num+10;
}

var result=callSomeFunction(add10,10);
alert(result); //20

//作为返回值
function createCompareFunction(propertyName){
 return function(object1,object2){
 var value1 = object1[propertyName];
 var value2 = object2[propertyName];
   if(value1 &lt; value2){
   return -1;
   }
   else if(value1 &gt; value2){
   return 1;
   }
   else{
   return 0;
   }
 }
}
</code></pre>
<h2>函数内部属性</h2>
<p>在函数内部有两个特殊对象:<code>arguments</code> <code>this</code><br><code>arguments</code>是一个类数组对象,包含传入函数中的所有参数(这是其主要用途),除此之外,其还有一个callee的属性,该属性是一个指针,指向当前函数对象.<br><code>this</code>引用的是函数据以执行的环境对象.在调用函数之前,this的值是不确定的,当在全局对象中调用函数时,this引用的是全局对象window,当把函数赋值给某对象时,this指的是此对象.</p>
<pre><code class="javascript">window.color = "red";
function sayColor(){
alert(color);
}
sayColor(); //red

var o={color:'blue'};
o.sayColor = sayColor;
o.sayColor();//blue</code></pre>
<h2>函数的属性和方法</h2>
<ol>
<li><p>属性<br><code>length</code>:函数希望接收的命名参数的个数.<br><code>prototype</code>:这是一个非常耐人寻味的属性,它保存着函数的实例方法,意即到通过函数实例化得到的对象可以访问prototype中的方法.此属性在自定义引用类型和实现继承很有用处.</p></li>
<li><p>方法<br><code>apply</code> <code>call</code>这两个方法是函数的非继承方法.用途都是设置函数体内this对象的值.</p></li>
</ol>
<p><code>apply</code>接收两个参数,第一个是运行函数的作用域,通俗的说就是将这个参数作为this指向的值.第二个参数是数组作为执行函数的参数.</p>
<pre><code class="javascript">function sum(num1,num2){
return num1+num2;
}
function callSum(num1,num2){
return sum.apply(this,arguments);
}
alert(callSum(10,10)); //20</code></pre>
<p><code>call</code>接收的第一个参数也是运行函数的作用域,后面的参数也是传递给执行函数的参数,与<code>apply</code>不同的是,后面的参数并非数组,而是逐个列举出来的.</p>
<pre><code class="javascript">function sum(sum1,sum2){
return sum1+sum2;
}
function callSum(num1,num2){
return sum.call(this,num1,num2);
}
alert(callSum(10,10)); //20</code></pre>
<h2>构造函数</h2>
<p>ECMAScript中的构造函数可以创建特定类型的对象.内置的构造函数(例如Array Object)会自动出现在执行环境中.构造函数的首字母应该以大写字母开头,从而区分非构造函数.<br>要创建新的实例,必须使用new操作符,穿件新的实例会经历以下四个步骤:</p>
<ol>
<li><p>创建一个新对象</p></li>
<li><p>将构造函数的作用域赋值给新对象(因此this指向这个新对象);</p></li>
<li><p>指向构造函数中的代码.</p></li>
<li><p>返回新对象</p></li>
</ol>
<pre><code class="javascript">function Person(name,age,job){
this.name = name;
this.age = age;
this.job = job;
this.sayName = function(){
alert(this.name);
};
}

var person=new Person('Mr pu',24,'web developer');
</code></pre>
<p>构造函数与普通函数的区别在于构造函数在实例化时加了new关键字.其它地方完全一样.</p>
<p><strong><code>重要提示</code></strong> 在通过构造函数实例化对象时,请勿把方法放在构造函数中,因为每个函数(在这里指方法方法)都是对象,每次实例化一个对象时这个对象中会保存每一构造函数中的方法,这是很影响性能的.解决办法是把这些方法放在prototype属性中.</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003751038";}i:8;a:11:{s:5:"title";s:28:"配置一个强大的FireFox";s:4:"link";s:42:"http://segmentfault.com/a/1190000003750820";s:2:"id";s:42:"http://segmentfault.com/a/1190000003750820";s:7:"updated";s:25:"2015-09-15T18:54:18+08:00";s:9:"published";s:25:"2015-09-15T18:54:18+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:8:"xumenger";s:10:"author_uri";s:34:"http://segmentfault.com/u/xumenger";s:2:"re";a:1:{s:4:"rank";s:1:"2";}s:7:"summary";s:5867:"
<p>你的浏览器绝对不止是一个浏览器，安装一些插件，可以让你的浏览器变成神器。正是应了一个好的设计应该坚持的一个原则：<code>面向扩展开放，面向修改封闭，也就是说系统支持扩展，但是不支持修改。</code></p>
<p>其实不为其他，只是为了提升自己使用浏览器时候的效率，不至于浪费太多宝贵的时间！</p>
<p>我并没有使用Chrome，不为什么，就是因为使用FireFox习惯了！</p>
<p>另外参见这个问题和回答：<a href="http://segmentfault.com/q/1010000003737995"></a><a href="http://segmentfault.com/q/1010000003737995">http://segmentfault.com/q/1010000003737995</a>去注册一个FireFox的账户，在所自己所有的设备上的FireFox同步自己的书签和扩展插件！</p>
<p>更多的插件可以参见知乎的提问：<a href="http://www.zhihu.com/question/19655956"></a><a href="http://www.zhihu.com/question/19655956">http://www.zhihu.com/question/19655956</a>，我会等到需要用的时候再去安装！</p>
<p>另外下面我对这些插件的介绍也只是介绍了我常用的，可能还有一些强大的功能是没有提到的，所以还是要自己没事去捣鼓捣鼓！</p>
<h2>All-in-one sidebar</h2>
<p>侧栏控制，率获大奖的用户体验！</p>
<p>比如书签、浏览历史、插件管理都放在了侧边栏上，然后需要使用或者管理某些配置的时候可以很方便的拖出来。</p>
<p>对我来说最有用的就是不要在浏览器的工具栏显示书签，这样浏览网页的面积就更大了！</p>
<h2>FireBug</h2>
<p>为你的Firefox集成了浏览网页的同时随手可得的丰富开发工具。</p>
<h2>Adblock Plus</h2>
<p>Adblock plus是Adblock的加强版，可以阻挡特定网址及网页上的广告对象（例如图片、Flash）。</p>
<p>安装完成之后，浏览网页爽多了，不被那些垃圾的广告所干扰！</p>
<h2>Show Location</h2>
<p>显示服务器的地理位置。利用 IP 数据库，在浏览器的链接输入框可以显示网页服务器的位置。鼠标右键提示复制 IP。</p>
<h2>vimperator</h2>
<p>让你可以完全用键盘操作浏览器，这个插件可以让你类似使用vim的方式来使用firefox. 这对于使用linux的人来说非常的方便.。</p>
<p>详细的操作参见：<a href="http://yife.im/firefox-vim-vimperator/"></a><a href="http://yife.im/firefox-vim-vimperator/">http://yife.im/firefox-vim-vimperator/</a></p>
<p>以及：<a href="https://www.zfanw.com/blog/vimperator-firefox.html"></a><a href="https://www.zfanw.com/blog/vimperator-firefox.html">https://www.zfanw.com/blog/vimperator-firefox.html</a></p>
<h2>FireGestures</h2>
<p>使用鼠标手势操作浏览器。当然还有其他的鼠标手势的插件，但是我就用这个了。上面的vimperator是使用键盘操作，这个是使用鼠标手势操作，下面的链接对其进行了详细的讲解。</p>
<p><a href="http://www.linuxbyte.org/firefox-de-shu-biao-shou-shi-cha-jian-firegestures.html"></a><a href="http://www.linuxbyte.org/firefox-de-shu-biao-shou-shi-cha-jian-firegestures.html">http://www.linuxbyte.org/firefox-de-shu-biao-shou-shi-cha-jian-firegestures.html</a></p>
<p><strong>常用手势：</strong></p>
<ul>
<li><p>刷新 “<code>上下</code>” 跳过缓存的刷新为“<code>上下上</code>”</p></li>
<li><p>前进 “<code>右</code>”</p></li>
<li><p>后退 “<code>左</code>”</p></li>
<li><p>关闭标签 “<code>下右</code>”</p></li>
<li><p>切换到上一（下一）标签 “<code>上左</code>” “<code>上右</code>”</p></li>
<li><p><code>左上</code> 可以回到顶部</p></li>
<li><p><code>左下</code> 可以调到底部</p></li>
<li><p>新建空白标签页 “<code>左右</code>”</p></li>
<li><p>恢复最近关闭的标签页 “<code>右左</code>”</p></li>
<li><p>图片另存为 “<code>下左下</code>” 也可以用“<code>下右下</code>”将图片存到firefox默认的下载路径</p></li>
<li><p>后台打开链接 “<code>下</code>” 以要在后台打开的链接为起点向下画</p></li>
<li><p>网页向上一级 “<code>下上</code>”</p></li>
<li><p>快速切换标签页 <code>按住鼠标右键+鼠标滚轮向下</code> 在不松开的情况下用选择要转到的标签然后松开右键</p></li>
<li><p>转到浏览过的历史页 <code>按住鼠标右键+鼠标滚轮向上</code></p></li>
<li><p>自定义鼠标手势 “<code>左下右上左</code>”弹出“Firegestures选项”，在“映射”列表中选中你要修改的命令名称，点击“编辑”在“动作”行中输入L、R、U、D所表示的手势（L代表左，类推）</p></li>
</ul>
<h2>gooreplacer</h2>
<p><a href="http://liujiacai.net/gooreplacer/"></a><a href="http://liujiacai.net/gooreplacer/">http://liujiacai.net/gooreplacer/</a>有详细的介绍</p>
<p>众所周知，Google在某国造到全面封杀，导致无法访问google的一切资源。Google在全球范围内提供一些js库、css库的CDN服务，本是一件相当好的事情，但是在某国情况就不一样了。如果一个网站引用了Google的这些库（比如stackoverflow、reddit）,那么在某国的访问速度那是真慢，不是一般的慢!</p>
<p>比如之前我无法在StackOverFlow注册，就是因为上面的原因，安装这个插件就OK了。</p>
<h2>fireIE</h2>
<p>解雇IE，让火狐兼容IE的双核扩展，一键切换至IE内核，网银支付无忧愁。有了这个就不需要IETab2插件和网银支付插件了。</p>
<p>在浏览器的链接输入框中的右侧可以看到<code>高速</code>和<code>兼容</code>选项，其中<code>高速</code>代表使用火狐内核，<code>兼容</code>代表使用IE内核。</p>
<p>扩展已支持Adblock Plus，您将不再被IE引擎下的广告所打扰。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003750820";}i:9;a:11:{s:5:"title";s:19:"css-负margin总结";s:4:"link";s:42:"http://segmentfault.com/a/1190000003750411";s:2:"id";s:42:"http://segmentfault.com/a/1190000003750411";s:7:"updated";s:25:"2015-09-15T17:35:00+08:00";s:9:"published";s:25:"2015-09-15T17:35:00+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"risker";s:10:"author_uri";s:32:"http://segmentfault.com/u/risker";s:2:"re";a:1:{s:4:"rank";s:1:"2";}s:7:"summary";s:3716:"
<blockquote>
<p>这篇文章是从原博客转载过来的，是2013年写的，有些不对的地方请指出。</p>
<p><a href="https://github.com/riskers/blog/issues/2">原文地址</a></p>
<p><a href="https://github.com/riskers/blog/issues">博客地址</a> , 欢迎订阅</p>
</blockquote>
<hr>
<p>这是一篇我自己关于负margin的理解，今天因为做项目用到了负margin，几经找资料，终于搞懂了，就赶紧记下来，免得忘记了！</p>
<ul>
<li><p>margin为正时，top、left属性是以content上（左）或垂直上方相连元素margin的下（右）边为参考线垂直向下（右）位移。</p></li>
<li><p>margin为负时，right、bottom属性是元素本身的border右（下）边为参考线水平向右（下）位移。</p></li>
</ul>
<h2>总结</h2>
<ol>
<li><p>盒子最后的显示大小等于盒子的<code>border</code>+<code>padding</code>+<code>正margin</code>，而<code>负margin</code>不会影响其大小。</p></li>
<li>
<p>margin为负且盒子static时：</p>
<ul>
<li><p>若属性为top、left，盒子将被拉进指定的方向;</p></li>
<li><p>若属性为bottom、right,将后续的元素拖拉进来，覆盖本来的元素。</p></li>
<li><p>若width没有被设置，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样</p></li>
</ul>
</li>
</ol>
<h2>选项卡demo</h2>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-8-25/31885201.jpg" alt="demo" title="demo"><br>怎么样实现上面菜单栏的选中状态下没有下边框的效果？<br>一般的思路是每个菜单栏设置边框，选中的状态没有下边框</p>
<p>其实还可以这样，边框不是上面菜单栏的，而是下面内容块的：<br><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-8-25/66815322.jpg" alt="demo2" title="demo2"><br>明白了把，所以只要给菜单栏设置<code>margin-bottom:-1px</code>就可以让下面的内容块上移1px，刚好让菜单栏的背景色盖住那个1px的边框。<br>如果选中状态没有背景色，就悲剧了：<br><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-8-25/49610791.jpg" alt="demo3" title="demo3"></p>
<p>请看 <a href="http://codepen.io/riskers/pen/gpVeyQ">demo</a></p>
<p>现在看这个例子没有明显展示出负margin的能力，再看下面的</p>
<h2>负margin加宽元素</h2>
<p>再看一个width没有设置，通过负margin加宽的元素的布局例子，这是很常见的例子，如果不用负margin，就会很麻烦呢<br><a href="http://codepen.io/riskers/pen/GJVdRw">demo</a></p>
<h2>圣杯布局</h2>
<p>因为BFC有这个特性：</p>
<blockquote><p>元素在设定<code>width</code>时，添加<code>border</code>、<code>padding</code>、<code>margin</code>会导致元素变宽；但是在没有设定<code>width</code>时，元素会自动填满父元素，添加<code>padding</code>、<code>border</code>、<code>margin</code>会使元素变窄，减少量等于他们三个之和。</p></blockquote>
<p><a href="http://codepen.io/riskers/pen/waVjBL">demo</a></p>
<h2>负margin实现两列等高布局</h2>
<p><a href="http://codepen.io/riskers/pen/VLoxpE">demo</a></p>
<h2>参考文章</h2>
<p><a href="http://www.cnblogs.com/jscode/archive/2012/08/28/2660078.html">负值之美</a></p>
<blockquote><p>以上是网上资料总结，我的总结就一句话：left、top不论正负自己动，right、bottom不论正负别的元素动！正的向外，负的向内！考虑问题的时候还要考虑到盒子的特性问题！！</p></blockquote>
<p>PS:遇到问题只要先想想什么是margin，margin的作用是什么，则负margin的工作原理则迎刃而解！</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003750411";}i:10;a:11:{s:5:"title";s:45:"多维度分析：抽象类和接口的区别";s:4:"link";s:42:"http://segmentfault.com/a/1190000003750422";s:2:"id";s:42:"http://segmentfault.com/a/1190000003750422";s:7:"updated";s:25:"2015-09-15T17:34:34+08:00";s:9:"published";s:25:"2015-09-15T17:34:34+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:18:"OneAPM蓝海讯通";s:10:"author_uri";s:41:"http://segmentfault.com/u/oneapm_official";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:5321:"
<p>【编者按】本文作者是<a href="https://dzone.com/users/2571450/smalaca.html">Sebastian Malaca</a>，是面向对象编程的狂热者，不断深化研究整洁代码和高代码质量。本文中，作者通过多个方面深入剖析抽象类和接口的区别，并结合经验供读者借鉴学习，本文系 <a href="http://www.oneapm.com/index.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=abstractclass&amp;utm_campaign=SeptArti&amp;from=matefispac">OneAPM</a> 工程师编译整理。</p>
<p>在开发人员岗位面试时，是否了解抽象类和接口之间的基本区别是一个很重要的考量因素。</p>
<p><strong>显而易见？</strong></p>
<p>完全不是。笔者面试过很多人，通常问的第一个问题是关于接口和抽象类的区别。但实际上很少有程序员能给出正确的答案。</p>
<p>就这个问题来说，初级程序员可能都会清楚之间的区别，可能也并不一定理解其背后的原因，但其结构上的差异，特别是针对特定语言（几乎和所有的面向对象的语言一样）应该深入了解。</p>
<p>同时，笔者也发现其他职位候选人（有时甚至是高级职位）竟然也不知道这之间的差异，或者只知道的一个或几个。</p>
<p>如果只是需要了解这些内容那并不难，但这些都是面向对象的基础知识，因此想要设计良好的代码必须对其有一个深入的认识。</p>
<p>下面将详细介绍这些基础知识。</p>
<p><strong>继承</strong></p>
<p>下面将从众所周知的接口和抽象类的区别开始。这种差异是关于继承的，任何类都可以实现多个接口，但是只能扩展一个类，也只能有一个父类。</p>
<p>多个类扩展是一个语言特性，它存在于一些面向对象的语言。为什么呢？因为它带来的问题往往多于价值。</p>
<p>当一个类有许多父类时，有一个情况就是完全相同的方法会声明多个，因此必须显式地「告知」究竟需要的是哪一个。</p>
<p>这样的代码通常难以维护，因为对其进行的任何修改或者重构都必须小心地检查。另一方面，如果一个类需要扩展（至少）两个拥有相同方法的类，那么 DRY 规则显然会被破坏(因此需要从别处下手），或者说会干扰到 Single Responsibility Principle (SAP)。</p>
<p>「如果多个类的继承如此糟糕，为什么它可以实现许多接口呢？」——如果这样的问题在你的脑海盘旋，我不得不承认这是一个绝妙的问题。</p>
<p>然而，答案很简单。每一个接口都是基于函数而不是一个类去实现。所以，即使实现十个不同的接口，每个包含相同的方法声明，内部也不会发生冲突。接口保证了方法的存在，而不是去说明方法的实现，这意味着，只要不违反 SRP ，你完全可以实现多个接口。</p>
<p><strong>方法的可见度</strong></p>
<p>接口中的所有方法都是 Public 的，但对于抽象类的声明并没有这样的规则，当然不能是 Private 。为什么不能 Private？因为一个抽象方法需要在子类中实现，但 Private 无法访问子类，因此不抽象类不可能存在 Private 属性。</p>
<p>接着回归主题。正如上文写道的，接口是一个函数的保证，你可以把它当作使用接口的类和实现这个接口的类之间的一个合约——保证一个特定类将实现所有声明的方法。这也是为什么这些方法必须是 Public 的原因。因为被严格的限制到了实现上，所以其他一切都不成问题。</p>
<p>然而，当涉及到抽象类时并非这样。我们总是可以有不同的类组，除了这几方面基本上不同以外，其他地方几乎一样，类体的公共方法也是非常相似的。在这种情况下，可以创建 Protected 方法来保持类之间的差异。Template Method 就是一个很典型的例子。</p>
<p><strong>声明和定义</strong></p>
<p>接口只能包含方法声明，而抽象类还可以包含方法的定义。</p>
<p>接口的重点在于提供特定函数，而抽象类还在于子类实现的相似性，不仅仅是其中的函数。</p>
<p><strong>常量</strong></p>
<p>接口和抽象类中都可以定义常量。这是因为这些值不依赖于特定对象，对它们来说都是相同的。</p>
<p><strong>属性</strong></p>
<p>抽象类可以包含属性，但接口却不能。原因与声明和定义是一样的。</p>
<p><strong>总结</strong></p>
<p>除了说明差异，笔者也试图解释它产生的原因。这不仅是因为人们发明某个语言时的突发奇想，而是源于语言背后所支撑的理念。</p>
<p>原文链接：<a href="https://dzone.com/articles/differences-between-abstract-class-and-interface">Differences Between Abstract Class and Interface</a> </p>
<p><a href="http://www.oneapm.com/">OneAPM</a> 是应用性能管理领域的新兴领军企业，能帮助企业用户和开发者轻松实现：缓慢的程序代码和 SQL 语句的实时抓取。想阅读更多技术文章，请访问 <a href="http://news.oneapm.com/?utm_source=Community&amp;utm_medium=Article&amp;utm_term=abstractclass&amp;utm_campaign=SeptArti&amp;from=matefispac">OneAPM 官方博客</a>。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003750422";}i:11;a:11:{s:5:"title";s:65:"SVProgressHUD--比MBProgressHUD更好用的 iOS进度提示组件";s:4:"link";s:42:"http://segmentfault.com/a/1190000003749810";s:2:"id";s:42:"http://segmentfault.com/a/1190000003749810";s:7:"updated";s:25:"2015-09-15T15:48:49+08:00";s:9:"published";s:25:"2015-09-15T15:48:49+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"iOS122";s:10:"author_uri";s:32:"http://segmentfault.com/u/ios122";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:6165:"
<h1>简介</h1>
<p><img src="http://f.cl.ly/items/2G1F1Z0M0k0h2U3V1p39/SVProgressHUD.gif" alt="SVProgressHUD" title="SVProgressHUD"></p>
<p><code>SVProgressHUD</code>是简单易用的显示器,用于指示一个持续进行的任务的进度.</p>
<ul>
<li><p>项目主页: <a href="http://www.ios122.com/tag/svprogresshud/">SVProgressHUD</a></p></li>
<li><p>最新示例: <a href="https://github.com/TransitApp/SVProgressHUD/archive/master.zip">点击下载</a></p></li>
</ul>
<h1>快速入门</h1>
<h2>安装</h2>
<h3>通过Cocoapods</h3>
<pre><code class="ruby">pod 'SVProgressHUD'</code></pre>
<h3>手动安装</h3>
<ul>
<li><p>拖拽 <code>SVProgressHUD/SVProgressHUD</code> 文件 到你的项目.</p></li>
<li><p>注意把 <code>SVProgressHUD.bundle</code> 添加进 <code>Targets-&gt;Build Phases-&gt;Copy Bundle Resources</code>.</p></li>
<li><p>添加 <strong>QuartzCore</strong> framework 到你的项目.</p></li>
</ul>
<h2>使用</h2>
<p>(参见Xcode项目文档 <code>/Demo</code>)</p>
<p><code>SVProgressHUD</code> 作为一个单例（也就是说，它并不需要创建和实例化，你直接调用, 如<code>[SVProgressHUD method]</code>).</p>
<p><strong>使用<code> SVProgressHUD</code>是非常明智的！常用场景：下拉刷新，无限滚动，发送消息</strong></p>
<p>使用<code> SVProgressHUD</code>在您的应用程序通常看起来简单:</p>
<pre><code class="objective-c">[SVProgressHUD show];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // time-consuming task
    dispatch_async(dispatch_get_main_queue(), ^{
        [SVProgressHUD dismiss];
    });
});</code></pre>
<h3>显示 HUD</h3>
<p>您可以使用下面的方法中的任意一个来显示HUD,以及指示任务的状态：</p>
<pre><code class="objective-c">+ (void)show;
+ (void)showWithStatus:(NSString*)string;</code></pre>
<p>如果您想在HUD指示任务的进度，请使用下列操作之一：</p>
<pre><code class="objective-c">+ (void)showProgress:(CGFloat)progress;
+ (void)showProgress:(CGFloat)progress status:(NSString*)status;</code></pre>
<h3>隐藏 HUD</h3>
<p>HUD可以用以下方法隐藏:</p>
<pre><code class="objective-c">+ (void)dismiss;
+ (void)dismissWithDelay:(NSTimeInterval)delay;</code></pre>
<p>如果你想显示多个HUD ，可以使用使用一下方法：</p>
<pre><code class="objective-c">+ (void)popActivity;</code></pre>
<p>该HUD将自动消失, <code>popActivity</code>将与显示的次数匹配。</p>
<h3>显示一个提示消息</h3>
<p>也可以用于显示一个提示信息。所述显示时间取决于给定的字符串的长度（ 0.5至5秒）。</p>
<pre><code class="objective-c">+ (void)showInfoWithStatus:(NSString *)string;
+ (void)showSuccessWithStatus:(NSString*)string;
+ (void)showErrorWithStatus:(NSString *)string;
+ (void)showImage:(UIImage*)image status:(NSString*)string;</code></pre>
<h3>自定义</h3>
<p><code>SVProgressHUD</code> 可通过下列方法进行个性化定制:</p>
<pre><code class="objective-c">+ (void)setDefaultStyle:(SVProgressHUDStyle)style;                  // 默认是SVProgressHUDStyleLight
+ (void)setDefaultMaskType:(SVProgressHUDMaskType)maskType;         // 默认是SVProgressHUDMaskTypeNone
+ (void)setDefaultAnimationType:(SVProgressHUDAnimationType)type;   // 默认是 SVProgressHUDAnimationTypeFlat
+ (void)setRingThickness:(CGFloat)width;                            // 默认是 2 pt
+ (void)setCornerRadius:(CGFloat)cornerRadius;                      // 默认是 14 pt
+ (void)setFont:(UIFont*)font;                                      // 默认是 [UIFont preferredFontForTextStyle:UIFontTextStyleSubheadline]
+ (void)setForegroundColor:(UIColor*)color;                         // 默认是 [UIColor blackColor], 仅对 SVProgressHUDStyleCustom 有效
+ (void)setBackgroundColor:(UIColor*)color;                         // 默认是 [UIColor whiteColor], 仅对 SVProgressHUDStyleCustom 有效
+ (void)setInfoImage:(UIImage*)image;                               //默认是bundle文件夹中的提示图片.
+ (void)setSuccessImage:(UIImage*)image;                            // 默认是bundle文件夹中的成功图片.
+ (void)setErrorImage:(UIImage*)image;                              // 默认是bundle文件夹中的错误图片.
+ (void)setViewForExtension:(UIView*)view;                          // 默认是nil,仅当设置了 #define SV_APP_EXTENSIONS 时有效.</code></pre>
<h3>通知</h3>
<p><code>SVProgressHUD</code>通过<code> NSNotificationCenter</code> 注册4份通知,以响应正在显示/消失:</p>
<ul>
<li><p><code>SVProgressHUDWillAppearNotification</code> 提示框即将出现</p></li>
<li><p><code>SVProgressHUDDidAppearNotification</code> 提示框已经出现</p></li>
<li><p><code>SVProgressHUDWillDisappearNotification</code> 提示框即将消失</p></li>
<li><p><code>SVProgressHUDDidDisappearNotification</code> 提示框已经消失</p></li>
</ul>
<p>每个通知传递一个<code> userInfo</code>字典,字典中包含HUD的状态字符串（如果有的话） ，可通过<code> SVProgressHUDStatusUserInfoKey</code>作为键来获取。</p>
<p><code> SVProgressHUD</code>还发送通知: <br><code> SVProgressHUDDidReceiveTouchEventNotification</code>当用户触摸整体屏幕上 和<br>' SVProgressHUDDidTouchDownInsideNotification<code>当用户直接在HUD接触。这两个通知没有</code> userInfo<code>参数，但包含了有关的触摸的</code>UIEvent` 参数.</p>
<h3>App 扩展(App Extension)</h3>
<p>当在应用程序中使用<code>SVProgressHUD</code>时， 要定义常量 <code>#define  SV_APP_EXTENSIONS</code>避免使用不可用的API。然后从你的扩展视图控制器中通过<code>self.view</code> 调用<code> setViewForExtension:</code> 即可。<br>注意: 此处指的是"App Extension",不是类目."File-&gt;New-&gt;Target...-&gt; iOS -&gt; App Extension-&gt;Photo Editing Extension". 如果未用到,可忽略.  更多细节参考: <a href="https://github.com/TransitApp/SVProgressHUD/issues/390"></a><a href="https://github.com/TransitApp/SVProgressHUD/issues/390">https://github.com/TransitApp/SVProgressHUD/issues/390</a></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003749810";}i:12;a:11:{s:5:"title";s:38:"前端之React实战-交互与动态UI";s:4:"link";s:42:"http://segmentfault.com/a/1190000003748297";s:2:"id";s:42:"http://segmentfault.com/a/1190000003748297";s:7:"updated";s:25:"2015-09-15T10:45:09+08:00";s:9:"published";s:25:"2015-09-15T10:45:09+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"2";}s:7:"summary";s:9310:"
<h1>Interactivity and Dynamic UIs</h1>
<h2>React.findDOMNode()</h2>
<p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 React.findDOMNode 方法。</p>
<pre><code>var MyComponent = React.createClass({
  handleClick: function() {
    React.findDOMNode(this.refs.myTextInput).focus();
  },
  render: function() {
    return (
      &lt;div&gt;
        &lt;input type="text" ref="myTextInput" /&gt;
        &lt;input type="button" value="Focus the text input" onClick={this.handleClick} /&gt;
      &lt;/div&gt;
    );
  }
});

React.render(
  &lt;MyComponent /&gt;,
  document.getElementById('example')
);
</code></pre>
<p>需要注意的是，由于 React.findDOMNode 方法获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个方法，否则会返回 null 。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会调用 React.findDOMNode 方法。</p>
<h3>getInitialState</h3>
<p>设置State的初始状态。</p>
<pre><code>var MyComponent = React.createClass({
    getInitialState: function(){
        return {
            count: 5
        }
    },
    render: function(){
        return (
            &lt;h1&gt;{this.state.count}&lt;/h1&gt;
        )
    }
});
</code></pre>
<h2>Style</h2>
<blockquote>
<p>参考资料</p>
<ul><li><p>React行内样式最佳实践</p></li></ul>
</blockquote>
<h3>Inline-style</h3>
<p>在React中，如果要使用行内元素，不可以直接使用style="”这种方式，可以有：</p>
<pre><code class="javascript">import React from 'react';

var style = {
  backgroundColor: '#EEE'
};

export default React.createClass({
  render: function () {
    return (
      &lt;div style={style}&gt;
      //或者&lt;div style={{backgroundColor: '#EEE'}}&gt;
        &lt;h1&gt;Hello world&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
});</code></pre>
<p>可以看出，React的style属性接收的也是一个JavaScript对象。</p>
<h3>Class</h3>
<p>你可以根据这个策略为每个组件创建 CSS 文件，可以让组件名和 CSS 中的 class 使用一个命名空间，来避免一个组件中的一些 class 干扰到另外一些组件的 class。</p>
<p><em>app/components/MyComponent.css</em></p>
<pre><code class="css">.MyComponent-wrapper {
  background-color: #EEE;
}</code></pre>
<p><em>app/components/MyComponent.jsx</em></p>
<pre><code class="javascript">import './MyComponent.css';
import React from 'react';

export default React.createClass({
  render: function () {
    return (
      &lt;div className="MyComponent-wrapper"&gt;
        &lt;h1&gt;Hello world&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
});</code></pre>
<h4>Multiple Class</h4>
<p>上文中提及的利用className方式赋值，如果在存在多个类名的情况下：</p>
<pre><code class="javascript">render: function() {
  var cx = React.addons.classSet;
  var classes = cx({
    'message': true,
    'message-important': this.props.isImportant,
    'message-read': this.props.isRead
  });
  // same final string, but much cleaner
  return &lt;div className={classes}&gt;Great, I'll be there.&lt;/div&gt;;
}</code></pre>
<h2>Event</h2>
<p>React对于事件的支持非常完善，可以查看这里。React 实现了一个“合成事件”层（synthetic event system），这个事件模型保证了和 W3C 标准保持一致，所以不用担心有什么诡异的用法，并且这个事件层消除了 IE 与 W3C 标准实现之间的兼容问题。“合成事件”额外提供了两个好处：<strong>自动绑定上下文和事件委托</strong></p>
<ul>
<li><p>“合成事件”自动将事处理件方法的上下文绑到当前组件，所以 <code>handleClick</code> 方法里面可以直接使用<code>this.setState</code>。</p></li>
<li><p>“合成事件”会以事件委托（event delegation）的方式绑定到组件最上层，并且在组件卸载（unmount）的时候自动销毁绑定的事件。</p></li>
</ul>
<p>当然，在React中，也可以使用原生事件，比如你在 <code>componentDidMount</code> 方法里面通过 <code>addEventListener</code> 绑定的事件就是浏览器原生事件。使用原生事件的时候注意在 <code>componentWillUnmount</code> 解除绑定 <code>removeEventListener</code>。所有通过 JSX 这种方式绑定的事件都是绑定到“合成事件”，除非你有特别的理由，建议总是用 React 的方式处理事件。</p>
<h3>Event Bind</h3>
<p>最基本的绑定方式就是依靠类似于<code>onClick={handleClick}</code>的方式，要注意，这里不同于ng-click，onClick传递的参数只能是一个方法，而不能是一个调用。如果要简单来写的话可以采Lambda表达式的方式：</p>
<pre><code class="javascript">onClick={()=&gt;{alert(1);}}</code></pre>
<h4>Event Params</h4>
<p>给事件处理函数传递额外参数的方式：<code>bind(this, arg1, arg2, ...)</code></p>
<pre><code class="javascript">render: function() {
    return &lt;p onClick={this.handleClick.bind(this, 'extra param')}&gt;;
},
handleClick: function(param, event) {
    // handle click
}</code></pre>
<p>由上面可以看出，Event一般都是作为最后一个参数传递到handleClick中，这里的event是SyntheticEvent对象，它的主要属性如下：</p>
<pre><code class="javascript">boolean bubbles
boolean cancelable
DOMEventTarget currentTarget
boolean defaultPrevented
number eventPhase
boolean isTrusted
DOMEvent nativeEvent
void preventDefault()
void isDefaultPrevented()
void stopPropagation()
void isPropagationStopped()
DOMEventTarget target
number timeStamp
string type</code></pre>
<h4>List Element</h4>
<p>在React中，也会经常遇到需要为某个群组绑定事件的情况，可以参考如下代码：</p>
<pre><code class="javascript">var GroceryList = React.createClass({
  handleClick: function(i) {
    console.log('You clicked: ' + this.props.items[i]);
  },
  render: function() {
    return (
      &lt;div&gt;
        {this.props.items.map(function(item, i) {
          return (
            &lt;div onClick={this.handleClick.bind(this, i)} key={i}&gt;{item}&lt;/div&gt;
          );
        }, this)}
      &lt;/div&gt;
    );
  }
});
React.render(
  &lt;GroceryList items={['Apple', 'Banana', 'Cranberry']} /&gt;, mountNode
);</code></pre>
<h3>TouchEvent</h3>
<p>If you'd like to use React on a touch device such as a phone or tablet, simply call <code>React.initializeTouchEvents(true);</code> to enable touch event handling.</p>
<h3>接口暴露</h3>
<p>譬如在某个子组件中，提供了某个方法：</p>
<pre><code class="javascript">var ButtonComponent = React.createClass({
    getDragonKillingSword: function(){
        //送宝刀
    },
    render: function(){
        return (&lt;button onClick={this.getDragonKillingSword}&gt;屠龙宝刀，点击就送&lt;/button&gt;);
    }
});</code></pre>
<p>如果在父组件中想手动调用该方法，则可以利用ref方式：</p>
<pre><code class="javascript">var ImDaddyComponent = React.createClass({
  render: function(){
    return (
      &lt;div&gt;
        //其他组件
        &lt;ButtonComponent /&gt;
        //其他组件
      &lt;/div&gt;
    );
  }
});</code></pre>
<p>在父组件的功能方程中：</p>
<pre><code class="javascript">this.refs.getSwordButton.getDragonKillingSword();</code></pre>
<p>反之，如果需要在子组件中调用父组件的方法，则可以直接将父组件的方法作为Props参数传入到子组件中：</p>
<pre><code class="javascript">&lt;ButtonComponent clickCallback={this.getSwordButtonClickCallback}/&gt;</code></pre>
<h2>Ajax</h2>
<p>组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以在componentDidMount 方法中设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。</p>
<pre><code class="javascript">    var UserGist = React.createClass({
      getInitialState: function() {
        return {
          username: '',
          lastGistUrl: ''
        };
      },

      componentDidMount: function() {
        $.get(this.props.source, function(result) {
          var lastGist = result[0];
          if (this.isMounted()) {
            this.setState({
              username: lastGist.owner.login,
              lastGistUrl: lastGist.html_url
            });
          }
        }.bind(this));
      },

      render: function() {
        return (
          &lt;div&gt;
            {this.state.username}'s last gist is
            &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.
          &lt;/div&gt;
        );
      }
    });

    React.render(
      &lt;UserGist source="https://api.github.com/users/octocat/gists" /&gt;,
      document.body
    );</code></pre>
<p>不过笔者习惯还是将整个获取数据，处理数据的业务逻辑放在Angular中进行。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003748297";}i:13;a:11:{s:5:"title";s:27:"前端之React实战-组件";s:4:"link";s:42:"http://segmentfault.com/a/1190000003748289";s:2:"id";s:42:"http://segmentfault.com/a/1190000003748289";s:7:"updated";s:25:"2015-09-15T10:43:49+08:00";s:9:"published";s:25:"2015-09-15T10:43:49+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"3";}s:7:"summary";s:15682:"
<h1>Components</h1>
<p>React提供了和以往不一样的方式来看待视图，它以组件开发为基础。组件是React的核心概念，React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。你可以通过分割组件的方式去开发复杂的页面或某个功能区块，并且组件是可以被复用的。这个过程大概类似于用乐高积木去瓶装不同的物体。我们称这种编程方式称为<strong>组件驱动开发</strong>。</p>
<h2>Declaration：组件声明</h2>
<p>React是可以同时渲染HTML标签与组件的，但是要注意的是，一般Tags元素都是小写开头，而Component都是以大写字母开头，以下面为例：</p>
<pre><code class="javascript">var myDivElement = &lt;div className="foo" /&gt;;
React.render(myDivElement, document.getElementById('example'));</code></pre>
<p>而如果需要渲染一个Component：</p>
<pre><code class="javascript">var MyComponent = React.createClass({/*...*/});
var myElement = &lt;MyComponent someProperty={true} /&gt;;
React.render(myElement, document.getElementById('example'));</code></pre>
<h2>LifeCycle</h2>
<p>组件的生命周期分成三个状态：</p>
<ul>
<li><p>Mounting：已插入真实 DOM，即Initial Render</p></li>
<li><p>Updating：正在被重新渲染，即Props与State改变</p></li>
<li><p>Unmounting：已移出真实 DOM，即Component Unmount</p></li>
</ul>
<p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<ul>
<li><p>componentWillMount()</p></li>
<li><p>componentDidMount()</p></li>
<li><p>componentWillUpdate(object nextProps, object nextState)</p></li>
<li><p>componentDidUpdate(object prevProps, object prevState)</p></li>
<li><p>componentWillUnmount()</p></li>
</ul>
<p>此外，React 还提供两种特殊状态的处理函数。</p>
<ul>
<li><p>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</p></li>
<li><p>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</p></li>
</ul>
<h3>Ini­tial Render</h3>
<p><img src="https://camo.githubusercontent.com/461765618c95d7d3d0941d767a95855cb5698195/687474703a2f2f7279616e73756b616c652e636f6d2f76697a2f74682f6a732f72656163746a735f636f6d706f6e656e745f6c6966656379636c652f696e697469616c5f72656e6465722e706e67" alt="" title=""></p>
<h3>Props Change</h3>
<p><img src="https://camo.githubusercontent.com/89a1b3c9ec4282045c095b5e74c296de7165955a/687474703a2f2f7279616e73756b616c652e636f6d2f76697a2f74682f6a732f72656163746a735f636f6d706f6e656e745f6c6966656379636c652f70726f70735f6368616e67652e706e67" alt="" title=""></p>
<h3>State Change</h3>
<p><img src="https://camo.githubusercontent.com/10de2955e68ca334679daf4cf821b18b5364f029/687474703a2f2f7279616e73756b616c652e636f6d2f76697a2f74682f6a732f72656163746a735f636f6d706f6e656e745f6c6966656379636c652f73746174655f6368616e67652e706e67" alt="" title=""></p>
<p>这里可以看出，Props比State的改变会有多出一个shouldComponentUpdate的回调方法。</p>
<h3>Com­po­nent Unmount</h3>
<p><img src="https://camo.githubusercontent.com/c0390065e7dcd4e75ad6a146db705f8a23826716/687474703a2f2f7279616e73756b616c652e636f6d2f76697a2f74682f6a732f72656163746a735f636f6d706f6e656e745f6c6966656379636c652f756e6d6f756e742e706e67" alt="" title=""></p>
<p>如果需要判断某个组件是否挂载，可以isMounted()方法进行判断，可以用该方法来确保异步调用中的setState与forceUpdate方法不会被误用。不过该方法在ES6的类中已经被移除了，在未来的版本中也会被逐步移除。    </p>
<p>总结而言，一个完整的React Component的写法应该如下：</p>
<pre><code class="javascript">/**
 * @jsx React.DOM
 */

var React = require('react'),
    MyReactComponent = React.createClass({

    // The object returned by this method sets the initial value of this.state
    getInitialState: function(){
        return {};
    },

    // The object returned by this method sets the initial value of this.props
    // If a complex object is returned, it is shared among all component instances      
    getDefaultProps: function(){
        return {};
    },

    // Returns the jsx markup for a component
    // Inspects this.state and this.props create the markup
    // Should never update this.state or this.props
    render: function(){
        return (&lt;div&gt;&lt;/div&gt;);
    },

    // An array of objects each of which can augment the lifecycle methods
    mixins: [],

    // Functions that can be invoked on the component without creating instances
    statics: {
        aStaticFunction: function(){}
    },

    // -- Lifecycle Methods --

    // Invoked once before first render
    componentWillMount: function(){
        // Calling setState here does not cause a re-render
    },

    // Invoked once after the first render
    componentDidMount: function(){
        // You now have access to this.getDOMNode()
    },

    // Invoked whenever there is a prop change
    // Called BEFORE render
    componentWillReceiveProps: function(nextProps){
        // Not called for the initial render
        // Previous props can be accessed by this.props
        // Calling setState here does not trigger an an additional re-render
    },

    // Determines if the render method should run in the subsequent step
    // Called BEFORE a render
    // Not called for the initial render
    shouldComponentUpdate: function(nextProps, nextState){
        // If you want the render method to execute in the next step
        // return true, else return false
        return true;
    },

    // Called IMMEDIATELY BEFORE a render
    componentWillUpdate: function(nextProps, nextState){
        // You cannot use this.setState() in this method
    },

    // Called IMMEDIATELY AFTER a render
    componentDidUpdate: function(prevProps, prevState){
    },

    // Called IMMEDIATELY before a component is unmounted
    componentWillUnmount: function(){
    }

}); 

module.exports = MyReactComponent;</code></pre>
<h2>Props</h2>
<h3>getDefaultProps</h3>
<p>设置默认的Props.</p>
<h3>Attributes</h3>
<h4>children</h4>
<p>this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。</p>
<pre><code class="javascript">    var NotesList = React.createClass({
      render: function() {
        return (
          &lt;ol&gt;
          {
            this.props.children.map(function (child) {
              return &lt;li&gt;{child}&lt;/li&gt;
            })
          }
          &lt;/ol&gt;
        );
      }
    });

    React.render(
      &lt;NotesList&gt;
        &lt;span&gt;hello&lt;/span&gt;
        &lt;span&gt;world&lt;/span&gt;
      &lt;/NotesList&gt;,
      document.body
    );</code></pre>
<p>其效果图如下所示：</p>
<p>enter description here</p>
<h3>Validation</h3>
<pre><code class="javascript">React.createClass({
  propTypes: {
    // You can declare that a prop is a specific JS primitive. By default, these
    // are all optional.
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,

    // Anything that can be rendered: numbers, strings, elements or an array
    // containing these types.
    optionalNode: React.PropTypes.node,

    // A React element.
    optionalElement: React.PropTypes.element,

    // You can also declare that a prop is an instance of a class. This uses
    // JS's instanceof operator.
    optionalMessage: React.PropTypes.instanceOf(Message),

    // You can ensure that your prop is limited to specific values by treating
    // it as an enum.
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),

    // An object that could be one of many types
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),

    // An array of a certain type
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

    // An object with property values of a certain type
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

    // An object taking on a particular shape
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),

    // You can chain any of the above with `isRequired` to make sure a warning
    // is shown if the prop isn't provided.
    requiredFunc: React.PropTypes.func.isRequired,

    // A value of any data type
    requiredAny: React.PropTypes.any.isRequired,

    // You can also specify a custom validator. It should return an Error
    // object if the validation fails. Don't `console.warn` or throw, as this
    // won't work inside `oneOfType`.
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }
  },
  /* ... */
});</code></pre>
<h2>State</h2>
<p>React不提倡数据的双向绑定，而在用户行为下面产生的数据更新，React建议还是通过事件机制来处理。譬如下述例子中，输入框文本内容的改变，还是通过onChange事件，然后出发状态机的变化。</p>
<pre><code class="javascript">    var LikeButton = React.createClass({
      getInitialState: function() {
        return {liked: false};
      },
      handleClick: function(event) {
        this.setState({liked: !this.state.liked});
      },
      render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
          &lt;p onClick={this.handleClick}&gt;
            You {text} this. Click to toggle.
          &lt;/p&gt;
        );
      }
    });

    React.render(
      &lt;LikeButton /&gt;,
      document.getElementById('example')
    );</code></pre>
<h3>Props与State对比</h3>
<blockquote>
<p>参考资料</p>
<p>Props VS State</p>
</blockquote>
<p>组件的主要职责是将原始数据转化为HTML中的富文本格式，而Props与State协作完成这件事，换言之，Props与State的并集即是全部的原始数据。Props与State之间也是有很多交集的，譬如：</p>
<ul>
<li><p>Props与State都是JS对象。</p></li>
<li><p>Props与State的值的改变都会触发界面的重新渲染。</p></li>
<li><p>Props与State都是确定性的，即在确定的Props或者State的值的情况下都会得出相同的界面。</p></li>
</ul>
<p>不过Props顾名思义，更多的是作为Component的配置项存在。Props往往是由父元素指定并且传递给自己的子元素，不过自身往往不会去改变Props的值。另一方面，State在组件被挂载时才会被赋予一个默认值，而常常在与用户的交互中发生更改。往往一个组件独立地维护它的整个状态机，可以认为State是一个私有属性。他们的对比如下：</p>
<table>
<thead><tr>
<th>描述</th>
<th>Props</th>
<th>State</th>
</tr></thead>
<tbody>
<tr>
<td>是否可以从父元素获取初始值</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>是否可以被父元素改变</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>是否可以设置默认值</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>是否可以在组件内改变</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>是否可以设置为子元素的初始值</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>是否可以在子元素中改变</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2>Multiple Components</h2>
<h3>Children：组件Tag内包裹</h3>
<p>上文中提及过，一种利用组件内包裹的方式动态定义组件的方式，可以利用Props的children属性来获取所有包裹住的Dom对象。</p>
<h3>Nested Components</h3>
<pre><code>React主打的是组件驱动型编程，往往可以将一个大的组件拆分为几个小的组件，这里以头像控件为例：
</code></pre>
<pre><code class="javascript">var Avatar = React.createClass({
  render: function() {
    return (
      &lt;div&gt;
        &lt;ProfilePic username={this.props.username} /&gt;
        &lt;ProfileLink username={this.props.username} /&gt;
      &lt;/div&gt;
    );
  }
});

var ProfilePic = React.createClass({
  render: function() {
    return (
      &lt;img src={'https://graph.facebook.com/' + this.props.username + '/picture'} /&gt;
    );
  }
});

var ProfileLink = React.createClass({
  render: function() {
    return (
      &lt;a href={'https://www.facebook.com/' + this.props.username}&gt;
        {this.props.username}
      &lt;/a&gt;
    );
  }
});

React.render(
  &lt;Avatar username="pwh" /&gt;,
  document.getElementById('example')
);</code></pre>
<pre><code>有时候在某个组件内调用另一个组件，并不会进行渲染，譬如：
</code></pre>
<pre><code class="javascript">class Home extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;map/&gt;
      &lt;/div&gt;   
    );
  }
}
var map = React.createClass({
   render: function() {
      return (
          &lt;div id="map-canvas"&gt;
            &lt;span&gt;hello&lt;/span&gt;
          &lt;/div&gt;
      );
    }
});</code></pre>
<p>这里的map并不会被识别，应该把map变为Map,可以参考<a href="https://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components">这里</a>。</p>
<h2>Mixins：组件的继承</h2>
<p>虽然组件的原则就是模块化，彼此之间相互独立，但是有时候不同的组件之间可能会共用一些功能，共享一部分代码。所以 React 提供了 <code>mixins</code> 这种方式来处理这种问题。Mixin 就是用来定义一些方法，使用这个 mixin 的组件能够自由的使用这些方法（就像在组件中定义的一样），所以 mixin 相当于组件的一个扩展，在 mixin 中也能定义“生命周期”方法。</p>
<p>比如一个定时器的 mixin：</p>
<pre><code class="javascript">var SetIntervalMixin = {
    componentWillMount: function() {
        this.intervals = [];
    },
    setInterval: function() {
        this.intervals.push(setInterval.apply(null, arguments));
    },
    componentWillUnmount: function() {
        this.intervals.map(clearInterval);
    }
};

var TickTock = React.createClass({
    mixins: [SetIntervalMixin], // Use the mixin
    getInitialState: function() {
        return {seconds: 0};
    },
    componentDidMount: function() {
        this.setInterval(this.tick, 1000); // Call a method on the mixin
    },
    tick: function() {
        this.setState({seconds: this.state.seconds + 1});
    },
    render: function() {
        return (
            &lt;p&gt;
                React has been running for {this.state.seconds} seconds.
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;TickTock /&gt;,
    document.getElementById('example')
);</code></pre>
<p>React 的 <code>mixins</code> 的强大之处在于，如果一个组件使用了多个 mixins，其中几个 <code>mixins</code> 定义了相同的“生命周期方法”，这些方法会在组件相应的方法执行完之后按 mixins 指定的数组顺序执行。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003748289";}i:14;a:11:{s:5:"title";s:39:"前端之React实战-JSX介绍与使用";s:4:"link";s:42:"http://segmentfault.com/a/1190000003748270";s:2:"id";s:42:"http://segmentfault.com/a/1190000003748270";s:7:"updated";s:25:"2015-09-15T10:41:50+08:00";s:9:"published";s:25:"2015-09-15T10:41:50+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4833:"
<h1>JSX</h1>
<p>HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。</p>
<pre><code class="javascript">var names = ['Alice', 'Emily', 'Kate'];

React.render(
  &lt;div&gt;
  {
    names.map(function (name) {
      return &lt;div&gt;Hello, {name}!&lt;/div&gt;
    })
  }
  &lt;/div&gt;,
  document.getElementById('example')
);</code></pre>
<p>上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员:</p>
<pre><code class="javascript">var arr = [
  &lt;h1&gt;Hello world!&lt;/h1&gt;,
  &lt;h2&gt;React is awesome&lt;/h2&gt;,
];
React.render(
  &lt;div&gt;{arr}&lt;/div&gt;,
  document.getElementById('example')
);</code></pre>
<h2>Transfer</h2>
<p>JSX编译器的核心是将基于XML的语言编译成JS代码，主要是依赖于React.createElment函数。</p>
<pre><code class="javascript">var Nav;
// Input (JSX):
var app = &lt;Nav color="blue" /&gt;;
// Output (JS):
var app = React.createElement(Nav, {color:"blue"});</code></pre>
<pre><code class="javascript">var Nav, Profile;
// Input (JSX):
var app = &lt;Nav color="blue"&gt;&lt;Profile&gt;click&lt;/Profile&gt;&lt;/Nav&gt;;
// Output (JS):
var app = React.createElement(
  Nav,
  {color:"blue"},
  React.createElement(Profile, null, "click")
);</code></pre>
<h2>JavaScript Expressions</h2>
<h3>属性表达式</h3>
<p>如果需要在HTML中混入JavaScript变量值，需要利用{}来代替""。</p>
<pre><code>// Input (JSX):
var person = &lt;Person name={window.isLoggedIn ? window.name : ''} /&gt;;
// Output (JS):
var person = React.createElement(
  Person,
  {name: window.isLoggedIn ? window.name : ''}
);</code></pre>
<h3>Boolean Attributes</h3>
<pre><code class="javascript">// These two are equivalent in JSX for disabling a button
&lt;input type="button" disabled /&gt;;
&lt;input type="button" disabled={true} /&gt;;

// And these two are equivalent in JSX for not disabling a button
&lt;input type="button" /&gt;;
&lt;input type="button" disabled={false} /&gt;;</code></pre>
<h3>Child Expressions</h3>
<pre><code>// Input (JSX):
var content = &lt;Container&gt;{window.isLoggedIn ? &lt;Nav /&gt; : &lt;Login /&gt;}&lt;/Container&gt;;
// Output (JS):
var content = React.createElement(
  Container,
  null,
  window.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)
);</code></pre>
<h3>Comments：注释</h3>
<p>JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 <code>{}</code> 包围要注释的部分。</p>
<pre><code>var content = (
  &lt;Nav&gt;
    {/* child comment, put {} around */}
    &lt;Person
      /* multi
         line
         comment */
      name={window.isLoggedIn ? window.name : ''} // end of line comment
    /&gt;
  &lt;/Nav&gt;
);
</code></pre>
<h2>Multiple Case</h2>
<h3>If-Else</h3>
<p>在JSX中是不可以直接在{}中加入if-else的，可以使用下面这种三元表达式：</p>
<pre><code class="javascript">React.render(&lt;div id={condition ? 'msg' : ''}&gt;Hello World!&lt;/div&gt;, mountNode);</code></pre>
<p>不过三元表达式往往并不能满足需求，React建议的方式是在JS代码中使用if表达式：</p>
<pre><code class="javascript">var loginButton;
if (loggedIn) {
  loginButton = &lt;LogoutButton /&gt;;
} else {
  loginButton = &lt;LoginButton /&gt;;
}

return (
  &lt;nav&gt;
    &lt;Home /&gt;
    {loginButton}
  &lt;/nav&gt;
);</code></pre>
<h4>Show-Hide</h4>
<pre><code class="javascript">&lt;style type="text/css"&gt;
    .hidden { display:none; }
&lt;/style&gt;

render: function() {
    return (
      &lt;div className={this.props.shouldHide ? 'hidden' : ''}&gt;
        This will be hidden if you set &lt;tt&gt;props.shouldHide&lt;/tt&gt; 
        to something truthy.
      &lt;/div&gt;
    );
}</code></pre>
<h3>Switch-Case</h3>
<pre><code class="javascript">return (
  &lt;section&gt;
    &lt;h1&gt;Color&lt;/h1&gt;
    &lt;h3&gt;Name&lt;/h3&gt;
    &lt;p&gt;{this.state.color || "white"}&lt;/p&gt;
    &lt;h3&gt;Hex&lt;/h3&gt;
    &lt;p&gt;
      {(() =&gt; {
        switch (this.state.color) {
          case "red":   return "#FF0000";
          case "green": return "#00FF00";
          case "blue":  return "#0000FF";
          default:      return "#FFFFFF";
        }
      })()}
    &lt;/p&gt;
  &lt;/section&gt;
);</code></pre>
<h3>Loop：循环</h3>
<pre><code class="javascript">var rows = [];
for (var i=0; i &lt; numrows; i++) {
    rows.push(&lt;ObjectRow /&gt;);
}
return &lt;tbody&gt;{rows}&lt;/tbody&gt;;</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003748270";}i:15;a:11:{s:5:"title";s:79:"VLIS实验室云计算组张磊：关于Docker、开源，以及教育的尝试";s:4:"link";s:42:"http://segmentfault.com/a/1190000003747648";s:2:"id";s:42:"http://segmentfault.com/a/1190000003747648";s:7:"updated";s:25:"2015-09-15T08:34:22+08:00";s:9:"published";s:25:"2015-09-15T08:34:22+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:12:"图灵访谈";s:10:"author_uri";s:42:"http://segmentfault.com/u/turing_interview";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:16730:"
<blockquote><p>非商业转载请注明作译者、出处，并保留本文的原始链接：<a href="http://www.ituring.com.cn/article/203520">http://www.ituring.com.cn/article/203520</a></p></blockquote>
<p><strong>张磊</strong>，浙江大学计算机学院博士生，科研人员，VLIS实验室云计算组技术负责人、策划人。Kubernetes项目贡献者和维护者，Docker项目贡献者。前Cloud Foundry中国团队和百度私有云项目组成员。InfoQ、CSDN、《程序员》杂志等多篇浙大系技术文章的贡献者和策划人，他还是<a href="http://www.ituring.com.cn/book/1713">《Docker——容器与容器云》</a>一书的主要作者之一。</p>
<p><img src="/img/bVpS54" alt="图片描述" title="图片描述"></p>
<p><strong>问：你现在的目标是成为一位计算机科学家吗？</strong></p>
<p>是。</p>
<p><strong>问：你是从什么时候开始想成为一位计算机科学家的？</strong></p>
<p>大概是由于中学时候就开始玩电脑，然后自然而然就进入了计算机专业。由于我的兴趣主要在云计算以及Linux操作系统上，所以我的导师跟课题都是跟这些相关的。</p>
<p>2011年我们开始专注于开源云计算技术，当时开源的力量正在逐渐浮现。后来事实证明我们对趋势的判断是对的，因为从那个时候开始，软件的开发和发布以及整个生命周期就发生了改变。从此以后，可以说开源技术掌握了云计算行业，甚至是整个计算机行业的主流发展态势。于是，我们开始更深入地钻研Cloud Foundry, Docker, Kubernetes这样的技术，并且作为这些项目的贡献者成为了社区中的重要成员。</p>
<p><strong>问：你认为在云计算领域，学术跟产业之间有没有明确的界限？</strong></p>
<p>首先，云计算这个领域本身就比较特殊，它其实没有很多基础性研究，所以这个领域的学术跟工业是分不开的，中间没有一个明显的界限。比如，伯克利的AMP实验室做的一套高性能数据分析系统，最终开源出去就变成现在的明星项目Spark，成为工业界大数据的事实标准。在这些领域中，没有任何一个界限能够划定哪些技术是学术的，而工业界不能用。因为云计算本来就是“站在巨人肩膀上”的一种技术，它基于已有的分布式系统来做进一步的创新和整合。</p>
<p><strong>问：你现在在SEL实验室的工作是什么？</strong></p>
<p>我主要负责实验室云计算团队的技术工作 ，以及与技术相关的其他事宜，包括开源以及一些商业上的技术合作。</p>
<p><strong>问：SEL实验室的前身是VLIS实验室，当初建立VLIS实验室的目的是什么？现在SEL实验室的关注点有没有变化？</strong></p>
<p>我们实验室最开始的研究方向就是软件工程以及计算机软件。实验室一开始就注重从学校的角度跟知名企业建立强强联合的关系，致力于为工业界提供最好的大规模信息系统的开发技术和能力。在那个时候，我们的主要关注点是金融信息系统的开发，并且同全球最大的资金托管机构美国道富银行建立了紧密的合作研发关系。从这个时候开始，我们向工业界输出了大量的技术能力，整个北美市场的股票交易系统的后台都是我们实验室师生参与重新开发的。而软件技术发展到现在，新一代的大规模分布式系统开始更多地以知名开源项目作为表现形式，这些技术也就自然成为我们新的关注点。其中最重要的还是云计算技术，但是我们略有侧重，更关注轻量化的云计算技术，我们认为这将是一个新的变革。</p>
<p><strong>问：你们实验室跟Cloud Foundry还有百度、思科等知名企业都是以什么形式合作的？</strong></p>
<p>首先肯定有人才上的合作，因为学校本来是人才，我们会选择一些从事这个方向的优秀的学生，联合工业界的公司，比如去道富，VMware，思科总部或者百度等等，完成一个以技术研究为核心，以实际开发为途径的长期合作学习的过程。学生不是实习几个月然后回来，而是从开始到毕业，从研究的方向到最后的毕业论文都跟这些公司的真实技术场景紧密相关，并且专注于这些IT巨头的核心技术以及云计算平台的开发和研究工作。</p>
<p><strong>问：你们实验室为什么在Docker还不太完善的时候就敢去尝试这种技术？</strong></p>
<p>容器技术不是一种新技术，它其实很早就存在了。在此之前，我们搞Linux内核的时候已经用过类似的技术，而且做PaaS用到的技术也是基于Linux容器的，所以我们团队很久以前就对这种技术有过很多接触和研究。2013年的时候，我们同学主要在从事的是VMware的Warden容器的研发，紧接着Docker就出现了，并且比前一代容器技术要完善很多，所以我们就自然而然地转到了Docker上。这就是为什么Docker一出现就会引起我们的关注。轻量化的云计算技术一定会以这样的方式实现，只不过实现不同，而我们肯定会选择更好的实现。</p>
<p><strong>问：你本人是怎么成为Kubernetes和Docker项目的贡献者的？</strong></p>
<p>我是从Cloud Foundry团队出来的，而Cloud Foundry是一个纯粹的开源项目，它没有市场人员和项目经理这样的角色来干扰工程师的工作，所有贡献者都是通过远程协作和结对编程来贡献代码的。我，以及我们实验室的大多数同学从一开始就是这样一种工作模式，所以对于我们来说，参与开源项目是很自然的，而且我们也不像其他公司那样寻求互等的商业利益。</p>
<p>我们认为开源项目是一定要参与的，不仅要参与，还要学会主导项目的方向，成为维护者和更重要的核心代码贡献者。我刚才讲过，我们的愿景就是要基于开源软件做事情，做研究也好，做进一步的商业活动也好，一定要进入到社区里面，而不仅仅是一个使用者。</p>
<p><strong>问：Docker一直存在安全方面的问题，在这方面你有哪些经验可以和大家分享？</strong></p>
<p>我也在<a href="http://www.ituring.com.cn/book/1713">《Docker——容器和容器云》</a>里提到过，Docker本身确实有安全问题，但是一定要分场景讨论。比如，什么样的场景下我会在一台裸机上部署Docker；什么样的场景下我会让Docker容器跑在虚拟机里面。在目前这种情况下，如果你是一个公有云提供商，我认为你还是要把容器拷在你的虚拟机里面，防止出现逃逸状况。</p>
<p>我们在书里讲过，你的Docker容器和整个Docker Daemon环境最好做安全加固，在操作系统层面做很多加固，设置权限，并且在整个系统的设计上把权限设计和授权设计摆在第一位，逐层来把不正确的行为过滤掉。另外，一定要区分场景。对于私有云的话，安全要求满足第一点就可以了。但是对于公有云来说，一定要做最高等级的安全预案。</p>
<p>以上是从业务方面讲，但是从技术方面讲，容器本身的安全问题是很难解决的，但是有一些努力的方向非常值得我们关注。比如最新的Rocket集成了英特尔在CPU上的一些虚拟化技术来做到硬件加固，这就是等级很高的安全技术。另外还有像国内赵鹏他们做的Hyper，是一个基于虚拟化技术的容器，它跟虚拟机的安全系数几乎是一样的。所以我觉得从另一方面说，这些技术应该得到大家的重视，并且集成到我们现有的解决方案里面。</p>
<p><strong>问：现在在生产环境中使用Docker的人还是不太多，其背后的原因多种多样，你认为现在Docker面临的最大的阻碍是什么？</strong></p>
<p>第一个问题在于Docker所属公司本身的强势，以及他们自己想做一揽子事情的态度。这个问题使得Docker现在变得非常臃肿，而且导致本来应该专注解决的问题没有解决掉。如果他们投入主要力量来解决容器的安全问题，我觉得反而要比现在的态势好。</p>
<p>第二，我们使用Docker也好，对它做二次开发也好，其实我们不要把自己的眼光局限在Docker上面。让Docker只做容器的事情其实是最好的选择，其余的事情交给更专业的人。我们不要过分相信来自某些商业化的宣传，比如一个人或者一个团队就能完成从开发到部署到运维的所有流程。哪怕你一开始可以，但是随着业务的正常增长，技术发展到一定程度之后你一定是做不到的。所以一定是专业的人做专业的事。</p>
<p><strong>问：Docker和CoreOS一起创立了一个开放容器计划（OCP）。你认为OCP的成立对于软件开发行业会造成什么影响？</strong></p>
<p>容器镜像不单指Docker镜像，它很久之前就已经存在了。容器镜像作为一种软件的发布方式，现在已经得到了大家的认可，成为了行业的事实标准。并且由于容器镜像本身已经存在了很久，所以它本身标准的普及是比较容易的。所以OCP的成立其实是为这种镜像发布的方式提供了一个技术上的标准。</p>
<p>以前，这一套东西虽然可以做标准，但是没有技术来支撑它，现在有了。我们通过标准容器来支撑标准镜像。所以，这两个标准如果能够在OCP里面得到统一，我相信它对整个软件工程将来的发展都是有很大影响的。我们现在学校的课程里就已经引入了完全基于容器的软件工程设计模式，谷歌也提出了基于容器的编程模型，将来的软件工程一定会向这方向发展。</p>
<p><strong>问：你有一篇文章叫做《从Borg到Kubernetes》。你觉得Kubernetes今后的发展会怎么样？它和Mesos分别会向什么方向发展？</strong></p>
<p>我们最近也跟谷歌的人一起交流了很久，首先，Kubernetes确实背负了很多Borg之前的优秀的设计理念，其中包括Borg在谷歌内部大规模集群业务的应用。虽然现在还有一些应用我们看不到，但是Kubernetes将来的发展目标一定是用来解决这些问题。</p>
<p>Mesos和Kubernetes在一开始发展时其实是非常直接的竞争对手，因为这两者关注的事情有很多是一致的。但是随着这两个项目的继续发展，它们已经形成了合作关系。比如，Mesos本来就是一个优秀的调度器，那么接下来Mesos会更关注这个业务。并且Mesos可以被更方便地集成到Kubernetes里，作为Kubernetes的一个核心调度器来工作。</p>
<p>这两个项目现在的关注点其实是不一样的，使用的场景也不一样。在今后的发展中，它们会逐渐融合对方的优点。互相之间的集成会越来越多，互相之间的重合会越来越少。</p>
<p><strong>问：学术跟产业之间的脱轨问题一直以来经常被人们所诟病，浙大在这方面做得很不错，有没有什么经验可以分享？</strong></p>
<p>首先，作为一所学校，要学会如何在我们国家的体制下，在不影响正常的教学、科研的前提下，获得企业的支持。学校需要鼓励学生在看似枯燥的学业中找到真正的个人兴趣点。比如我们实验室就涌现出了非常多的代码贡献者、作者、领域内的小专家。因为我们实验室从一开始就鼓励个人发展自己的兴趣，并且鼓励同学向大家分享你的工作成果。这样，工业界会自然而然地关注过来，合作也接踵而至。</p>
<p>另一方面，如果学校自身的硬件条件很强，技术水平很高的话，学校就可以为工业界做出很多贡献，无论是开源贡献，还是参与到工业的开发。并且还有一点很重要，就是学校要想办法把实验室的技术和研究经验转化成工程上可以应用到增值需求里的东西，而不只是埋头写论文。所以，我们实验室在硕士生阶段，不会提出苛刻的论文要求。我们更希望你的论文是对一个开源项目的贡献，或者是我们和产业界合作的课题的相关实际工程经验。</p>
<p>同时，我们也在浙大试点了一个学院，整个软件学院在以更加工程的方式推动科研的走向。我们课题组从十年前开始做这样的事情，所以学术跟产业之间的脱轨问题我们这边几乎是没有的。</p>
<p><strong>问：浙大有这么好的环境，但是很多其他大学没有能力提供这样的环境。你建议在一般大学学习的学生怎样来丰富自己的专业知识？</strong></p>
<p>首先对于一个学生，尤其是CS专业的学生，我认为实习是最重要的。你一定要想办法在跟导师融洽相处的前提下，寻求到与自己专业相关的实习机会，并且珍惜这些机会，因为实习能够使你的专业技能得到锻炼。并且你应该想办法把实习转化成毕业论文，或者是学校要求的课程设计。这样的经历会对你在工业界的影响力也好，工作也好，起到很大的积极作用。</p>
<p><strong>问：你认为学习Docker需要几个阶段？</strong></p>
<p>我们在书的后记里面讲过，不止是Docker，对于任何一个开源项目来说，都有这样的三个或四个阶段。<br>首先，你要去用，而且不只要用，还要变成一个优秀的玩家。对于开源项目的所有指令、所有设计，你应该有一个感性认识。</p>
<p>在这个基础之上就是源码，要读源码。读源码是一件非常有意思的事，但是在这个过程中，你要学会提问，带着问题去读源码，才会有收获。</p>
<p>然后就是转化，转化包括几种情况。比如，你可以将容器技术转化成你们实验室的某个项目的基础或者工作中的整个项目。另外，你要学会对项目做贡献。从最开始的找bug、解决bug、修改文档，到最后提出自己的特性、融入到社区里，只有这样你才能够获得最多的知识，以最快的速度提高自己在这个领域中的能力。</p>
<p>这三步之后，如果你在这个方面做得更多，可以考虑一些商业化的事情。比如你可以做一些相关的买卖，或者在你的公司里推广这些开源技术。</p>
<p><strong>问：你觉得读者应该怎样使用<a href="http://www.ituring.com.cn/book/1713">《Docker——容器和容器云》</a>这本书，读者在哪个阶段需要用到这本书？</strong></p>
<p>这本书应该更适合在第二或第三阶段阅读。</p>
<p>这本书的一个特点就是它倾向于把原理帮你从源码中抽象出来，而不仅仅带你走读代码。因为代码很快会过时，所以我们特别注重抽象原理。在第三阶段的时候，你要去做开发，所以你对技术的熟悉程度和原理必然要有一个深刻的认识。而这本书的很多实践章节，包括我们对代码的整个框架结构的分析，会对你有很大的帮助。</p>
<p><strong>问：<a href="http://www.ituring.com.cn/book/1713">《Docker——容器和容器云》</a>的关注点和其他类似的书有什么不同？</strong></p>
<p>首先，我们不认为容器就是Docker，我们认为它只是容器技术一种优秀的实现。所以我们的书叫<a href="http://www.ituring.com.cn/book/1713">《Docker——容器与容器云》</a>，我们更关注所有基于容器的云平台的实现方式。你可以把容器理解为我们现在的虚拟机，把容器云理解为OpenStack，所以我们这本书肯定要先讲虚拟机原理，以此为基础我们才能讲清楚容器云，也就是容器的大规模管理方式。</p>
<p>很多目前市面上的书只关注于Docker本身，而我们更关注Docker背后的<code>libcontainer</code>也就是<code>runc</code>的工作原理，于此同时，我们还非常关注所谓的容器技术与大规模容器集群管理的结合方式。我们非常想为大家解决的一个问题就是，真正的大规模容器集群管理应该是什么样的。我们认为Kubernetes现在的方向是非常好的，所以在书中我们对它做了一个非常详细深入的解读，这在国内外应该是首次，而且从谷歌和CoreOS工程师的反馈来看，甚至在国外可能也是第一次。</p>
<hr>
<h4>更多精彩，加入图灵访谈微信！</h4>
<p><img src="/img/bVkfQ4" alt="图片描述" title="图片描述"></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003747648";}i:16;a:11:{s:5:"title";s:42:"css reset重置样式有那么重要吗？";s:4:"link";s:42:"http://segmentfault.com/a/1190000003746701";s:2:"id";s:42:"http://segmentfault.com/a/1190000003746701";s:7:"updated";s:25:"2015-09-14T21:02:19+08:00";s:9:"published";s:25:"2015-09-14T21:02:19+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:21:"风雨过后见彩虹";s:10:"author_uri";s:35:"http://segmentfault.com/u/taotao123";s:2:"re";a:1:{s:4:"rank";s:1:"2";}s:7:"summary";s:3522:"
<p>在以前写html代码的时候，一般都会在head里添加重置样式reset.css，其内容如下：</p>
<pre><code>@charset "utf-8";
html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, font, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td {
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    font-size: 100%;

}
table {
    border-collapse:collapse;
    border-spacing:0;
}
fieldset, img {    border:0;}
address, caption, cite, code, dfn, em, strong, th, var {
    font-style:normal;
    font-weight:normal;
}
ol, ul { list-style:none; }
caption, th { text-align:left; }
h1, h2, h3, h4, h5, h6 {
    font-size:200%;
    font-weight:normal;
}
:focus { outline: 0;}
a{ text-decoration:none;}
a:hover img{ border:none;}

a:active{noOutline:expression(this.onFocus=this.blur());}

.clearfix:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}
.clearfix {display: inline-block;}
 html .clearfix { height: 1%;}
.clearfix {display: block;}

*html img.png{
_background-image: expression(this.runtimeStyle.backgroundImage = "none",this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.src + "', sizingMethod='image')",this.src = "http://i0.itc.cn/20101019/848_0a785a7b_1118_4825_85dc_e8696988c94b_0.gif");</code></pre>
<p>}</p>
<p>但是最近在网上看了看网络文章，也感觉有些重置是没有用的。为什么呢？</p>
<p><strong>重置的作用究竟是什么？</strong></p>
<p>CSS reset的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”！</p>
<p>有时候看到别人网站站的一些重置是这样的：</p>
<pre><code>*{ margin:0; padding:0; }
</code></pre>
<p>这样的写法是极不推荐的。<br>现在来看重置表发现：</p>
<ol>
<li><p><code>div</code>标签默认有<code>margin</code>值吗？有<code>padding</code>值吗？怎么会想到应用<code>div{margin:0; padding:0;}</code>属性呢？答案肯定没有。</p></li>
<li><p><code>dt</code>标签有默认的<code>margin</code>与<code>padding</code>值就是<code>0</code>，什么还要使用呢？</p></li>
<li><p><code>li</code>标签默认有<code>margin</code>值吗？有<code>padding</code>值吗？没有！</p></li>
<li><p><code>code</code>标签是个属于<code>inline</code>水平的元素，居然也扯到<code>margin</code>与<code>padding</code>的重置，没有必要。</p></li>
<li><p><code>fieldset</code>, l<code>egend</code>这两个90年代的标签你的网站上使用了吗？使用概率不足1%的标签也拿来重置，也没必要。</p></li>
</ol>
<p>css真的重置也就那么几个常用的标签而已，你的页面一般都用到什么标签？</p>
<pre><code>body, dl, dd, h1, h2, h3, h4, h5, h6, p, form{margin:0;} 

 ol,ul{margin:0; padding:0;}
 </code></pre>
<p>这样的CSS reset才是高效的，简洁的，其他一些标签都可以去掉的，没有必要。</p>
<p>当然css重置的优点，缺点都不说了，估计心里都非常有数的，还是要根据实际项目来。</p>
<p>后来主管给我推荐了一款替代<code>reset.css</code>重置的替代方案，那就是用<code>Normalize.css</code>。在后面文章里把它的用法等再列出来。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003746701";}i:17;a:11:{s:5:"title";s:82:"js立即执行函数: (function ( ){...})( ) 与 (function ( ){...}( )) 有区别?";s:4:"link";s:42:"http://segmentfault.com/a/1190000003746637";s:2:"id";s:42:"http://segmentfault.com/a/1190000003746637";s:7:"updated";s:25:"2015-09-14T20:52:41+08:00";s:9:"published";s:25:"2015-09-14T20:52:41+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:21:"风雨过后见彩虹";s:10:"author_uri";s:35:"http://segmentfault.com/u/taotao123";s:2:"re";a:1:{s:4:"rank";s:1:"4";}s:7:"summary";s:2966:"
<p>在SF上看到这样一个问题，我觉得问得很好，所以弄成文章收集了。</p>
<p>没有区别。</p>
<p>你需要明白 IIFE 的原理，我简单说一下：</p>
<pre><code>function foo() {...}     // 这是定义，Declaration；定义只是让解释器知道其存在，但是不会运行。

foo();                   // 这是语句，Statement；解释器遇到语句是会运行它的。
</code></pre>
<p>IIFE 并非必须，传统一点可以这么写：</p>
<pre><code>function foo() {...}
foo();
</code></pre>
<p>那么为什么要 IIFE？</p>
<ol>
<li><p>传统的方法啰嗦，定义和执行分开写；</p></li>
<li><p>传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window）</p></li>
</ol>
<p>于是，开发者们想找一个可以解决以上问题的写法。那么像下面这么写行不行呢？</p>
<pre><code>function foo(...){}();
</code></pre>
<p>当然是不能，但是为什么呢？因为 <code>function foo(...){}</code> 这个部分只是一个声明，对于解释器来说，就好像你写了一个字符串<code> "function foo(...){}"</code>，它需要使用解析函数，比如<code>eval() </code>来执行它才可以。所以把 <code>() </code>直接放在声明后面是不会执行，这是错误的语法。</p>
<p>如何把它变得正确？说起来也简单，只要把 声明 变成 表达式（Expression） 就可以了。</p>
<p>实际上转变表达式的办法还是很多的，最常见的办法是把函数声明用一对 () 包裹起来，于是就变成了：</p>
<pre><code>(function foo() {...})    // 这里是故意换行，实际上可以和下面的括号连起来
();
</code></pre>
<p>这就等价于：</p>
<pre><code>var foo = function () {...};    // 这就不是定义，而是表达式了。
foo();
</code></pre>
<p>但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式：</p>
<pre><code>(function foo(){...}());
</code></pre>
<p>所以答案是：木有区别～</p>
<p>另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如：</p>
<pre><code>!function foo() {...}();
</code></pre>
<p>或者</p>
<pre><code>+function foo() {...}();
</code></pre>
<p>这些都可以。</p>
<p>我个人挺偏爱用 void 来转变表达式，因为此关键字不会有返回值。不过这一点真的没有什么要紧的，就当我“龟毛”好了……</p>
<pre><code>void function () {
    // 这里是真正需要的代码
}();
</code></pre>
<p>OK，所谓不去污染全局命名空间，是因为 IIFE 创建了一个新的函数作用域，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了。如果你需要全局对象，那就 pass 给 IIFE：</p>
<pre><code>void function (global) {
    // 在这里，global 就是全局对象了
}(this)    // 在浏览器里，this 就是 window 对象</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003746637";}i:18;a:11:{s:5:"title";s:32:"Javascript 中的闭包和引用";s:4:"link";s:42:"http://segmentfault.com/a/1190000003746599";s:2:"id";s:42:"http://segmentfault.com/a/1190000003746599";s:7:"updated";s:25:"2015-09-14T20:48:19+08:00";s:9:"published";s:25:"2015-09-14T20:48:19+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:21:"风雨过后见彩虹";s:10:"author_uri";s:35:"http://segmentfault.com/u/taotao123";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:3126:"
<p><strong>Javascript 中一个最重要的特性就是闭包的使用。因为闭包的使用，当前作用域总可以访问外部的作用域。因为Javascript 没有块级作用域，只有函数作用域，所以闭包的使用与函数是紧密相关的。</strong></p>
<h2>模拟私有变量</h2>
<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>
<p>这里 Counter 返回两个闭包：函数 increment 和 get。这两个函数一直保持着对 Counter 作用域的访问，因此它们能一直访问到定义在 Counter 作用域的变量 count。</p>
<h2>私有变量的工作机制</h2>
<p>由于 Javascript 不可以对作用域赋值和引用，所以在上例中，是没有办法在外部直接访问内部私有变量 count。唯一的方法就是通过定义闭包来访问。</p>
<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>
<p>上面的代码不会改变 Counter 作用域内的 count 变量值，因为 hack 没有在 Counter 内定义。上面这段代码只会创建或者覆盖全局变量 count。</p>
<p>循环内的闭包</p>
<p>一个最容易犯的错误就是在循环内使用闭包。</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>
<p>上面这段代码不会输出0到9，而是连续输出10次10。<br>上面的匿名会一直保持一个对变量 i 的引用。当调用 console.log 函数开始输出时，这是循环已经结束，而变量 i 已经为10了。<br>为了避免上面的错误发生，我们需要在每次循环时为变量 i 值创建一个拷贝。</p>
<h2>避免引用错误</h2>
<p>为了复制循环中变量的值，最好的方式是在外层加一个匿名的立刻执行函数。</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>
<p>这个外部的匿名函数接收循环变量 i 作为第一个参数，并将其值拷贝至它自身的参数 e。<br>外部的匿名函数将参数 e 再传递给 setTimeout，因此 setTimeout 有了指向参数 e 的引用。而且这个参数 e 的值不会因为外部的循环改变而改变。</p>
<p>还有另外一个方法可以实现同样的效果，就是在 setTimeout 内的匿名函数中再返回一个匿名函数：</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
</code></pre>
<p>此外，通过 bind 方法也可以实现。</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(console.log.bind(console, i), 1000);
}
</code></pre>
<p>地址：<a href="http://bonsaiden.github.io/JavaScript-Garden/#function.closures">http://bonsaiden.github.io/JavaScript-Garden/#function.closures</a></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003746599";}i:19;a:11:{s:5:"title";s:11:"浅谈JSONP";s:4:"link";s:42:"http://segmentfault.com/a/1190000003746509";s:2:"id";s:42:"http://segmentfault.com/a/1190000003746509";s:7:"updated";s:25:"2015-09-14T20:18:40+08:00";s:9:"published";s:25:"2015-09-14T20:18:40+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"risker";s:10:"author_uri";s:32:"http://segmentfault.com/u/risker";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:8592:"
<blockquote>
<p>这是我在13年初写的文章，当时懵懵懂懂写下了自己对<code>JSONP</code>的理解。</p>
<p><a href="https://github.com/riskers/blog/issues/6">文章原文</a></p>
<p><a href="https://github.com/riskers/blog/issues">博客</a> 欢迎订阅</p>
</blockquote>
<hr>
<p>这是我在13年初写的文章，当时懵懵懂懂写下了自己对<code>JSONP</code>的理解。</p>
<hr>
<p>提到JSONP，我当时在网上找了无数帖子也没有看懂它。那些文章大同小异，都是讲到JSONP原理以后就戛然而止，把我们这些初学者搞得云里雾里。所以，写下这篇文章，希望对大家有帮助！</p>
<h2>为什么要有JSONP</h2>
<p>回答这个问题之前，大家先想想什么是AJAX，JSONP就是一种能够解决AJAX办不到的事情而存在的一种取数据的技术。什么事情是AJAX办不到的呢？就是跨域！</p>
<p><strong>跨域</strong>：顾名思义，就是当前网页的地址和我们要取的数据地址不在一个域下。这是因为浏览器都有一个“同源策略”— 两个页面的域名必须在同域的情况下，才能允许通信。</p>
<blockquote>
<p>怎么才算一个域呢？</p>
<p>相同域名，相同端口，相同协议（因为不是这里的重点，大家可以请教Google）</p>
</blockquote>
<p><strong>“同源策略”的意义</strong>:“同源策略”有效地阻止了一些危险行为，比如你进入<code>www.aaa.com</code>，同时浏览器又开了一个<code>www.bbb.com</code>，如果这个<code>www.bbb.com</code>是一个木马网站，在没有“同源策略”的情况下，它就可能嵌入一些代码，来取得你在<code>www.aaa.com</code>的信息（因为这时两个页面是可以通信的） 。而正是因为有了“同源策略”，刚才可以通信的情况才不会发生。</p>
<p><strong>“同源策略”带来的麻烦</strong>:上面的例子是我们在不知情的情况下，保护我们的网络安全的，但如果我们就是要让<code>www.aaa.com</code>取得<code>www.bbb.com</code>上的数据，行不行呢？答：不行！还是因为”同源策略”！我们想从自己信任的网页上取得数据都不行，这可怎么办呢？</p>
<h2>JSONP出现</h2>
<p>在需要跨域通信的岁月里，一些卓越的前端工程师们想到了这个”作弊”的办法来逃避”同源策略”。”同源策略”虽然很厉害，阻止了一个页面到另一个页面的通信，可是<code>src</code>指向的路径它放过了，提到<code>src</code>，大家是不是想起了<code>&lt;script&gt;</code>？对，JSONP就是利用”同源策略”的这一”漏洞”来进行”作弊”的。（其实有<code>src</code>属性的不止有<code>&lt;script&gt;</code>,还有<code>&lt;img&gt;</code>和<code>&lt;iframe&gt;</code>，而<code>&lt;iframe&gt;</code>也是能够运用<code>JSONP</code>的）。</p>
<p>下面看看<code>JSONP</code>的原理:</p>
<p><code>JSONP</code>:<code>JSON with Padding</code>，<code>JSON</code>大家这都知道，是一种数据通信格式，而”Padding”是什么意思，别急，往下看就知道了。</p>
<p>我们先举一个简单的例子：</p>
<p><code>www.aaa.com</code>中：</p>
<pre><code>&lt;script type="text/javascript" src="http://www.bbb.com/abc.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    function abc(json){
        alert(json['name']); 
    }
&lt;/script&gt;</code></pre>
<p><code>www.bbb.com/abc.js</code>中：</p>
<pre><code>abc({'name':'risker','age':24});</code></pre>
<p>页面会弹出<code>risker</code>，有感觉了么？</p>
<p><strong>JSONP是这样工作的</strong>：像前面所说的那样，我们可以取到<code>www.bbb.com/abc.js</code>，里面是一个<code>abc</code>函数，这个函数也会被加载到<code>www.aaa.com</code>。加载完成后，就应该执行<code>abc</code>了，然后我们在<code>www.aaa.com</code>定义<code>abc</code>函数，这个函数里写一些处理数据的语句。这样其实就简单地实现了跨域访问数据了，这也就是<code>JSONP</code>的原理了。而<code>JSON with Padding</code>的意思，就是<code>abc(json)</code>中的<code>json</code>：<br><code>abc({'name':'risker','age':24})</code>。</p>
<p>这个JSON对象被包在abc这个函数中当作参数来被处理，而<code>JSON with Padding</code>这个词很形象地形容了这个过程。</p>
<h2>JSONP的简单实例</h2>
<p>在网上能找到的JSON基本只是介绍到这里就完了，但是这让初学者看不到一个实实在在的例子。所以下面才是这篇文章和其他网上介绍JSON文章不一样的地方，我带给大家一个例子！<br>大家一定对百度的自动搜索框有印象，它就是一个JSONP的实例：</p>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-14/62504685.jpg" alt="f1" title="f1"></p>
<p>先查看<a href="http://codepen.io/riskers/full/JYGKme/">demo</a></p>
<p>分析一下：</p>
<p>1.分析数据地址回顾上面的例子，我们首先要知道数据的来源地址，就是上面的<code>www.bbb.com/abc.js</code>里的数据。在Chrome中查看Network。然后随便在搜索框里输入点什么，比如<code>s</code>，观察Network里是不是多了东西，点开它，就是我们输入“s”后传回的数据了：</p>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-14/82372497.jpg" alt="f2" title="f2"></p>
<p>这个地址是<code>http://suggestion.baidu.com/su?wd=S&amp;p=3&amp;cb=window.bdsug.sug&amp;from=superpage&amp;t=1365392859833</code> ， 我们分析一下，<code>wd</code>后面是<code>s</code>，那就可以断定百度定义<code>wd</code>是搜索的关键字，<code>cb</code>是一个回调函数，其他的对我们就不重要了。回调函数是我们取到数据要后执行的函数，相当于我们上面的abc函数。它是可以自己取名的。像<code>http://suggestion.baidu.com/su?wd=S&amp;p=3&amp;cb=succ&amp;from=superpage</code>表示取到数据后执行succ函数：</p>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-14/28602969.jpg" alt="f3" title="f3"></p>
<p>这样，我们的数据就包在了succ函数里做一个参数，再次证明了JSON with Padding 的原理。</p>
<p>2.做<code>&lt;script&gt;</code>标签，其src指向数据地址：这是要动态生成的，不能把地址写死，要不然取到的都是一样的数据了。所以我们要动态生成<code>&lt;script&gt;</code>，动态指定<code>src</code>属性:</p>
<pre><code>var oScript = document.createElement('script');
oScript.src = 'http://suggestion.baidu.com/su?wd='+oTxt.value+'&amp;amp;p=3&amp;amp;cb=succ&amp;amp;from=superpage';
document.body.appendChild(oScript);</code></pre>
<p>3.不要以为这样问题就解决了，F12一下，就看到生成了好多<code>&lt;script&gt;</code>!这是因为我们每输入一个字符就动态生成一个<code>&lt;script&gt;</code>，造成了代码冗余！解决一下：</p>
<pre><code>if(oScript){
document.body.removeChild(oScript);
}</code></pre>
<p>好，这样，我们的搜索框效果就做好了，因为主要讲JSONP部分的工作原理，就不做成百度下拉框那样了，大家可以自己去布局。当然，真正的百度搜索框还要在此基础上涉及事件的冒泡取消等等，就不是这里的重点了，不做阐述。</p>
<h2>JSONP总结</h2>
<ol>
<li><p>JSONP是为了传数据而存在的技术。网页之间的通信原本有AJAX就够了，而AJAX因为浏览器“同源策略”面对跨域情况就束手无策了。JSONP就这样被发明了，利用<code>&lt;script&gt;</code>的<code>src</code>属性不受“同源策略”的控制，“作弊”般地巧妙地逃过了浏览器的这一限制。</p></li>
<li><p>JSONP方法本质是创建<code>&lt;script&gt;</code>标签，其<code>src</code>指向我们的数据地址。地址后面附带一个回调函数（名字一般是callback或者是别的什么，就看后台给我们的是什么了，函数名是我们起的）。然后，声明这个回调函数。这样，只要一引入上面的<code>&lt;script&gt;</code>标签，就相当于执行了那个回调函数。</p></li>
<li><p>虽然jQuery把JSONP内置在了AJAX里，但是我们一定要清楚，AJAX和JSONP是完全不一样的，一定不要混淆！以后我会更新一篇介绍AJAX的文章的。</p></li>
<li><p>这里是前端和后台的交汇之处，想要真正融会贯通，还要学学后台的知识。我也是在学了PHP之后才把JSONP搞懂的。</p></li>
</ol>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003746509";}i:20;a:11:{s:5:"title";s:39:"Redux学习之一：何为middleware？";s:4:"link";s:42:"http://segmentfault.com/a/1190000003746223";s:2:"id";s:42:"http://segmentfault.com/a/1190000003746223";s:7:"updated";s:25:"2015-09-14T18:39:37+08:00";s:9:"published";s:25:"2015-09-14T18:39:37+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:12:"三寸天堂";s:10:"author_uri";s:34:"http://segmentfault.com/u/szhclaye";s:2:"re";a:1:{s:4:"rank";s:1:"3";}s:7:"summary";s:6334:"
<p>接触到redux有半个月之久了，最初是被各种概念绕的云里雾里，但是最近自己实现了一个demo之后，才发现redux是如此简洁，简洁到源代码就五部分组成，最大的<strong>createStore.js</strong>也就151行代码而已。</p>
<pre><code>createStore.js
applyMiddleware.js
bindActionCreators.js
combineReducers.js
compose.js</code></pre>
<p>redux的魅力在于其简洁和FP编程思想。像reducers的设计、curry编程风格等都散发出淡淡的FP的味道。<br>下面言归正传，进入middleware部分。下面由几个问题领着大家看看middleware的真面目。</p>
<h2><strong>1.什么是middleware？</strong></h2>
<p>学过nodejs的人对middleware一定不会陌生。在nodejs里面，middleware是req和res之间的中间层，可以做很多事情。但在redux里面，middleware又是什么呢。<br><a href="https://github.com/rackt/redux/blob/master/docs/advanced/Middleware.md">https://github.com/rackt/redux/blob/master/docs/advanced/Middleware.md</a><br>middleware文档里面有这样一句话：</p>
<blockquote><p><strong>It provides a third-party extension point between dispatching an</strong><br><strong>action, and the moment it reaches the reducer.</strong></p></blockquote>
<p>不难理解，在redux里，middleware是发送action和action到达reducer之间的第三方扩展，也就是中间层。也可以这样说，middleware是架在action和store之间的一座桥梁。</p>
<h2><strong>2.为什么要引入middleware？</strong></h2>
<p>也许有人会问，到底middleware有什么用？<br>这就要从action说起。在redux里，action仅仅是携带了数据的普通js对象（ plain JavaScript objects）。action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发……</p>
<blockquote><p>action ---&gt; dispatcher ---&gt; reducers</p></blockquote>
<p>同步的情况下一切都很完美……<br>如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写ActionCreator：</p>
<pre><code>var asyncSayActionCreator = function (message) {
    setTimeout(function () {
        return {
            type: 'SAY',
            message
        }
    }, 2000)
}</code></pre>
<p>这会报错，因为这个asyncSayActionCreator返回的不是一个action，而是一个function。这个返回值无法被reducer识别。<br>大家可能会想到，这时候需要在action和reducer之间架起一座桥梁……</p>
<h2><strong>3.middleware如何工作？</strong></h2>
<p>我们看看redux-thunk的代码：</p>
<pre><code>export default function thunkMiddleware({ dispatch, getState }) {
  return next =&gt; action =&gt;
    typeof action === 'function' ?
      action(dispatch, getState) :
      next(action);
}</code></pre>
<p>仅仅是区区的6行代码，以至于我第一次看代码的时候怀疑是不是看错了，但其实它就这么简单。一个三目符，如果action是一个函数，执行这个action函数，如果不是函数，执行next函数。<br>可能大家换是不懂，结合middleware的应用便会一目了然：</p>
<pre><code>const finalCreateStore=applyMiddleware(thunkMiddleware)(createStore)
const store = finalCreateStore(reducer)</code></pre>
<p>这就是我们最常使用middleware的代码。把源码中的next换成createStore，如果action是一个函数（这里的action是改造后的ActionCreator），便会执行这个action(dispatch, getState)函数。</p>
<pre><code>var asyncSayActionCreator = function (message) {
    return function (dispatch) {
        setTimeout(function () {
            dispatch({
                type: 'SAY',
                message
            })
        }, 2000)
    }
}</code></pre>
<p>这里的action是return的函数：</p>
<pre><code>    function (dispatch) {
        setTimeout(function () {
            dispatch({
                type: 'SAY',
                message
            })
        }, 2000)
    }</code></pre>
<p>如果action返回的不是函数，即返回的是action对象的话，执行createStore函数的dispatch方法。<br>有了middleware之后，数据流动的方向变为：</p>
<blockquote><p>action ---&gt; dispatcher ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; reducers</p></blockquote>
<h2><strong>4.applyMiddleware都做了什么？</strong></h2>
<p>redux2.0对applyMiddleware做了柯里化处理。</p>
<pre><code>import compose from './compose';
export default function applyMiddleware(...middlewares) {
  return (next) =&gt; (reducer, initialState) =&gt; {
    var store = next(reducer, initialState);
    var dispatch = store.dispatch;
    var chain = [];

    var middlewareAPI = {
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action)
    };
    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);

    return {
      ...store,
      dispatch
    };
  };
}</code></pre>
<p>其实最核心的代码也就是下面两句：</p>
<pre><code>chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));
dispatch = compose(...chain)(store.dispatch);</code></pre>
<p>前一句是执行middlewares数组里的每一个中间件，下一句是将chain柯里化，合成一个函数。</p>
<h2><strong>5.自己的middleware怎么写？</strong></h2>
<p>学了这些，我们可以自己写一个middleware练练手。<br>首先在项目下建个middlewares的文件夹，新建一个callTraceMiddleware.js来追踪函数的调用过程。<br>在funCallTrace.js添加如下代码：</p>
<pre><code>export default function callTraceMiddleware ({dispatch,getState}){
    return next=&gt; action =&gt;{
        console.trace();
        return next(action);
    }
}</code></pre>
<p>然后在调用中间件部分添加中间件：</p>
<pre><code>const createStoreWithMiddleware = applyMiddleware(
  thunkMiddleware,
  loggerMiddleware,
  callTraceMiddleware
)(createStore);</code></pre>
<p>这样我们运行在浏览器窗口就可以看到打印的函数调用轨迹。是不是很简单……</p>
<h2><strong>总结</strong></h2>
<p>redux的middleware是对action进行扩展处理，这样丰富了应用需求。<br>以上是我对redux的个人理解，如发现错误恳请批评指正。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003746223";}i:21;a:11:{s:5:"title";s:24:"CrossPHP 1.4.1 发布了";s:4:"link";s:42:"http://segmentfault.com/a/1190000003745853";s:2:"id";s:42:"http://segmentfault.com/a/1190000003745853";s:7:"updated";s:25:"2015-09-14T17:27:46+08:00";s:9:"published";s:25:"2015-09-14T17:27:46+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"ideaa";s:10:"author_uri";s:31:"http://segmentfault.com/u/ideaa";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4727:"
<h2>1.4.1 更新说明</h2>
<h4>一. BUG修复</h4>
<ol>
<li>
<p>修复多条件下AND条件解析错误的bug</p>
<pre><code>
    'p' =&gt; array( 'AND',  array(array('&lt;=', 5), array('&gt;', 0)))
</code></pre>
</li>
<li><p>修复<code>Cross\MVC\Controller::to()</code>方法第三个参数无效的bug</p></li>
</ol>
<h4>二. 不兼容性更新</h4>
<ol>
<li><p>删除了不完善的PYInitials库</p></li>
<li><p><code>Cross\MVC\View::makeParams()</code>, 第一个参数强制指定为数组, 仅支持字符串</p></li>
<li><p><code>Cross\Core\CrossArray::get($config, $name = null)</code>, <code>$config</code>不再识别数组</p></li>
</ol>
<h4>二. 优化和功能更新</h4>
<ol>
<li><p>非HTML视图不再加载layer</p></li>
<li><p>增加 <code>PATH_INFO</code> 模式下的短URL风格支持(需要使用注释配置 <code>@cp_params</code>, 来为 <code>$this-&gt;params</code> 中的成员命名)</p></li>
<li><p>调用<code>display_type</code>中指定的方法时, 不再强制转换大小写(<code>display_type</code>在init.php配置文件中指定)</p></li>
<li><p><code>Cross\MVC\View::makeUri()</code>生成的uri不再包含app名称</p></li>
<li><p>分离SQLAssembler中的条件解析部分(更容易扩展)</p></li>
<li><p>新增对mysql函数INSRT的支持</p></li>
<li><p>支持自定义默认数据库名称(在app配置文件init.php中使用sys['default_db']指定)</p></li>
<li><p><code>Cross\Core\Loader::read()</code>读取.ini文件时, 返回多维数组</p></li>
<li><p>优化生成连接的速度<br>10. 框架内部,判断文件是否存在用is_file代替file_exists<br>11. 更新单元测试代码,增加了对生成基础SQL语句的条件覆盖</p></li>
</ol>
<h2>1.4.0 更新说明</h2>
<h4>一. 数据库操作的改进</h4>
<ol>
<li>
<p>新增一种写法</p>
<pre><code>    $this-&gt;link-&gt;get(table, fields, array('a = ? AND b = ?', array(1, 2))</code></pre>
<p>第一个参数为条件的预处理字符串, 第二个参数为参数列表. 以上写法等同1.3.0以下写法:</p>
<pre><code>    $this-&gt;link-&gt;get(table, fields, array('a' = 1,  'b' = 2))</code></pre>
<p>生成的SQL语句均为 <code>SELECT fields FROM table WHERE a = ? AND b = ?</code>, 省去条件解析, 所以比1.3.0更高效.</p>
</li>
<li>
<p>扩展数组语法,用于处理复杂查询条件下的优先级</p>
<pre><code>    $this-&gt;link-&gt;get(table, fields, array(
        '(a = ? OR b = ?)' =&gt; array(1, 2),
        'c'    =&gt; 1,
    )

 生成的sql语句为 `SELECT fields FROM table WHERE (a = ? OR b = ?) AND c = ?`, 以上语句可以转换为更高效的写法

    $this-&gt;link-&gt;get(table, fields, array(
        '(a = ? OR b = ?) AND c = ?', array(1, 2, 1)
    ))

复杂条件下,推荐使用新写法
</code></pre>
</li>
<li><p>find方法的 <code>$page</code> 参数支持在外部指定总记录条数 <code>result_count</code>, 此时内部获取总条数的语句不再执行, 直接使用外部指定的总条数来生成对应的分页查询语句.</p></li>
<li>
<p>where条件中增加对<code>find_in_set</code>和<code>regexp</code>方法的支持</p>
<pre><code>    $this-&gt;link-&gt;get(table, fields, array('name' =&gt; array(find_in_set, 'id1, id2...')))
</code></pre>
</li>
</ol>
<h3>二. 路由配置行为改变</h3>
<ol>
<li>
<p><code>init.php</code>文件中的<code>router</code>配置项中的数组不再表示控制器中action的别名.</p>
<pre><code>    router =&gt; array(
        'help'    =&gt;    array('aliasController', array('a'=&gt;1, 'b' =&gt; 2))
    )
以上配置表示为`aliasController`指定别名`help`, 默认参数为 `array('a'=&gt;1, 'b' =&gt; 2)`,
</code></pre>
</li>
<li>
<p>为控制器中的方法指定别名用冒号来表示</p>
<pre><code>    router =&gt; array(
        'help:list'    =&gt;    'help:getList'
    )
为`help`控制器中的`getList`指定别名为`list`
</code></pre>
</li>
</ol>
<h3>三. 其他优化</h3>
<ol>
<li><p>文件缓存内部增加读取配置的方法</p></li>
<li><p>修复多模板情况下,请求缓存被覆盖的问题</p></li>
<li><p>指定URL规则为1或3时, rewrite状态下带<code>?</code>访问默认控制器报错的bug</p></li>
<li><p><code>Request-&gt;getUrlRequest()</code>增加默认返回值</p></li>
<li><p>读取配置文件的值时, <code>$this-&gt;config-&gt;get('key', params)</code>, 如果第二个参数的值为数组则返回数组中指定的值</p></li>
<li><p>不再限制控制器中<code>__call</code>方法对注释配置的识别</p></li>
<li><p>Helper增加一个方法用于验证国内身份证号码</p></li>
<li><p>View中的 <code>$this-&gt;e(array, array_key, default_value)</code> 方法,需要加 <code>echo</code></p></li>
</ol>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003745853";}i:22;a:11:{s:5:"title";s:51:"前端之React实战-快速入门以及集成使用";s:4:"link";s:42:"http://segmentfault.com/a/1190000003745823";s:2:"id";s:42:"http://segmentfault.com/a/1190000003745823";s:7:"updated";s:25:"2015-09-14T17:23:48+08:00";s:9:"published";s:25:"2015-09-14T17:23:48+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:5929:"
<h1>Quick Start</h1>
<h2>HelloWorld</h2>
<p>基本的React的页面形式如下所示：</p>
<pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;script src="../build/react.js"&gt;&lt;/script&gt;
        &lt;script src="../build/JSXTransformer.js"&gt;&lt;/script&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id="example"&gt;&lt;/div&gt;
        &lt;script type="text/jsx"&gt;
          // ** Our code goes here! **
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>React独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。</p>
<pre><code class="javascript">var HelloMessage = React.createClass({
  render: function() {
    return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
  }
});

React.render(
  &lt;HelloMessage name="John" /&gt;,
  document.getElementById('container')
);</code></pre>
<p>React.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。</p>
<pre><code class="javascript">class ExampleComponent extends React.Component {
 constructor() {
  super();
  this. _handleClick = this. _handleClick.bind(this);
  this.state = Store.getState();
 }
 // ...
}</code></pre>
<h2>Setup:开发环境搭建</h2>
<p>完整的React开发环境应该包括了JSX/ES6的解析以及模块化管理，笔者在这里是选用了WebPack与Babel。Webpack是一个强大的包管理以及编译工具，</p>
<blockquote>
<p>参考资料</p>
<ul><li><p>react-webpack-cookbook</p></li></ul>
</blockquote>
<h3>Webpack</h3>
<pre><code>Webpack是一个非常强大依赖管理与打包工具，其基本的配置方式可以如下：
</code></pre>
<pre><code class="javascript">var path = require('path');
var node_modules = path.resolve(__dirname, 'node_modules');
var pathToReact = path.resolve(node_modules, 'react/dist/react.min.js');

config = {
    entry: ['webpack/hot/dev-server', path.resolve(__dirname, 'app/main.js')],
    resolve: {
        alias: {
          'react': pathToReact
        }
    },
    output: {
        path: path.resolve(__dirname, 'build'),
        filename: 'bundle.js',
    },
    module: {
        loaders: [{
            test: /\.jsx?$/,
            loader: 'babel'
        }],
        noParse: [pathToReact]
    }    
};

module.exports = config;</code></pre>
<h3>Project Structure：项目结构</h3>
<p>一个典型的项目结构你可以参考<a href="https://github.com/RisingStack/react-way-getting-started">这个仓库</a>。</p>
<pre><code>config/  
    app.js
    webpack.js (js config over json -&gt; flexible)
src/  
  app/ (the React app: runs on server and client too)
    components/
      __tests__ (Jest test folder)
      AppRoot.jsx
      Cart.jsx
      Item.jsx
    index.js (just to export app)
    app.js
  client/  (only browser: attach app to DOM)
    styles/
    scripts/
      client.js
    index.html
  server/
    index.js
    server.js
.gitignore
.jshintrc
package.json  
README.md</code></pre>
<h2>Integrated With Angular</h2>
<p>Angular与React是笔者喜欢的两个框架，二者可以相辅相成。可以查看笔者的这个库。</p>
<h2>Integrated With jQuery</h2>
<h2>ES6</h2>
<blockquote><p><a href="http://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes">refactoring-react-components-to-es6-classes</a></p></blockquote>
<p>ES6是一门非常让人兴奋的语言，而React自身的譬如JSX这样的语法也是别具特色，笔者一贯坚持从现在开始就广泛使用ES6。而在React的实践编程中，如果需要完全使用ES6语法进行开发，需要注意以下几点。</p>
<h3>使用Class代替createClass</h3>
<ul><li><p>Before</p></li></ul>
<pre><code class="javascript">var ExampleComponent = React.createClass({
 render: function() { 
  return &lt;div onClick={this._handleClick}&gt;Hello, world.&lt;/div&gt;;
 },
 _handleClick: function() {
  console.log(this);
 }
});</code></pre>
<ul><li><p>After，这里要注意将类的方法绑定到当前对象，避免在方法内部this指针被覆盖</p></li></ul>
<pre><code class="javascript">class ExampleComponent extends React.Component {
 constructor() {
  super();
  this. _handleClick = this. _handleClick.bind(this);
 }
 render() { 
  return &lt;div onClick={this._handleClick}&gt;Hello, world.&lt;/div&gt;;
 }
 _handleClick() {
  console.log(this); // this is an ExampleComponent
 }
}</code></pre>
<h3>在Constructor中初始化State</h3>
<p>如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，但是在ES6的Class中并不会如此自动调用，因此，要稍作修改。</p>
<ul><li><p>Before</p></li></ul>
<pre><code class="javascript">class ExampleComponent extends React.Component {
 getInitialState() {
  return Store.getState();
 }
 constructor() {
  super();
  this. _handleClick = this. _handleClick.bind(this);
 }
 // ...
}</code></pre>
<ul><li><p>After</p></li></ul>
<pre><code class="javascript">class ExampleComponent extends React.Component {
 constructor() {
  super();
  this. _handleClick = this. _handleClick.bind(this);
  this.state = Store.getState();
 }
 // ...
}</code></pre>
<h3>Mixin</h3>
<p>Mixin是React中非常好用的一个功能，但是ES6提倡的面向对象，即使用类继承等方式来进行传递。如果需要在ES6中继续使用Mixin，特别是大量现存的React Library中的Mixin功能，可以有以下几种方式：</p>
<ul>
<li><p>使用extends继承，然后在对应方法中调用父类方法。</p></li>
<li><p>参考<a href="https://github.com/brigand/react-mixin">react-mixin</a>这个库。</p></li>
</ul>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003745823";}i:23;a:11:{s:5:"title";s:33:"前端之React实战-背景概述";s:4:"link";s:42:"http://segmentfault.com/a/1190000003745809";s:2:"id";s:42:"http://segmentfault.com/a/1190000003745809";s:7:"updated";s:25:"2015-09-14T17:22:04+08:00";s:9:"published";s:25:"2015-09-14T17:22:04+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4841:"
<h1>Introduction</h1>
<p><img src="http://image.beekka.com/blog/2015/bg2015033103.png" alt="ScreenShot" title="ScreenShot"></p>
<p>React并不是一个完整的MVC或者MVVM框架，它与Angular也是负责不同的方面，它最大的功能是提供一个高效的视图层。React提供了一些新颖的概念、库和编程原则让你能够同时在服务端和客户端编写快速、紧凑、漂亮的代码来构建你的web应用。如果你使用React，那么可能会涉及到一些常用的概念或技术，包括：</p>
<ul>
<li><p>ES6 React</p></li>
<li><p>虚拟DOM（virtual DOM）</p></li>
<li><p>组件驱动开发（component-driven development）</p></li>
<li><p>不变性（immutability）</p></li>
<li><p>自上而下的渲染（top-down rendering）</p></li>
<li><p>渲染路径和优化</p></li>
<li><p>打包工具, ES6, 构建请求, debugging, 路由等</p></li>
<li><p>同构React（isomorphic React）</p></li>
</ul>
<p>在具体的React实践中，考虑到纯粹的UI或者UX设计人员，他们可能只会将CSS与HTML进行组合，换言之，大量的赋值还是会放置在HTML而非JSX中，建议还是可以运用jQuery+React或者Angular+React的方式。</p>
<h2>Virtual Dom</h2>
<p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶——RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p>
<p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升。</p>
<p><img src="http://wwsun.me/img/posts/150809-react-js-vdom.png" alt="virtual dom" title="virtual dom"></p>
<p>React渲染出来的HTML标记都包含了<code>data-reactid</code>属性，这有助于React中追踪DOM节点。</p>
<blockquote><ul>
<li><p><a href="http://calendar.perfplanet.com/2013/diff/">React’s diff algorithm</a></p></li>
<li><p><a href="http://fluentconf.com/fluent2014/public/schedule/detail/32395">The Secrets of React’s virtual DOM</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/21109361/why-is-reacts-concept-of-virtual-dom-said-to-be-more-performant-than-dirty-mode">Why is React’s concept of virtual DOM said to be moreperformant than dirty model checking?</a></p></li>
<li><p><a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a></p></li>
</ul></blockquote>
<h2>单向数据流</h2>
<p>在React中，应用利用State与Props对象实现单向数据流的传递。换言之，在一个多组件的架构中，某个父类组件只会负责响应自身的State，并且通过Props在链中传递给自己的子元素。</p>
<pre><code class="javascript">/** @jsx React.DOM */

var FilteredList = React.createClass({
  filterList: function(event){
    var updatedList = this.state.initialItems;
    updatedList = updatedList.filter(function(item){
      return item.toLowerCase().search(
        event.target.value.toLowerCase()) !== -1;
    });
    this.setState({items: updatedList});
  },
  getInitialState: function(){
     return {
       initialItems: [
         "Apples",
         "Broccoli",
         "Chicken",
         "Duck",
         "Eggs",
         "Fish",
         "Granola",
         "Hash Browns"
       ],
       items: []
     }
  },
  componentWillMount: function(){
    this.setState({items: this.state.initialItems})
  },
  render: function(){
    return (
      &lt;div className="filter-list"&gt;
        &lt;input type="text" placeholder="Search" onChange={this.filterList}/&gt;
      &lt;List items={this.state.items}/&gt;
      &lt;/div&gt;
    );
  }
});

var List = React.createClass({
  render: function(){
    return (
      &lt;ul&gt;
      {
        this.props.items.map(function(item) {
          return &lt;li key={item}&gt;{item}&lt;/li&gt;
        })
       }
      &lt;/ul&gt;
    )  
  }
});

React.render(&lt;FilteredList/&gt;, document.getElementById('mount-point'));</code></pre>
<p>[React</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003745809";}i:24;a:11:{s:5:"title";s:70:"RestKit ,一个用于更好支持RESTful风格服务器接口的iOS库";s:4:"link";s:42:"http://segmentfault.com/a/1190000003745207";s:2:"id";s:42:"http://segmentfault.com/a/1190000003745207";s:7:"updated";s:25:"2015-09-14T15:21:21+08:00";s:9:"published";s:25:"2015-09-14T15:21:21+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"iOS122";s:10:"author_uri";s:32:"http://segmentfault.com/u/ios122";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:36790:"
<h1>简介</h1>
<p>RestKit 是一个用于更好支持RESTful风格服务器接口的iOS库,可直接将联网获取的json/xml数据转换为iOS对象.</p>
<ul>
<li><p>项目主页: <a href="http://www.ios122.com/tag/restkit/">RestKit</a></p></li>
<li><p>最新示例: <a href="https://github.com/RestKit/RestKit/archive/development.zip">点击下载</a></p></li>
<li><p>注意: 如果无法直接运行示例根目录的工程,可尝试分别运行 Examples 文件夹下的各个子工程,此时你需要给每个子工程都通过 CocoaPods 安装一次 RestKit.</p></li>
</ul>
<h1>快速入门</h1>
<h2>使用环境</h2>
<ul>
<li><p>ARC</p></li>
<li><p>iOS 5.1.1 +</p></li>
</ul>
<h2>安装</h2>
<h3>通过 CocoaPods 安装</h3>
<pre><code class="bash">pod 'RestKit'

# 测试和搜索是可选的组件
pod 'RestKit/Testing'
pod 'RestKit/Search'</code></pre>
<h2>使用</h2>
<p>在需要的地方,引入头文件:</p>
<pre><code class="objective-c">/* 如果使用CoreData,一定要在引入RestKit前引入CoreData.RestKit中有一些预编译宏是基于CoreData是否已经引入;不提前引入CoreData,RestKit中CoreData相关的功能就无法正常使用. */
#import &lt;CoreData/CoreData.h&gt;
#import &lt;RestKit/RestKit.h&gt;

/* Testing 和 Search 是可选的. */
#import &lt;RestKit/Testing.h&gt;
#import &lt;RestKit/Search.h&gt;</code></pre>
<p>以下示例展示了RestKit的基本用法,涉及到网络请求的部分已转由iOS122的测试服务器提供模拟数据.示例代码复制到Xcode中,可直接执行.建议自己新建工程,通过CocoaPods安装RestKit测试.</p>
<h3>对象请求</h3>
<pre><code class="objective-c">/**
 *  定义数据模型: Article
 */
@interface Article : NSObject
@property (nonatomic, copy) NSString * title;
@property (nonatomic, copy) NSString * author;
@property (nonatomic, copy) NSString * body;
@end</code></pre>
<pre><code class="objective-c">// 从/vitural/articles/1234.json获取一篇文章的信息,并把它映射到一个数据模型对象中.
// JSON 内容: {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}}

RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
[mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx 状态.
RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];
    
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/1234.json"]];
RKObjectRequestOperation *operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]];
[operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *result) {
    Article *article = [result firstObject];
    NSLog(@"Mapped the article: %@", article);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];
[operation start];</code></pre>
<h3>管理对象请求</h3>
<pre><code class="objective-c">/* 需要额外引入头文件:#import "RKManagedObjectRequestOperation.h". */
    
// 从 /vitural/articles/888.json 获取文章和文章标签,并存放到Core Data实体中.
// JSON  数据类似: {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!", "categories": [{"id": 1, "name": "Core Data"]}
NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
NSError *error = nil;
BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
if (! success) {
    RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
}
    
// 如果改了实体结构,注意删除手机或模拟器对应路径的数据库
// 文章和标签,要设置 1 对 多的关联!
    
NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.
NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
if (! persistentStore) {
    RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
}
[managedObjectStore createManagedObjectContexts];
    
/* 要在Core Data中预定义相关实体. */
RKEntityMapping *categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:managedObjectStore];
[categoryMapping addAttributeMappingsFromDictionary:@{ @"id": @"categoryID", @"name": @"name" }];
RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:managedObjectStore];
[articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
[articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]];
    
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx的状态码
RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];
    
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/888.json"]];
    
RKManagedObjectRequestOperation *operation = [[RKManagedObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]];
operation.managedObjectContext = managedObjectStore.mainQueueManagedObjectContext;
operation.managedObjectCache = managedObjectStore.managedObjectCache;
[operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *result) {
    NSLog(@"Mapped the article: %@", [result firstObject]);
    
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];
NSOperationQueue *operationQueue = [NSOperationQueue new];
[operationQueue addOperation:operation];</code></pre>
<h3>把网络请求的错误信息映射一个到 NSError</h3>
<pre><code class="objective-c">// 获取 /vitural/articles/error.json,返回报头 422 (Unprocessable Entity)
// JSON 内容: {"errors": "Some Error Has Occurred"}

// 你可以将错误映射到任何类,但是通常使用`RKErrorMessage`就够了.
RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]];
//  包含错误信息的键对应的值,映射到iOS类的错误信息相关的属性中.
[errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]];

NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError);
// 任意报头状态码为 4xx 的返回值.
RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:statusCodes];

NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/error.json"]];
RKObjectRequestOperation *operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@ [errorDescriptor]];
[operation setCompletionBlockWithSuccess:nil failure:^(RKObjectRequestOperation *operation, NSError *error) {
    // 映射到的iOS错误类的`description`方法用来作为localizedDescription的值
    NSLog(@"Loaded this error: %@", [error localizedDescription]);
    
    // 你可以通过`NSError`的`userInfo`获取映射后的iOS类的对象.
    RKErrorMessage *errorMessage =  [[error.userInfo objectForKey:RKObjectMapperErrorObjectsKey] firstObject];
    
    NSLog(@"%@", errorMessage);
}];

[operation start];</code></pre>
<h3>在对象管理器上集中配置.</h3>
<pre><code class="objective-c">// 设置文章或请求出错时的响应描述.
// 成功时的JSON类似于: {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}}
RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
[mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];

// 出错时返回的JSON类似: {"errors": "Some Error Has Occurred"}
RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]];
// 包含错误信息的键对应的值,映射到iOS类的错误信息相关的属性中.

[errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]];
NSIndexSet *errorStatusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError);
// 任意报头状态码为 4xx 的返回值.
RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:errorStatusCodes];

// 把响应描述添加到管理器上.
RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
[manager addResponseDescriptorsFromArray:@[articleDescriptor, errorDescriptor ]];

// 注意,此处所用的接口已在服务器端设置为随机返回正确或错误的信息,以便于测试.
[manager getObject: nil path:@"/vitural/articles/555.json" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    // 处理请求成功获取的文章.
    Article *article = [mappingResult firstObject];
    NSLog(@"Mapped the article: %@", article);

} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    // 处理错误信息.
    NSLog(@"%@", error.localizedDescription);
}];</code></pre>
<h3>在对象管理器中整合CoreData</h3>
<pre><code class="objective-c">/* 配置管理器. */
RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
[RKObjectManager setSharedManager: manager];
    
/* 将管理器与CoreData整合到一起. */
NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
    
NSError * error = nil;
    
BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
if (! success) {
    RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
}
NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.
NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
if (! persistentStore) {
    RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
}
[managedObjectStore createManagedObjectContexts];
    
manager.managedObjectStore = managedObjectStore;
    
/* 将网络请求的数据存储到CoreData, 要在Core Data中预定义相关实体. */
RKEntityMapping *categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:manager.managedObjectStore];
[categoryMapping addAttributeMappingsFromDictionary:@{ @"id": @"categoryID", @"name": @"name" }];
RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:manager.managedObjectStore];
[articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
[articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]];
    
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx的状态码
RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];
    
[manager addResponseDescriptor: responseDescriptor];
[manager getObject: nil path:@"/vitural/articles/888.json" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    // 处理请求成功获取的文章.
    NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    // 处理错误信息.
    NSLog(@"%@", error.localizedDescription);
}];</code></pre>
<h3>从一个地址获取一组数据</h3>
<pre><code class="objective-c">    // 设置文章或请求出错时的响应描述.
    // 成功时的JSON类似于: [{"article":{"title":"My Article 1","author":"Blake 1","body":"Very cool!! 1"}},{"article":{"title":"My Article 2","author":"Blake 2","body":"Very cool!! 2"}},{"article":{"title":"My Article 3","author":"Blake 3","body":"Very cool!! 3"}},{"article":{"title":"My Article 4","author":"Blake 4","body":"Very cool!! 4"}}]
    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.
    
    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles" keyPath:@"article" statusCodes:statusCodes];
    
    // 出错时返回的JSON类似: {"errors": "Some Error Has Occurred"}
    RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]];
    // 包含错误信息的键对应的值,映射到iOS类的错误信息相关的属性中.
    
    [errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]];
    NSIndexSet *errorStatusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError);
    // 任意报头状态码为 4xx 的返回值.
    RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:errorStatusCodes];
    
    // 把响应描述添加到管理器上.
    RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    [manager addResponseDescriptorsFromArray:@[articleDescriptor, errorDescriptor ]];

    [manager getObjectsAtPath:@"/vitural/articles" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        // 处理请求成功获取的文章.
        NSArray * articles = [mappingResult array];
        
        [articles enumerateObjectsUsingBlock:^(Article * article, NSUInteger idx, BOOL *stop) {
            NSLog(@"Mapped the article: %@", article);
        }];
        
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];</code></pre>
<h3>使用队列管理对象请求</h3>
<pre><code class="objective-c">RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];

NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/1234.json"]];

    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/1234.json" keyPath:@"article" statusCodes:statusCodes];

RKObjectRequestOperation *operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[articleDescriptor]];

[operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *result) {
    Article *article = [result firstObject];
    NSLog(@"Mapped the article: %@", article);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];

[manager enqueueObjectRequestOperation:operation]; // 有了这句,就不需要再调用[operation start] 来发起请求了.
[manager cancelAllObjectRequestOperationsWithMethod:RKRequestMethodAny matchingPathPattern:@"/vitural/articles/:articleID\\.json"];</code></pre>
<h3>新建,更新 与 删除对象.</h3>
<pre><code class="objective-c">RKObjectMapping *responseMapping = [RKObjectMapping mappingForClass:[Article class]];
[responseMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx 状态码
RKResponseDescriptor *articlesDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:responseMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles" keyPath:@"article" statusCodes:statusCodes];

RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:responseMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:id" keyPath:@"article" statusCodes:statusCodes];

RKObjectMapping *requestMapping = [RKObjectMapping requestMapping];

[requestMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

// 将 Article 序列化为NSMutableDictionary ,并以 `article`为键.
RKRequestDescriptor *requestDescriptor = [RKRequestDescriptor requestDescriptorWithMapping:requestMapping objectClass:[Article class] rootKeyPath:@"article" method:RKRequestMethodAny];

RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
[manager addRequestDescriptor:requestDescriptor];
[manager addResponseDescriptor:articlesDescriptor];
[manager addResponseDescriptor:articleDescriptor];

Article *article = [Article new];
article.title = @"Introduction to RestKit";
article.body = @"This is some text.";
article.author = @"Blake";

// POST 创建对象.
[manager postObject: article path:@"/vitural/articles" parameters: nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    /* 这个接口服务器的暂时的逻辑是:把POST过去的数据,原样返回,以确认POST请求成功.*/
        Article *article = [mappingResult firstObject];
        NSLog(@"Mapped the article: %@", article);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        NSLog(@"Failed with error: %@", [error localizedDescription]);
    }];

// PACTH 更新对象.
article.body = @"New Body";
[manager patchObject:article path:@"/vitural/articles/1234" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    /* 这个接口服务器的暂时的逻辑是:把PACTH过去的数据,原样返回,以确认PATCH请求成功.*/

    Article *article = [mappingResult firstObject];
    NSLog(@"Mapped the article: %@", article);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];

// DELETE 删除对象.
/* DELETE 操作会影响上面两个接口,最好单独操作. */
//    [manager deleteObject:article path:@"/vitural/articles/1234" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
//        /* 这个接口服务器的暂时的逻辑是:把DELTE过去的数据,article字段设为空,以确认DELETE请求成功.*/
//
//        Article *article = [mappingResult firstObject];
//        NSLog(@"Mapped the article: %@", article);
//    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
//        NSLog(@"Failed with error: %@", [error localizedDescription]);
//    }];</code></pre>
<h3>日志设置</h3>
<pre><code class="objective-c">//  记录所有HTTP请求的请求和相应.
RKLogConfigureByName("RestKit/Network", RKLogLevelTrace);
    
// 记录Core Data 的调试信息.
RKLogConfigureByName("RestKit/CoreData", RKLogLevelDebug);
    
// 记录block的调用.
RKLogWithLevelWhileExecutingBlock(RKLogLevelTrace, ^{
    // 自定义日志信息.
    
});</code></pre>
<h3>配置路由</h3>
<p>路由,提供了URL无关的网络请求调用方式.它是为了在类/某个名字/某个实体联系 与 某个URL建立某种关联,以便再操作某个对象时,只需要告诉RestKit这个对象本身的某些属性就可以直接发送网络请求,而不必每次都去手动拼接 URL.</p>
<pre><code class="objective-c">  /* 设置共享的对象管理器. */
    RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    [RKObjectManager setSharedManager: manager];
    
    /* 将管理器与CoreData整合到一起. */
    NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
    RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
    
    NSError * error = nil;
    
    BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
    if (! success) {
        RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
    }
    NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.
    NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
    if (! persistentStore) {
        RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
    }
    [managedObjectStore createManagedObjectContexts];
    manager.managedObjectStore = managedObjectStore;

    
    // 响应描述,总是必须的.
    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
    
    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    
    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.
    
    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes]; // articleID 应为 Article 类的一个属性.
    [manager addResponseDescriptor: articleDescriptor];
    
    /* 类的路由.配置后,操作某个类时,会自动向这个类对应的地址发送请求. */
    [manager.router.routeSet addRoute:[RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];
    
    /*  发起请求. */
    Article * article = [[Article alloc] init];
    article.articleID = @"888"; // articleId 属性必须给,以拼接地址路由中缺少的部分.
    
    // 因为配置了路由,所以此处不必再传 path 参数.
    [manager getObject: article path:nil parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        // 处理请求成功获取的文章.
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];

    
    /* 关系路由: 使用CoreData实体间关系命名的路由.*/
    /* 仅在测试CoreData关系路由时,才需要把下面一段的代码注释打开. */
//    RKEntityMapping *categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:manager.managedObjectStore];
//    
//    [categoryMapping addAttributeMappingsFromDictionary:@{ @"id": @"categoryID", @"name": @"name" }];
//    RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:manager.managedObjectStore];
//    [articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
//    [articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]];
//    
//    NSIndexSet *coreDataStatusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx的状态码
//    RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:coreDataStatusCodes];
//    
//    [manager addResponseDescriptor: responseDescriptor];
    
    [manager.router.routeSet addRoute:[RKRoute routeWithRelationshipName:@"categories" objectClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];
    
    [manager getObjectsAtPathForRelationship:@"categories" ofObject:article parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        
        // 处理请求成功获取的文章.
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
        
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];

    /* 被命名的路由,可以根据路由名字发起相关请求. */
    [manager.router.routeSet addRoute:[RKRoute routeWithName:@"article_review" pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];
    
    [manager getObjectsAtPathForRouteNamed: @"article_review" object:article parameters: nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        // 处理请求成功获取的文章.
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];</code></pre>
<h3>POST 新建一个含有文件附件的对象.</h3>
<pre><code class="objective-c">  RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    [RKObjectManager setSharedManager: manager];
    
    /* 响应描述,总是必须的. */
    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
    
    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    
    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.
    
    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes]; // articleID 应为 Article 类的一个属性.
    [manager addResponseDescriptor: articleDescriptor];
    
    /* 类的路由.配置后,操作某个类时,会自动向这个类对应的地址发送请求. */
    [manager.router.routeSet addRoute:[RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodPOST]];
    
    Article *article = [[Article alloc]init];
    article.articleID = @"666";
    
    UIImage *image = [UIImage imageNamed:@"test.jpg"]; // 工程中要确实存在一张名为 test.jpg 的照片.
    
    // 序列化对象属性,以添加附件.
    NSMutableURLRequest *request = [[RKObjectManager sharedManager] multipartFormRequestWithObject:article method:RKRequestMethodPOST path:nil parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileData:UIImagePNGRepresentation(image)
                                    name:@"myImg" // 这个字段要和服务器取文件的字段一致.
                                fileName:@"photo.jpg"
                                mimeType:@"image/jpeg"];
    }];
    
    RKObjectRequestOperation *operation = [[RKObjectManager sharedManager] objectRequestOperationWithRequest:request success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        /* 服务器端接口目前自定义的逻辑是: 成功后,会返回图片上传后的服务器地址. */
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        NSLog(@"%@", error.localizedDescription);
    }];
    
    [[RKObjectManager sharedManager] enqueueObjectRequestOperation:operation]; // 注意:要用enqueued,不要使用 started方法.</code></pre>
<h3>以队列方式批量处理对像请求.</h3>
<pre><code class="objective-c">
     RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    
    Article * articleA = [[Article alloc] init];
    articleA.articleID = @"888";
    
    Article * articleB = [[Article alloc] init];
    articleB.articleID = @"1234";
    
    Article * articleC = [[Article alloc] init];
    articleC.articleID = @"555";
    
    /* 以队列方式,发送多个请求. */
    
    [manager.router.routeSet addRoute:[RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];
    
    RKRoute * route = [RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodPOST];

    [manager enqueueBatchOfObjectRequestOperationsWithRoute:route
                                                    objects:@[articleA, articleB, articleC]
                                                   progress:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
                                                       NSLog(@"完成了 %lu 个操作", (unsigned long)numberOfFinishedOperations);
                                                   } completion:^ (NSArray *operations) {
                                                       NSLog(@"所有的文章都已获取!");
                                                   }];</code></pre>
<h3>制作一个种子数据库.</h3>
<p>可以将一个JSON文件转化为一个数据库,用于初始化应用.</p>
<pre><code class="objective-c">NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
    RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
    NSError *error = nil;
    BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
    if (! success) {
        RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
    }
    
    NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.

    NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
    if (! persistentStore) {
        RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
    }
    [managedObjectStore createManagedObjectContexts];
    
    RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:managedObjectStore];
    [articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    
    NSString *seedPath = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"MySeedDatabase.sqlite"]; // 这个数据库文件不必存在,用来充当应用的初始数据库.
    RKManagedObjectImporter *importer = [[RKManagedObjectImporter alloc] initWithManagedObjectModel:managedObjectStore.managedObjectModel storePath:seedPath];
    
    //  使用 RKEntityMapping 从工程文件 "articles.json" 导入数据.
    // JSON 类似于: {"articles": [ {"title": "Article 1", "body": "Text", "author": "Blake" ]}

    error = nil;
    
    NSBundle *mainBundle = [NSBundle mainBundle];
    [importer importObjectsFromItemAtPath:[mainBundle pathForResource:@"articles" ofType:@"json"] // 工程中要有这个文件.
                              withMapping:articleMapping
                                  keyPath:@"articles"
                                    error:&amp;error];
    
    success = [importer finishImporting:&amp;error];
    
    if (success) {
        [importer logSeedingInfo];
    }</code></pre>
<h3>给实体添加索引并检索</h3>
<pre><code class="objective-c">// 要额外添加头文件: #import &lt;RestKit/Search.h&gt;

NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
NSError *error = nil;
BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
if (! success) {
    RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
}
NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"Store.sqlite"];
NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
if (! persistentStore) {
    RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
}
[managedObjectStore createManagedObjectContexts];
[managedObjectStore addSearchIndexingToEntityForName:@"Article" onAttributes:@[ @"title", @"body" ]];
[managedObjectStore addInMemoryPersistentStore:nil];
[managedObjectStore createManagedObjectContexts];
[managedObjectStore startIndexingPersistentStoreManagedObjectContext];

Article *article1 = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:managedObjectStore.mainQueueManagedObjectContext];
article1.title = @"First Article";
article1.body = "This should match search";

Article *article2 = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:managedObjectStore.mainQueueManagedObjectContext];
article2.title = @"Second Article";
article2.body = "Does not";

BOOL success = [managedObjectStore.mainQueueManagedObjectContext saveToPersistentStore:nil];

RKSearchPredicate *predicate = [RKSearchPredicate searchPredicateWithText:@"Match" type:NSAndPredicateType];
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Article"];
fetchRequest.predicate = predicate;

// Contains article1 due to body text containing 'match'
NSArray *matches = [managedObjectStore.mainQueueManagedObjectContext executeFetchRequest:fetchRequest error:nil];
NSLog(@"Found the matching articles: %@", matches);</code></pre>
<h3>对映射进行单元测试</h3>
<pre><code class="objective-c">// JSON looks like {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}}
RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
[mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

NSDictionary *article = @{ @"article": @{ @"title": @"My Title", @"body": @"The article body", @"author": @"Blake" } };
RKMappingTest *mappingTest = [[RKMappingTest alloc] initWithMapping:mapping sourceObject:article destinationObject:nil];

[mappingTest expectMappingFromKeyPath:@"title" toKeyPath:@"title" value:@"My Title"];
[mappingTest performMapping];
[mappingTest verify];</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003745207";}i:25;a:11:{s:5:"title";s:28:"[译] 剖析responsive image";s:4:"link";s:42:"http://segmentfault.com/a/1190000003744572";s:2:"id";s:42:"http://segmentfault.com/a/1190000003744572";s:7:"updated";s:25:"2015-09-14T12:59:35+08:00";s:9:"published";s:25:"2015-09-14T12:59:35+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"risker";s:10:"author_uri";s:32:"http://segmentfault.com/u/risker";s:2:"re";a:1:{s:4:"rank";s:1:"2";}s:7:"summary";s:12834:"
<blockquote>
<p>之所以会翻译这篇文章是因为我昨天看到<a href="http://weibo.com/p/1005051712131295">@勾三股四</a>的这篇<a href="http://weibo.com/1712131295/CzF4rhYXj?type=repost#_rnd1441873035539">微博</a>，里面推荐的文章就是下面我要翻译的。因为自己一直对响应式图片这个技术很关注，但是一直没有一个很好的总结机会，今天趁着翻译这篇文章总结了，这是本人翻译的第一篇文章，有错误的地方请指出。</p>
<p><a href="https://github.com/riskers/blog/issues/5">博客地址</a> 欢迎关注</p>
<p><a href="https://jakearchibald.com/2015/anatomy-of-responsive-images/">原文地址</a></p>
</blockquote>
<h1>剖析responsive image</h1>
<p>最近对<code>responsive image</code>有一些感悟然后赶紧记下来免得忘了。下面就是我的感悟：</p>
<h2>尺寸固定，不同屏幕密度</h2>
<p>如果你是用像素来固定图片尺寸,又想在不同屏幕密度屏幕上实现响应式图片，可以这样：</p>
<pre><code>&lt;img width="320" height="213"
    src="cat.jpg"
    srcset="cat-2x.jpg 2x,cat-3x.jpg 3x"&gt;</code></pre>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-9/75406563.jpg" alt="f1" title="f1"></p>
<p>它可以正常运行在<a href="http://caniuse.com/#search=srcset">所有现代浏览器</a>上，而且在不支持<code>srcset</code>的浏览器也可以降级到<code>src</code>。</p>
<p>有一些规则是上面图片所没有提到的:</p>
<ul>
<li><p><code>srcset</code>里的每一项都是<code>&lt;url&gt; &lt;density&gt;x</code>结构 ,就像<code>cat-2x.jpg 2x</code></p></li>
<li><p><code>srcset</code>里项目的顺序并不重要</p></li>
<li><p>如果你没有声明<code>width</code>/<code>height</code>，浏览器会按照屏幕密度展示它本身原始的<code>width</code>/<code>height</code>。 比如<code>2x</code>资源被匹配到了，它会被渲染成本身的 50%<code>width</code>和 50%<code>height</code></p></li>
<li><p>提示一下，如果在<code>3x</code>设备像素比的设备上浏览器渲染的是<code>1x</code>的图片，可能是因为糟糕的网络环境</p></li>
</ul>
<hr>
<p><a href="http://codepen.io/riskers/full/OyVadp/">案例</a></p>
<blockquote>
<p>这个案例使用的是3张一样的图片，只是尺寸不一样，这样我们很难看出区别。所以译者在这里换了这几张图，然后在Chrome中模拟手机调试，更换分辨率，应该就很明显了。</p>
<p><a href="http://codepen.io/riskers/full/ZbGVzm/">译者案例</a></p>
<p>这种方法因为要人为匹配设备像素比，所以<code>1x</code>、<code>2x</code>、<code>3x</code>、<code>4x</code>等等，这样HTML就会太臃肿，所以有了下面的新方法。</p>
</blockquote>
<h2>尺寸和屏幕密度都不同</h2>
<p>不同宽度的图片在响应式站点里是很常见的。在这篇博客里,图片内容都是占据了文章100%的宽度，但是文章的宽度并不总是窗口宽度的100%。</p>
<p>为了让浏览器匹配到正确的图片，我们需要知道：</p>
<ul>
<li><p>不同尺寸图片的地址</p></li>
<li><p>每张图片的宽度</p></li>
<li><p><code>&lt;img&gt;</code>的宽度</p></li>
</ul>
<p>最后一点是特别困难的，因为图片开始下载是在CSS解析之前的，所以<code>&lt;img&gt;</code>的宽度不能从页面布局那得到。</p>
<pre><code>&lt;img src="panda-689.jpg"
    srcset = "panda-689.jpg 689w,
                panda-1378.jpg 1378w
                panda-500.jpg 500w
                panda-1000.jpg 1000w"
    sizes = " (min-width:1066px) 689px,
                (min-width:800px) calc(75vw-137px) ,
                (min-width:530px) calc(100vw-96px) ,
                100vw" &gt;</code></pre>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-9/29625219.jpg" alt="f2" title="f2"></p>
<p>通过<code>srcset</code>属性，浏览器知道了哪些图片可用以及这些图片的宽度。<br>通过<code>sizes</code>属性，浏览器知道了<code>&lt;img&gt;</code>相对于一个已知宽度窗口的宽度。<br>这样，浏览器就可以匹配最佳资源加载了。</p>
<p>你不再需要说明屏幕密度，浏览器自己会辨别。如果浏览器窗口宽度是<code>1066px</code>甚至更大，<code>&lt;img&gt;</code>会被定为<code>689px</code>。在<code>1x</code>设备浏览器上会下载<code>panda-689.jpg</code>，但是在<code>2x</code>设备浏览器上将会下载<code>panda-1378.jpg</code>。</p>
<blockquote>
<p>这里感觉作者并没有解释清楚 <code>sizes</code>和<code>srcset</code>的工作原理(参照下面的<a href="http://codepen.io/riskers/full/KddzxV/">译者案例</a>来看)。</p>
<p>首先，是关于<code>sizes</code>的理解：<br>比如当前窗口<code>800px</code>，那么<code>sizes</code>会匹配到<code>(min-width:800px) calc(75vw - 137px)</code> ，则这个<code>&lt;img&gt;</code>对应的宽度就是<code>800px*0.75-137px=463px</code>。这个宽度的设定相当于</p>
<pre><code>&lt;img src="..."  width="463" /&gt;</code></pre>
<p>知道了<code>&lt;img&gt;</code>的<code>width</code>，然后再看<code>srcset</code>的<code>w</code>:<br>在<code>dpr</code>为<code>1</code>的时候，<code>463px</code>对应<code>463w</code>，查找<code>srcset</code>，找到<code>500w</code>适合它，就显示500的这张图。<br>在<code>dpr</code>为<code>2</code>的时候，<code>463px</code>对应<code>926w</code>，查找<code>srcset</code>，找到<code>1000w</code>适合，就显示1000的这张图。</p>
</blockquote>
<p>一些规则是上面没有提到的：</p>
<ul>
<li><p><code>srcset</code>里的每一项是<code>&lt;url&gt; &lt;width-descriptor&gt;w</code>，比如<code>panda-689.jpg 689w</code></p></li>
<li><p><code>srcset</code>里每一项的顺序没有影响</p></li>
<li><p>如果<code>srcset</code>包含了一个宽度描述符(<code>w</code>)，则<code>src</code>会被那些支持<code>srcset</code>的浏览器忽略掉</p></li>
<li><p><code>sizes</code>里的每一项是<code>&lt;媒体查询&gt; &lt;图片宽度&gt;</code>形式，除了最后一个仅仅是<code>&lt;图片宽度&gt;</code></p></li>
<li><p><code>sizes</code>里的宽度单位都是<code>px</code></p></li>
<li><p>浏览器使用<code>sizes</code>里的第一个匹配到的媒体查询，所以<code>sizes</code>里的顺序是很重要的</p></li>
<li><p>和上面一样，浏览器下载一个低分辨率图片可能是因为糟糕的网络</p></li>
</ul>
<p>如果你没有指明<code>&lt;img&gt;</code>的宽度，浏览器也会正常解析。对<code>sizes</code>精确设置，但是一个不是很确切的宽度也很好。比如</p>
<pre><code>sizes="(min-width:1066px) 689px ,
    (min-width:800px) 75vw,100vw"</code></pre>
<p>挑选哪些图片资源放在<code>srcset</code>里是很困难的，我也没有完全掌握技巧。在上面的例子里，我设置了一个最小尺寸(注：原文中是最大)(<code>689px</code>)，然后给<code>2x</code>设备设置刚才的两倍尺寸(<code>1378px</code>)。另外两个设置是在这两个值中间任意取的。我没有设置更小的宽度比如<code>320px</code>,因为在这一情况下的屏幕密度是<code>2x</code>或者更高。</p>
<p><code>srcset</code> + <code>sizes</code> 在 Chrome、Firefox和Opera中都兼容。至于其他浏览器，也会很安全地回退到<code>src</code>属性。不用等待很久，<code>WebKit nightly</code> 和 下一个稳定版本的<code>Edge</code>就会很好地支持它。</p>
<blockquote>
<p><code>WebKit nightly</code>是WebKit的<code>mac port</code>，对于<code>Safari</code>就像<code>Chromium</code>对于<code>Chrome</code></p>
<p><a href="http://www.infoq.com/cn/articles/webkit-for-developers">开发者需要了解的WebKit</a></p>
</blockquote>
<hr>
<p><a href="http://codepen.io/riskers/full/vNObYd/">案例</a></p>
<blockquote>
<p>原文中<code>&lt;img&gt;</code>有一个内联样式<code>width:100%</code>，一开始没有注意到的话还以为没有变化呢。上面的案例已经修改过了 -。-</p>
<p>还是因为作者使用了内容相同，尺寸的图片，所以我换了图片重新做了一个例子：</p>
<p><a href="http://codepen.io/riskers/full/KddzxV/">译者案例</a></p>
<p>这种新方法的<code>srcset</code>用来指向提供的图片资源，没有上面方法的<code>1x</code>、<code>2x</code>，这个都交给浏览器。例子中就指向了3个尺寸图片。</p>
<p><code>sizes</code>用来表示尺寸临界点，用媒体查询定下图片的实际宽度。</p>
</blockquote>
<h2>不同宽度、分辨率和艺术指导</h2>
<p>和之前的例子类似除了框架的不同宽度的变化。它允许你集中精力对付更小的宽度。</p>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-9/18516116.jpg" alt="f3" title="f3"></p>
<ul>
<li><p>只要你想，你可以有很多<code>&lt;source&gt;</code></p></li>
<li><p>你必须包含一个<code>&lt;img&gt;</code></p></li>
<li><p>媒体查询<code>&lt;source&gt;</code>元素上总是被服从的</p></li>
<li><p>媒体查询是基于窗口的宽度，不是<code>&lt;img&gt;</code>的</p></li>
<li><p>第一个匹配到的<code>&lt;source&gt;</code>会被使用，所以顺序很重要</p></li>
<li><p>如果没有匹配到<code>&lt;source&gt;</code>，则<code>&lt;img&gt;</code>被调用</p></li>
<li><p><code>&lt;img&gt;</code>必须出现在<code>&lt;source&gt;</code>后面</p></li>
<li><p><code>&lt;source&gt;</code>不支持<code>src</code>，但是支持<code>srcset</code></p></li>
</ul>
<p>一旦<code>&lt;source&gt;</code>或者<code>&lt;img&gt;</code>被选中，<code>srcset</code>和<code>sizes</code>属性就像之前的例子一样解析。</p>
<blockquote>
<p><code>艺术指导</code>:剪裁图片内容来适应特定环境，任何时候我们裁剪或是修改图片来适应一个断点（而非简单缩放），都是一种艺术指导。</p>
<p>可以看出来，艺术指导比之前的<code>srcset</code>+<code>sizes</code>又多了一层维度:<code>source</code>的媒体查询。</p>
</blockquote>
<p><code>&lt;picture&gt;</code>元素在Chrome、Firefox和Opera中<a href="http://caniuse.com/#search=picture">兼容良好</a>，在其他浏览器可以回退到<code>&lt;img&gt;</code>。而下一代的<a href="https://twitter.com/jacobrossi/status/639471869473656832">Edge也可能会支持</a>。</p>
<p>--</p>
<p><a href="http://codepen.io/riskers/full/ZbGPGX/">案例</a></p>
<h2>不同类型</h2>
<p>这个方法可以让你有更优化的方式去提供给支持它们的浏览器。</p>
<pre><code>&lt;picture&gt;
    &lt;source type="image/webp"
        srcset="snow.webp"&gt;
    &lt;img src="snow.jpg"&gt;
&lt;/picture&gt;</code></pre>
<p><img src="http://7xlc2a.com1.z0.glb.clouddn.com/15-9-10/46700329.jpg" alt="f4" title="f4"></p>
<ul>
<li><p><code>type</code>属性是<code>mime</code>类型</p></li>
<li><p>你可以有很多种资源和混合<code>type</code>和<code>media</code>、<code>srcset</code>甚至是<code>sizes</code>取创建一些惊奇的东西</p></li>
</ul>
<p>它在Chrome、Firefox和Opera上<a href="http://caniuse.com/#search=picture">兼容良好</a>，其他浏览器还可以回退到<code>&lt;img&gt;</code>。</p>
<hr>
<p><a href="http://codepen.io/riskers/full/xwGopm/">案例</a></p>
<h2>扩展阅读</h2>
<p>希望上面的文章能够对各种用例起到参考作用，你可以继续看看下面的文章：</p>
<ul>
<li><p><a href="http://blog.cloudfour.com/responsive-images-101-definitions/">十段响应式图片文章</a> - Jason Grigsby</p></li>
<li><p><a href="https://dev.opera.com/articles/responsive-images/">响应式图片:用例和代码片段</a> - 和这篇文章类似，但是有更多用例</p></li>
<li><p><a href="https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints">Client hints</a> - 服务端代替响应式图片的方法</p></li>
</ul>
<h2>译者推荐文章</h2>
<p>与本文结构类似的文章：</p>
<ul>
<li><p><a href="http://efe.baidu.com/blog/responsive-images-in-practice/">实战响应式图片</a> - EFE</p></li>
<li><p><a href="https://developers.google.com/web/fundamentals/media/images/images-in-markup#section">响应式图片指南</a> - form <code>Google Developers</code></p></li>
<li><p><a href="https://dev.opera.com/articles/responsive-images/">开始使用响应式图片</a> - from <code>dev.opera</code> 结构十分清晰</p></li>
</ul>
<p>补充文章：</p>
<ul>
<li><p><a href="http://responsiveimages.org/demos/">艺术指导的例子</a></p></li>
<li><p><a href="http://responsiveimages.org/">响应式图片讨论组</a></p></li>
<li><p><a href="https://imququ.com/post/http-client-hints.html">HTTP Client Hints介绍</a></p></li>
</ul>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003744572";}i:26;a:11:{s:5:"title";s:45:"如何设计 HTTP 接口异常状态的返回";s:4:"link";s:42:"http://segmentfault.com/a/1190000003744014";s:2:"id";s:42:"http://segmentfault.com/a/1190000003744014";s:7:"updated";s:25:"2015-09-14T10:52:45+08:00";s:9:"published";s:25:"2015-09-14T10:52:45+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:9:"艾彦波";s:10:"author_uri";s:33:"http://segmentfault.com/u/aiyanbo";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4241:"
<h1>如何设计 HTTP 接口异常状态的返回</h1>
<hr>
<p>上周五，我在做一个 HTTP 接口的迁移。刚好跟同事进行了一场关于 HTTP 接口的状态返回的讨论。很巧合地是，我们的观点互不相同，在他看来：</p>
<p><strong>所有业务返回的响应状态码都应该是200，包含业务异常的响应状态码也是200，错误的消息放在 Body 里面描述；未到达业务层的请求，例如：5XX, 403 这样的错误应该算作是 “连接层” 的错误。</strong></p>
<p><strong>这样做的优点是：</strong></p>
<ol>
<li><p>对于 5XX, 403 这样的错误可以归纳为 “连接” 错误。可以统一处理？</p></li>
<li><p>客户端只需在接受到 200 的状态码时才做业务处理。</p></li>
</ol>
<p><strong>但是在我看来，这有一个很大的缺点：</strong></p>
<ul><li><p>对于业务异常无法在第一层的 status code 里面发现，需要进一步解析 body， 响应的 body 有 2 个 Schema, 即 error message  和业务响应实体的 schema。这样做的厂商其实很多，例如： LeanColud 的获取数据的接口。</p></li></ul>
<pre><code>GET /1.1/classes/&lt;className&gt;/&lt;objectId&gt; </code></pre>
<p>在使用这个接口获取一个不存在的 <code>objectId</code> 时，响应的格式是：</p>
<pre><code>Response Status Code: 200
Response Body: {}</code></pre>
<p>这个接口把 <code>className</code> 与 <code>objectId</code> 都做成了 path parameter, 通常地，我们不应该用 404 来描述一个 URL 不存在的情况吗？</p>
<p>如果我要使用这个接口，我在客户端接收到响应之后大概要做以下的处理：</p>
<ol>
<li><p>判断 http status code 是否是 200。</p></li>
<li><p>解析 http body 是否是一个 error message。</p></li>
<li><p>解析 http body 为业务实体。</p></li>
<li><p>判断解析后的业务实体是否是"空"。</p></li>
</ol>
<p>所以，我的观点刚好相反：<strong>所有响应的状态要充分利用 http status code 来描述响应的异常情况， 并且配合 http body 来描述更详细的 error message</strong>。</p>
<p>我同事他认为这样做的缺点是：</p>
<ul><li><p>http status code 是非常有限的，且不能扩展。</p></li></ul>
<p>那么我们该怎么处理这种 http status code 表达能力不足的情况呢？ 答案是： 使用 http status code 来代表某一个类型的异常，同时用 http response body 来描述更详细的异常消息。 例如：</p>
<pre><code>Response Status Code: 400
Response Body:
    {
        "code": "missing_parameter_name",
        "message": "请求中必须包含参数 name"
    }

Response Status Code: 400
Response Body:
    {
        "code": "id_not_matched",
        "message": "id 格式应该为: \w+"
    }</code></pre>
<p>上面的例子中我们使用了 400 来描述了一个 <code>Bad Request</code>， 并且将更加详细的业务异常表达出来了！ 来看看我如何改造 LeanCloud 的接口返回：</p>
<pre><code>Response Status Code: 200
Response Body: 
    {
        "objectId": "xxx",
        "name": "这是一个业务实体"
    }
    
Response Status Code: 404
Response Body:
    {
        "error": "resource_not_found",
        "message": "无法在 className 下找打 objectId 资源"
    }</code></pre>
<p>总结一下我这种设计方式的优点：</p>
<ol>
<li><p>可以根据 http status code 判断响应是否正常。</p></li>
<li><p>无需将一个 response body 适配多个 schema 解析。</p></li>
<li><p>客户端友好，无需过多包装 response body，在正常返回的情况下数据可以直接使用，无需拆箱。</p></li>
</ol>
<h2>总结</h2>
<p>接口设计可以千变万化，可以说没有哪一种方案是完美的，我们在设计的接口的时候也要尽可能地站在使用者的角度考虑下面的原则：</p>
<ol>
<li><p>客户端友好，响应的层次尽可能简洁。</p></li>
<li><p>数据不要过渡封装，最好能做到即拿即用。</p></li>
<li><p>接口名称简洁明了。</p></li>
</ol>
<p>对于 HTTP 接口的更多实践经验可以查看我的文章 <a href="http://segmentfault.com/a/1190000002949234">RESTful Best Practices</a></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003744014";}i:27;a:11:{s:5:"title";s:11:"Git  简介";s:4:"link";s:42:"http://segmentfault.com/a/1190000003743788";s:2:"id";s:42:"http://segmentfault.com/a/1190000003743788";s:7:"updated";s:25:"2015-09-14T10:18:19+08:00";s:9:"published";s:25:"2015-09-14T10:18:19+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"desdik";s:10:"author_uri";s:32:"http://segmentfault.com/u/desdik";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:11330:"
<h2><strong>Git的简史</strong></h2>
<p>　　同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>　　Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>　　到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者Linux Torvalds）基于使用 BitKcheper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p>
<ul>
<li><p>速度</p></li>
<li><p>简单的设计</p></li>
<li><p>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p></li>
<li><p>完全分布式</p></li>
</ul>
<p>　　有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>　　自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p>
<p>　　Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<h2><strong>Git是什么？</strong></h2>
<p>　　Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>　　Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>　　最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本。有时候偷懒省事，保存副本时命名比较随意，时间长了就不知道哪个是新的，哪个是老的了，即使知道新旧，可能也不知道每个版本是什么内容，相对上一版作了什么修改了，当几个版本过去后，很可能就是下面这个老土的样子了：</p>
<p><img src="/img/bVpR5c" alt="汇智网" title="汇智网"></p>
<h2><strong>Git特点</strong></h2>
<p>　　分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p>
<ul>
<li><p><strong>直接记录快照，而非差异比较</strong> ： Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。</p></li>
<li><p><strong>近乎所有操作都是本地执行</strong> ：在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。</p></li>
<li><p><strong>时刻保持数据完整性</strong> ：在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</p></li>
<li><p><strong>多数操作仅添加数据</strong> ：常用的 Git 操作大多仅仅是把数据添加到数据库。</p></li>
</ul>
<p>　　开发流程示意图：</p>
<p><img src="/img/bVpR5n" alt="汇智网 开发流程图" title="汇智网 开发流程图"></p>
<h2><strong>集中版本控制</strong></h2>
<p>　　CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p>
<p>　　集中式版本控制系统，版本库是集中存放在中央服务器的，一起工作的人需要用自己的电脑从服务器上同步更新或上传自己的修改。</p>
<p><img src="/img/bVpR5z" alt="汇智网 版本控制" title="汇智网 版本控制"></p>
<p>　　但是，所有的版本数据都存在服务器上，用户的本地设备就只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。。</p>
<p>　　而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。</p>
<h2><strong>分布式版本控制</strong></h2>
<p>　　那分布式版本控制系统与集中式版本控制系统有何不同呢？</p>
<p>　分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网就可以工作。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你和同事在各自电脑修改相同文件，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>　　分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库。大家之间可以相互复制。</p>
<p>　　分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p><img src="/img/bVpR5A" alt="汇智网 版本控制" title="汇智网 版本控制"></p>
<h2><strong>安装Git</strong></h2>
<p>　　最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>　　在Linux上安装Git</p>
<p>　　首先，你可以试着输入git，看看系统有没有安装Git：</p>
<pre><code>$ git
</code></pre>
<p>　　像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>　　如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。如果想查看是否安装成功，通过git --version。</p>
<p>　　如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<p>　　安装完成后，还需要最后一步设置，在命令行输入：　　</p>
<pre><code>$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
</code></pre>
<p>　　因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和Email地址。</p>
<p>　　注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。在此课程中，我们配置的环境中Git已安装好，我们课程提供也是在Linux系统中命令进行操作。</p>
<h2><strong>什么是版本库？</strong></h2>
<p>　　版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>　　所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/home/hubwiz/learngit
</code></pre>
<p>　　pwd命令用于显示当前目录。在环境中这个仓库位于/home/hubwiz/learngit。</p>
<p>　　通过git init命令把这个目录变成Git可以管理的仓库：</p>
<pre><code>$ git init
Initialized empty Git repository in /home/hubwiz/learngit/.git/
</code></pre>
<p>　　瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>　　如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<h2><strong>添加文件</strong></h2>
<p>　　我们了解下版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>　　为了简明起见，我们创建一个readme.txt作为练习：</p>
<pre><code>echo "Git is a version control system." &gt; readme.txt
// 输入这句话保存到创建的readme.txt文件中
echo " Git is free software." &gt;&gt; readme.txt
// 输入此内容追加到readme.txt中
</code></pre>
<p>　　一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>　　用命令git add告诉Git，把文件添加到仓库：</p>
<pre><code>$ git add readme.txt
</code></pre>
<p>　　git add 实际上是个脚本命令，没有任何显示，说明添加成功。</p>
<h2><strong>提交文件</strong></h2>
<p>　　用命令git commit告诉Git，把文件提交到仓库：</p>
<pre><code>$ git commit -m "wrote a readme file"
[master (root-commit) cb926e7] wrote a readme file
1 file changed, 2 insertions(+)
create mode 100644 readme.txt
</code></pre>
<p>　　简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>　　git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>　　为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."
</code></pre>
<h2><strong>小结</strong></h2>
<p>此节知识点我们所学习的内容：</p>
<p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<p>第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；<br>第二步，使用命令git commit，完成。</p>
<p>网站上还有更多内容和对应每一小节的在线练习大家可以去试试。<br><a href="http://www.hubwiz.com/course/55d301543ad79a1b05dcc4e2/">http://www.hubwiz.com/course/55d301543ad79a1b05dcc4e2/</a></p>
<p><img src="/img/bVpR5F" alt="汇智网 git" title="汇智网 git"></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003743788";}i:28;a:11:{s:5:"title";s:27:"Java  ArrayList源码分析";s:4:"link";s:42:"http://segmentfault.com/a/1190000003743218";s:2:"id";s:42:"http://segmentfault.com/a/1190000003743218";s:7:"updated";s:25:"2015-09-14T08:34:26+08:00";s:9:"published";s:25:"2015-09-14T08:34:26+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"佚名";s:10:"author_uri";s:44:"http://segmentfault.com/u/ming_55e57cb682df4";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:8253:"
<h2>ArrayList介绍</h2>
<p><code>List</code> 接口的一个实现类，内部是用一个数组存储元素值，相当于一个可变大小的数组。</p>
<h2>签名</h2>
<pre><code>public class ArrayList&lt;E&gt;
extends AbstractList&lt;E&gt;
implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable
</code></pre>
<p>可以看到<code>ArrayList</code>继承了<code>AbstractList</code>抽象类，它实现了<code>List</code>接口的大多数方法。如果要实现一个不可变的<code>List</code>，只要继承这个类并且实现<code>get(int)</code>和<code>size</code>方法。如果要实现可变的<code>List</code>，需要覆盖<code>set(int, E)</code>。另外，如果<code>List</code>的大小是可变的，还要覆盖<code>add(int, E)</code>和<code>remove()</code>方法。</p>
<h2>构造器</h2>
<p><code>ArrayList</code>提供了三个构造器：</p>
<pre><code>ArrayList()
ArrayList(Collection&lt;? extends E&gt; c)
ArrayList(int initialCapacity)</code></pre>
<p><code>Collection</code>接口约定，每个集合类应该提供两个”标准”构造器，一个是无参数的构造器（上面第一个），另外一个是拥有单个参数（类型为<code>Collettion</code>）的构造器（上面第二个）。ArrayList还提供了第三个构造器，其接受一个int值，用于设置ArrayLi的初始大小（默认大小为10）。</p>
<h2>相关方法</h2>
<h3><code>trimToSize</code></h3>
<pre><code>public void trimToSize() {
        modCount++;
        int oldCapacity = elementData.length;
        if (size &lt; oldCapacity) {
            elementData = Arrays.copyOf(elementData, size);
        }
    }</code></pre>
<p>用于把<code>ArrayList</code>的容量缩减到当前实际大小，减少存储容量。其中的变量<code>modCount</code>由<code>AbstracList</code>继承而来，记录List发生结构化修改（structurally modified）的次数。<code>elementData</code>中实际存储了<code>ArrayList</code>的元素，在<code>ArrayList</code>中声明为：<code>private transient Object[] elementData;</code>变量<code>size</code>是<code>ArrayList</code>的元素数量，当<code>size &lt; oldCapacity</code>时，调用<code>Arrays.copyOf</code>方法实现缩减。</p>
<h3>
<code>indexOf</code> 和 <code>lasIndexOf</code>
</h3>
<pre><code>public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i &lt; size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i &lt; size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }</code></pre>
<p>这两个方法返回指定元素的下标，要区分参数是否为<code>null</code>。<code>lastIndexOf</code>和<code>indexOf</code>类似，只不过是从后往前搜索。</p>
<h3><code>ensureCapacity</code></h3>
<pre><code>public void ensureCapacity(int minCapacity) {
       if (minCapacity &gt; 0)
           ensureCapacityInternal(minCapacity);
   }
private void ensureCapacityInternal(int minCapacity) {
        modCount++;
        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }</code></pre>
<p>这个方法可以确保<code>ArrayList</code>的大小</p>
<h3>
<code>add</code> 和 <code>addAll</code>
</h3>
<pre><code>public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }</code></pre>
<p><code>add(int index, E element)</code>向指定位置添加元素，首先调用<code>rangeCheckForAdd</code>检查<code>index</code>是否有效，如果<code>index &gt; size || index &lt; 0</code>将抛出异常。然后确保容量加1，调用<code>System.arraycopy</code>把从<code>index</code>开始的元素往后移动一个位置。最后把<code>index</code>处的值设置为添加的元素。还有一个重载的<code>add(E e)</code>方法是直接把元素添加到末尾。<br><code>addAll(Collection&lt;? extends E&gt; c)</code>和<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>则分别是向末尾和指定位置添加<code>Collection</code>中的所有元素。</p>
<h3>
<code>remove</code> 和 <code>removeAll</code>
</h3>
<pre><code>public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }</code></pre>
<p><code>remove(Object o)</code>方法删除指定的元素。首先是查找元素位置，然后调用<code>fastRemove(index)</code>删除，其代码如下：</p>
<pre><code>private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            //把index+1往后的元素都往前移动一个位置
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // Let gc do its work
    }</code></pre>
<p>重载的<code>remove(int index)</code>方法用于删除指定位置的元素。<code>removeRange(int fromIndex, int toIndex)</code>用于删除指定位置之间的所有元素。<br><code>removeAll(Collection&lt;?&gt; c)</code>和<code>retainAll(Collection&lt;?&gt; c)</code>代码如下：</p>
<pre><code>public boolean removeAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, false);
    }
public boolean retainAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }</code></pre>
<p>它们都是通过调用<code>batchRemove</code>方法实现的，其代码如下：</p>
<pre><code>private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r &lt; size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i &lt; size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }</code></pre>
<p>这个方法有两个参数，第一个是操作的<code>Collection</code>，第二个是一个布尔值，通过设置为<code>true</code>或<code>false</code>来选择是<code>removeAll</code>还是<code>retainAll</code>。<code>try</code>里面的语句是把留下来的放在0到w之间，然后在<code>finally</code>中第二个<code>if</code>处理w之后的空间，第一个是在<code>c.contains()</code>抛出异常时执行。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003743218";}i:29;a:11:{s:5:"title";s:33:"闲谈异步调用“扁平”化";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742890";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742890";s:7:"updated";s:25:"2015-09-13T23:42:42+08:00";s:9:"published";s:25:"2015-09-13T23:42:42+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:12:"边城狂人";s:10:"author_uri";s:36:"http://segmentfault.com/u/jamesfancy";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:3400:"
<blockquote><p>哦，代码……就把它们当成插图吧</p></blockquote>
<p>随着 CPU 从单核变多核，软件从注重功能到注重体验，Web 从页面跳转方式到 Web2.0 的无刷新加载（AJAX），程序员越来越多的接触多线程和异步。而 Android 的主线程中不允许操作网络，更是将程序员们推向了异步的深渊。异步深渊产生的主要原因是回调，这在 nodejs 里尤其严重。</p>
<pre><code class="javascript">// [node.js]

doFirstThing(function(err, data) {
    doSecondThing(data, function(err, data) {
        doThirdThing(data, function(err, data) {
            // ... fall down
        })
    });
});</code></pre>
<p>为了逃离回调的深渊，大家开始想各种办法来把回调扁平化。</p>
<p>在 JavaScript 中，Promise<em>（指该类方法而非某个库）</em>成为众多解决方案的佼佼者，并成功被 ES6 采纳。</p>
<pre><code class="javascript">// [node.js]

doFirstThing()
    .then(doSecondThing)
    .then(doThirdThing)
    // .then(...) - continuous
    .catch(function() {
        // something wrong
    });</code></pre>
<p>而 C# 则通过 Task 和 ThreadPool 让异步编程变得容易。前面谈论的 <a href="http://segmentfault.com/a/1190000003097290">C# 并行计算（Parallel 和 ParallelQuery）</a> 就是基于 Task 的。不过使用 <code>Task.ContinueWith()</code> 和 <code>Parallel.ForEach()</code> 的时候，就会觉得：这不就是 Promise 吗？</p>
<pre><code class="cs">// [csharp]

Task.Run(() =&gt; {
    // do first thing and return a data
    return "first";
}).ContinueWith(task =&gt; {
    // do second thing and return a data
    return new []{ task.Result, "second" };
}).ContinueWith(task =&gt; {
    // do final thing
    foreach (string s in task.Result) { Console.WriteLine(s); }
}).Wait();</code></pre>
<p>之后 C#5.0 又推出 <code>async/await</code> 方案，将异步代码写得像同步代码一样，由编译器来将 <code>async/await</code> 代码封装成异步 Task 方式，而不是由人工处理，这大大降低了写异步程序的门槛。</p>
<pre><code class="cs">// [csharp]

private async static Task Process() {
    string first = await Task.Run(() =&gt; "first");
    string[] all = await Task.Run(() =&gt; {
        return new [] { first, "second" };
    });
    
    await(Task.Run(() =&gt; {
        foreach (string s in all) { Console.WriteLine(s); }
    }));
}</code></pre>
<p>JavaScript 程序员们一边在等着 ES7 的 <code>async/await</code> 特性，一边也没闲着，在 ES6 <code>generator/yield</code> 特性基础上开发了个 <a href="https://github.com/tj/co">co</a> 出来，提供了类似于 <code>async/await</code> 特性的异步编程方式。</p>
<pre><code class="javascript">// [node.js]

var co = require("co");

co(function*() {
    var first = yield new Promise(function(resolve) {
        setTimeout(function() {
            resolve("first");
        }, 100);
    });

    var all = yield new Promise(function(resolve) {
        setTimeout(function() {
            resolve([first, "second"])
        }, 200);
    })

    console.log(all);
});

// [ 'first', 'second' ]</code></pre>
<p>不过 co 程序写起来又要写 Generator，又要用 yeild，还常常要封装 Promise，代码仍然不够简洁。所以继续期待 ES7 的 <code>async/await</code> 特性。</p>
<hr>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742890";}i:30;a:11:{s:5:"title";s:51:"Swift&amp;Cocoa实战之数据类型﹣时间日期";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742865";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742865";s:7:"updated";s:25:"2015-09-13T23:34:57+08:00";s:9:"published";s:25:"2015-09-13T23:34:57+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:6440:"
<h1>时间日期</h1>
<h2>NSDate</h2>
<p>在Objective-C中，可以使用如下的代码创建一个UTC的时间：</p>
<pre><code>NSDate *currentUTCDate = [NSDate date]</code></pre>
<p>但是在Swift中，如果使用如下方式：</p>
<pre><code>let date = NSDate()</code></pre>
<p>获取到的会是本地时间。</p>
<h3>UTC时间与本地化时间</h3>
<pre><code class="swift">import UIKit

let date = NSDate();
// "Apr 1, 2015, 8:53 AM" &lt;-- local without seconds

var formatter = NSDateFormatter();
formatter.dateFormat = "yyyy-MM-dd HH:mm:ss ZZZ";
let defaultTimeZoneStr = formatter.stringFromDate(date);
// "2015-04-01 08:52:00 -0400" &lt;-- same date, local, but with seconds
formatter.timeZone = NSTimeZone(abbreviation: "UTC");
let utcTimeZoneStr = formatter.stringFromDate(date);
// "2015-04-01 12:52:00 +0000" &lt;-- same date, now in UTC</code></pre>
<h3>时间比较</h3>
<p>如果需要比较两个日期，可以使用如下方法，在如下代码中已经展示了如何处理不同的返回结果：</p>
<pre><code class="swift">// Date comparision to compare current date and end date.
var dateComparisionResult:NSComparisonResult = NSDate().compare(endDate)

if dateComparisionResult == NSComparisonResult.OrderedAscending
{
    // Current date is smaller than end date.
}
else if dateComparisionResult == NSComparisonResult.OrderedDescending
{
    // Current date is greater than end date.
}
else if dateComparisionResult == NSComparisonResult.OrderedSame
{
    // Current date and end date are same.
}</code></pre>
<h3>TimeStamp</h3>
<p>如果需要将某个TimeStamp("/Date(1427909016000-0800)”)转化为NSDate对象，那么可以使用如下的扩展工具，该扩展将会把TimeStamp转化为本地化时间。其中1427909016000表示从Unix计时以来的毫秒数，而-0800表示时区：</p>
<pre><code class="swift">extension NSDate {
    convenience init?(jsonDate: String) {
        let prefix = "/Date("
        let suffix = ")/"
        let scanner = NSScanner(string: jsonDate)
        
        // Check prefix:
        if scanner.scanString(prefix, intoString: nil) {
            
            // Read milliseconds part:
            var milliseconds : Int64 = 0
            if scanner.scanLongLong(&amp;milliseconds) {
                // Milliseconds to seconds:
                var timeStamp = NSTimeInterval(milliseconds)/1000.0
                
                // Read optional timezone part:
                var timeZoneOffset : Int = 0
                if scanner.scanInteger(&amp;timeZoneOffset) {
                    let hours = timeZoneOffset / 100
                    let minutes = timeZoneOffset % 100
                    // Adjust timestamp according to timezone:
                    timeStamp += NSTimeInterval(3600 * hours + 60 * minutes)
                }
                
                // Check suffix:
                if scanner.scanString(suffix, intoString: nil) {
                    // Success! Create NSDate and return.
                    self.init(timeIntervalSince1970: timeStamp)
                    return
                }
            }
        }
        
        // Wrong format, return nil. (The compiler requires us to
        // do an initialization first.)
        self.init(timeIntervalSince1970: 0)
        return nil
    }
}</code></pre>
<p>使用的例子如下：</p>
<pre><code class="swift">if let theDate = NSDate(jsonDate: "/Date(1427909016000-0800)/")
{
    println(theDate)
}
else
{
    println("wrong format")
}</code></pre>
<h2>NSDateFormatter：格式化时间</h2>
<pre><code class="swift">var dataString = "April 1, 2015" as String
var dateFormatter = NSDateFormatter()
dateFormatter.dateFormat = "MM-dd-yyyy"
dateFormatter.timeZone = NSTimeZone.localTimeZone()

// convert string into date
let dateValue = dateFormatter.dateFromString(dataString) as NSDate!

println(dateValue)</code></pre>
<p><img src="http://www.brianjcoleman.com/wp-content/uploads/2015/04/Sg0tZ.png" alt="" title=""></p>
<h2>NSCalendar</h2>
<pre><code class="swift">// Playground - noun: a place where people can play

import UIKit

// Setup the calendar object
let calendar = NSCalendar.currentCalendar()

// Set up date object
let date = NSDate()

// Create an NSDate for the first and last day of the month
//let components = calendar.components(NSCalendarUnit.CalendarUnitYear |
//                                     NSCalendarUnit.CalendarUnitMonth |
//                                     NSCalendarUnit.WeekdayCalendarUnit |
//                                     NSCalendarUnit.WeekCalendarUnit |
//                                     NSCalendarUnit.CalendarUnitDay,
//                                     fromDate: date)

// Create an NSDate for the first and last day of the month
let components = NSCalendar.currentCalendar().components(NSCalendarUnit.CalendarUnitMonth, fromDate: date)


components.month

// Getting the First and Last date of the month
components.day = 1
let firstDateOfMonth: NSDate = calendar.dateFromComponents(components)!

components.month  += 1
components.day     = 0
let lastDateOfMonth: NSDate = calendar.dateFromComponents(components)!

var unitFlags = NSCalendarUnit.WeekOfMonthCalendarUnit |
                NSCalendarUnit.WeekdayCalendarUnit     |
                NSCalendarUnit.CalendarUnitDay

let firstDateComponents = calendar.components(unitFlags, fromDate: firstDateOfMonth)
let lastDateComponents  = calendar.components(unitFlags, fromDate: lastDateOfMonth)

// Sun = 1, Sat = 7
let firstWeek = firstDateComponents.weekOfMonth
let lastWeek  = lastDateComponents.weekOfMonth

let numOfDatesToPrepend = firstDateComponents.weekday - 1
let numOfDatesToAppend  = 7 - lastDateComponents.weekday + (6 - lastDateComponents.weekOfMonth) * 7

let startDate: NSDate = calendar.dateByAddingUnit(NSCalendarUnit.CalendarUnitDay, value: -numOfDatesToPrepend, toDate: firstDateOfMonth, options: nil)!
let endDate:   NSDate = calendar.dateByAddingUnit(NSCalendarUnit.CalendarUnitDay, value: numOfDatesToAppend, toDate: lastDateOfMonth, options: nil)!

Array(map(0..&lt;42) {
    calendar.dateByAddingUnit(NSCalendarUnit.CalendarUnitDay, value: $0, toDate: startDate, options: nil)!
})

"\(components.year)"


var dateString = "2014-10-3" // change to your date format
var dateFormatter = NSDateFormatter()
dateFormatter.dateFormat = "YYYY-MM-dd"

var someDate = dateFormatter.dateFromString(dateString)
println(someDate)</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742865";}i:31;a:11:{s:5:"title";s:32:"[译]在 React.js 中使用 ES6+";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742747";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742747";s:7:"updated";s:25:"2015-09-13T22:48:55+08:00";s:9:"published";s:25:"2015-09-13T22:48:55+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:11:"MockingBird";s:10:"author_uri";s:38:"http://segmentfault.com/u/codingmonkey";s:2:"re";a:1:{s:4:"rank";s:1:"4";}s:7:"summary";s:7988:"
<blockquote><p>原文地址： <a href="http://babeljs.io/blog/2015/06/07/react-on-es6-plus/">http://babeljs.io/blog/2015/06/07/react-on-es6-plus/</a></p></blockquote>
<p><img src="http://7xiyp1.com1.z0.glb.clouddn.com/652b57761014ee46dc3114e22229b92f.png" alt="babel.js" title="babel.js"></p>
<p>在今年对 Instagram Web 进行全新的设计的时候，我喜欢在写 React 组件的时候，用上一些 ES6+ 的新特性。请允许我列举这些能够改变你写 React 应用方式的新特性。比起以往，这些特性能够使你撸起码来更加容易、有趣！</p>
<h2>类（Class）</h2>
<p>使用 ES6+ 来编写 React 组件最明显的变化就是我们定义组件（类）的语法的方式。我们可以用定义一个继承了 <code>React.Component</code> 的ES6 类来代替原本使用 <code>React.createClass</code> 的来创建类的方式：</p>
<pre><code class="javascript">class Photo extends React.Component {
  render() {
    return &lt;img alt={this.props.caption} src={this.props.src} /&gt;;
  }
}</code></pre>
<p>我们可以发现这种写法使得定义组件的方式变得更加简洁：</p>
<pre><code class="javascript">// The ES5 way
var Photo = React.createClass({
  handleDoubleTap: function(e) { … },
  render: function() { … },
});
// The ES6+ way
class Photo extends React.Component {
  handleDoubleTap(e) { … }
  render() { … }
}</code></pre>
<p>这样我们可以少写一对圆括号、一个分号、每个方法的冒号和 <code>function</code> 关键字。</p>
<p>所有生命周期方法都可以采用这种方式来定义。 但是 <code>componentWillMount</code> 还可以用 <code>constructor</code> 来代替：</p>
<pre><code class="javascript">// The ES5 way
var EmbedModal = React.createClass({
  componentWillMount: function() { … },
});
// The ES6+ way
class EmbedModal extends React.Component {
  constructor(props) {
    super(props);
    // Operations usually carried out in componentWillMount go here
  }
}</code></pre>
<h2>属性初始化（property initializers）</h2>
<p>在 ES6+ 类中，属性类型 <code>prop type</code> 和默认属性 <code>default prop</code> 可以通过类中的 <code>static</code> 来声明。同时，组件的初始状态（ <code>initial state</code> ）可以通过 ES7 的<a href="https://gist.github.com/jeffmo/054df782c05639da2adb">属性初始化（property initializers）</a>来完成：</p>
<pre><code class="javascript">// The ES5 way
var Video = React.createClass({
  getDefaultProps: function() {
    return {
      autoPlay: false,
      maxLoops: 10,
    };
  },
  getInitialState: function() {
    return {
      loopsRemaining: this.props.maxLoops,
    };
  },
  propTypes: {
    autoPlay: React.PropTypes.bool.isRequired,
    maxLoops: React.PropTypes.number.isRequired,
    posterFrameSrc: React.PropTypes.string.isRequired,
    videoSrc: React.PropTypes.string.isRequired,
  },
});
// The ES6+ way
class Video extends React.Component {
  static defaultProps = {
    autoPlay: false,
    maxLoops: 10,
  }
  static propTypes = {
    autoPlay: React.PropTypes.bool.isRequired,
    maxLoops: React.PropTypes.number.isRequired,
    posterFrameSrc: React.PropTypes.string.isRequired,
    videoSrc: React.PropTypes.string.isRequired,
  }
  state = {
    loopsRemaining: this.props.maxLoops,
  }
}</code></pre>
<p>ES7 中在构造函数（ <code>constructor</code> ）下的属性初始化操作中的 <code>this</code> 指向的是类的实例，所以初始状态（ <code>initial state</code> ）可以通过 <code>this.prop</code> （即传入的参数）来设定。</p>
<h2>箭头函数（Arrow function）</h2>
<p><code>React.createClass</code> 方法在你的组件上做了一些额外的绑定工作，以确保在组件实实例的方法内部， <code>this</code> 指向的是组件实例自身。</p>
<pre><code class="javascript">// Autobinding, brought to you by React.createClass
var PostInfo = React.createClass({
  handleOptionsButtonClick: function(e) {
    // Here, 'this' refers to the component instance.
    this.setState({showOptionsModal: true});
  },
});</code></pre>
<p>由于我们使用 ES6+ 的语法定义类的时候没有采用 <code>React.createClass</code> 的方式，所以，这样看来我们不得不手动来绑定这些方法中 <code>this</code> 的指向：</p>
<pre><code class="javascript">// Manually bind, wherever you need to
class PostInfo extends React.Component {
  constructor(props) {
    super(props);
    // Manually bind this method to the component instance...
    this.handleOptionsButtonClick = this.handleOptionsButtonClick.bind(this);
  }
  handleOptionsButtonClick(e) {
    // ...to ensure that 'this' refers to the component instance here.
    this.setState({showOptionsModal: true});
  }
}</code></pre>
<p>幸运的是，通过 ES6+ 的箭头函数（ Arrow functions ）和属性初始化（ property initializers ）这两个特性使得把函数的 <code>this</code> 指向绑定为组件的实例变得非常的简单：</p>
<pre><code class="javascript">class PostInfo extends React.Component {
  handleOptionsButtonClick = (e) =&gt; {
    this.setState({showOptionsModal: true});
  }
}</code></pre>
<p>函数体内的 <code>this</code> 对象，绑定定义时所在的对象，而不是使用时所在的对象。而恰好属性初始化（ property initializers ）刚好在这个作用域内。</p>
<h2>动态属性名 &amp; 字符串模板</h2>
<p>在 ES6+ 中对 <em>对象字面量的扩展</em> 使得我们可以在对象字面量中使用表达式来对属性命名。如果是在 ES5 中，我们也许只能这样做：</p>
<pre><code class="javascript">var Form = React.createClass({
  onChange: function(inputName, e) {
    var stateToSet = {};
    stateToSet[inputName + 'Value'] = e.target.value;
    this.setState(stateToSet);
  },
});</code></pre>
<p>但是，在 ES6+ 中，我们不仅可以在对象字面量属性的定义中使用表达式，还有使用使用 <em>字符串模板</em> ：</p>
<pre><code class="javascript">class Form extends React.Component {
  onChange(inputName, e) {
    this.setState({
      [`${inputName}Value`]: e.target.value,
    });
  }
}</code></pre>
<h2>析构 &amp; 扩展运算符</h2>
<p>我们在编写组件的过程中，经常遇到要从父组件要把自己的很多属性多传给子组件的情况。有了 ES6+ 的 <em>析构</em> 和 <em>扩展运算符</em> 特性，这变得非常的方便：</p>
<pre><code class="javascript">class AutoloadingPostsGrid extends React.Component {
  render() {
    var {
      className,
      ...others,  // contains all properties of this.props except for className
    } = this.props;
    return (
      &lt;div className={className}&gt;
        &lt;PostsGrid {...others} /&gt;
        &lt;button onClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>我们可以把 <em>扩展运算符</em> 属性和普通的属性结合起来使用，这样使得我们可以利用优先级来使用属性的默认值和属性的覆盖。下面这个元素会获得一个 <code>override</code> 的类（ <code>class</code> ），及时 <code>this.props</code> 中有传递 <code>className</code> 属性。</p>
<pre><code class="javascript">&lt;div {...this.props} className="override"&gt;
  …
&lt;/div&gt;</code></pre>
<p>下面这种写法，可以给元素设定默认的 <code>className</code>：</p>
<pre><code class="javascript">&lt;div className="base" {...this.props}&gt;
  …
&lt;/div&gt;</code></pre>
<h2>最后</h2>
<p>我希望你能够享受 ES6+ 的这些特性给你在编写 React.js 中带来的好处。感谢我的同事他们为这篇文章作出的贡献，还有，特别的感谢 Babel 团队，使得我们可以随意的使用这些特性。</p>
<blockquote><p>文章地址：<a href="http://blog.mcbird.cn/2015/09/11/react-on-es6-plus/">http://blog.mcbird.cn/2015/09/11/react-on-es6-plus/</a></p></blockquote>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742747";}i:32;a:11:{s:5:"title";s:76:"MySQL in 查询，并通过 FIELD 函数按照查询条件顺序返回结果";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742537";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742537";s:7:"updated";s:25:"2015-09-13T21:39:45+08:00";s:9:"published";s:25:"2015-09-13T21:39:45+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:8:"Martin91";s:10:"author_uri";s:34:"http://segmentfault.com/u/martin91";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:5701:"
<h3>从示例讲起</h3>
<p>我们都非常习惯通过 MySQL 的 <a href="https://dev.mysql.com/doc/refman/5.0/en/comparison-operators.html#function_in">IN 函数</a>来查询特定集合的数据，比如为了在 books 表中找出李雷、韩梅梅和安华写的书，我们可以有如下的 SQL：</p>
<pre><code class="sql">SELECT * FROM books WHERE `books`.`author` IN ('李雷','韩梅梅','安华');</code></pre>
<p><strong>注意:</strong> 可以通过 <a href="http://sqlfiddle.com/#!9/1982d">SQL Fiddle</a> 查看以上示例。</p>
<p>数据库返回如下结果：</p>
<table>
<thead><tr>
<th>author</th>
<th>title</th>
</tr></thead>
<tbody>
<tr>
<td>安华</td>
<td>暴走漫画</td>
</tr>
<tr>
<td>李雷</td>
<td>蓝色生死恋</td>
</tr>
<tr>
<td>韩梅梅</td>
<td>冰与火之歌</td>
</tr>
<tr>
<td>韩梅梅</td>
<td>天国的阶梯</td>
</tr>
<tr>
<td>李雷</td>
<td>这个杀手不太冷</td>
</tr>
<tr>
<td>韩梅梅</td>
<td>阿甘正传</td>
</tr>
</tbody>
</table>
<p>虽然这样确实能够返回所有李雷、韩梅梅和安华写过的书，但是返回的数据的排序方式是默认按照数据在数据库中的存储顺序，假如我们需要的返回结果是同时按照 IN 查询条件里边的参数顺序来排序呢？这个时候我们就需要利用到 MySQL <a href="https://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_field">FIELD</a> 这个函数了，FIELD 函数本来是 MySQL 提供用来查询某一个字符串在给定字符串元组中的索引位置的，比如这个官方例子：</p>
<pre><code class="sql">SELECT FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo'); # -&gt; 2</code></pre>
<p>如果将其应用在 <a href="http://dev.mysql.com/doc/internals/en/optimizer-order-by-clauses.html"><code>ORDER BY</code></a> 排序条件中，就可以根据指定字段的值在给定参数列表中的索引数值，进而将查询结果按照参数列表排序了：</p>
<pre><code>SELECT * FROM books WHERE `books`.`author` IN ('李雷','韩梅梅','安华') ORDER BY FIELD(author, '李雷','韩梅梅','安华');</code></pre>
<p><strong>注意：</strong> 可以通过<a href="http://sqlfiddle.com/#!9/46ccc/5">SQL Fiddle</a>查看以上示例。</p>
<p>这一次，返回的结果则是：</p>
<table>
<thead><tr>
<th>author</th>
<th>title</th>
</tr></thead>
<tbody>
<tr>
<td>李雷</td>
<td>蓝色生死恋</td>
</tr>
<tr>
<td>李雷</td>
<td>这个杀手不太冷</td>
</tr>
<tr>
<td>韩梅梅</td>
<td>冰与火之歌</td>
</tr>
<tr>
<td>韩梅梅</td>
<td>天国的阶梯</td>
</tr>
<tr>
<td>韩梅梅</td>
<td>阿甘正传</td>
</tr>
<tr>
<td>安华</td>
<td>暴走漫画</td>
</tr>
</tbody>
</table>
<p>可以发现，这一次，我们得到的结果就是按照条件参数列表 <code>'李雷','韩梅梅','安华'</code> 进行排序后得到了。</p>
<h3>应用层面的思考</h3>
<h4>1. 兼容性</h4>
<p>本文提到的 <code>FIELD</code> 函数，毕竟只是 MySQL 数据库内置提供的一种函数，除非你非常明确你的项目就是只用 MySQL 数据库，否则，你的 SQL 代码在未来迁移到其他数据库的过程中就会遇到语法兼容性问题（只是 PostgreSQL 数据库不支持 FIELD）。</p>
<h4>2. 性能问题</h4>
<p>我们都知道，数据库在进行 <code>ORDER BY</code> 排序的时候，除非它是按照某个已经存在索引的键的值进行排序，否则数据库则需要通过计算 <code>ORDER BY</code> 中表达式的值并且按照查询结果建立新的临时表，这个过程会带来额外的时间开销跟内存开销，对数据库本身就是一种性能负担。这样的方式在单一数据库多个数据库客户端连接的时候，可能对数据库造成太大负担。</p>
<h4>3. 与应用层代码的结合</h4>
<p>尽管使用 <code>FIELD</code> 函数可能带来兼容性以及性能方面的隐患，但是 <code>FIELD</code> 的使用并非全是有损之处。</p>
<p>比如在与 Ruby 的 active_record 结合时，这种通过数据库直接完成排序等 SQL 语句可以方便我们构建 ActiveRecord::Relation 对象，因为我们不再需要先将查询结果集从内存中转为数组排序，再进行二次查询，可以帮助我们减少 <a href="https://secure.phabricator.com/book/phabcontrib/article/n_plus_one/">N+1 查询问题</a>，后者也是常见的影响数据库服务器性能的现象之一。除此之外，这样的写法也可以有效地帮助我们简化代码，保持代码简洁。</p>
<p>但是在不需要对数据进行二次查询或者查询数据量太大的情况下，我反而建议可以通过 Ruby 的 <code>Array#sort_by</code> 方法对数据进行排序，这样的话，排序的任务就转移给了客户端代码，排序任务的压力就自然分散，减轻了服务器端的压力。</p>
<h3>总结</h3>
<ol>
<li><p>FIELD 函数结合 ORDER BY 可以帮助我们将查询结果集按照参数列表顺序返回；</p></li>
<li><p>FIELD 函数结合 ORDER BY 的方式可以帮助我们在数据库层面完成排序，简化了业务代码逻辑；</p></li>
<li><p>FIELD 函数结合 ORDER BY 可能带来 SQL 兼容性以及性能方面的问题；</p></li>
<li><p>在确认项目数据库不大可能为 MySQL<br> 之外的数据库的前提下，查询数据量少或者需要保持业务代码简洁的场景下，我建议可以采用 FIELD 函数排序；而在数据量庞大的情况下，或者不大可能出现大量 N+1 查询的情况下，我建议可以采用先在数据库中查询数据集（只查询 IN 条件，不排序）再到内存中通过业务代码排序(比如 Ruby 的 <code>Array#sort_by</code>)的方式。</p></li>
</ol>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742537";}i:33;a:11:{s:5:"title";s:35:"Python-OpenCV 图像与视频处理";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742481";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742481";s:7:"updated";s:25:"2015-09-13T21:16:30+08:00";s:9:"published";s:25:"2015-09-13T21:16:30+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"Tairy";s:10:"author_uri";s:31:"http://segmentfault.com/u/tairy";s:2:"re";a:1:{s:4:"rank";s:1:"3";}s:7:"summary";s:1364:"
<p>一直断断续续的用过几次 OpenCV，感觉熟练掌握它的使用方法已经变的非常必要了，正好找到一个很不错的英文教程，就以此为起点，详细记录一下对 OpenCV 的学习过程吧。</p>
<h3>目录</h3>
<h4>准备工作</h4>
<ul><li><p><a href="http://segmentfault.com/a/1190000003742411">安装Python OpenCV</a></p></li></ul>
<h4>图像处理</h4>
<ul>
<li><p><a href="http://segmentfault.com/a/1190000003742422">第一节：图像基本操作</a></p></li>
<li><p><a href="http://segmentfault.com/a/1190000003742433">第二节：滤镜和图像运算</a></p></li>
<li><p><a href="http://segmentfault.com/a/1190000003742442">第三节：图像像素点操作</a></p></li>
<li><p><a href="http://segmentfault.com/a/1190000003742455">第四节：图像直方图和反向投影</a></p></li>
<li><p><a href="http://segmentfault.com/a/1190000003742461">第五节：图像中边界和轮廓检测</a></p></li>
<li><p><a>第六节：对象检测</a></p></li>
</ul>
<h4>视频处理</h4>
<ul>
<li><p><a>第一节：视频的输入输出</a></p></li>
<li><p><a>第二节：视频处理</a></p></li>
<li><p><a>第三节：标记运动轨迹</a></p></li>
<li><p><a>第四节：动作检测</a></p></li>
</ul>
<h3>参考资料</h3>
<ul><li><p><a href="http://www.robindavid.fr/opencv-tutorial/">OpenCV Tutorial</a></p></li></ul>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742481";}i:34;a:11:{s:5:"title";s:68:"Python-OpenCV 处理图像（五）：图像中边界和轮廓检测";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742461";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742461";s:7:"updated";s:25:"2015-09-13T21:13:14+08:00";s:9:"published";s:25:"2015-09-13T21:13:14+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"Tairy";s:10:"author_uri";s:31:"http://segmentfault.com/u/tairy";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:9676:"
<blockquote><p><a href="http://segmentfault.com/a/1190000003742481">系列文章目录</a></p></blockquote>
<p>关于边缘检测的基础来自于一个事实，即在边缘部分，像素值出现”跳跃“或者较大的变化。如果在此边缘部分求取一阶导数，就会看到极值的出现。</p>
<p>而在一阶导数为极值的地方，二阶导数为0，基于这个原理，就可以进行边缘检测。</p>
<p>关于 Laplace 算法原理，可参考</p>
<ul><li><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/laplace_operator/laplace_operator.html?highlight=laplace">Laplace 算子</a></p></li></ul>
<h3>0x01. Laplace 算法</h3>
<p>下面的代码展示了分别对灰度化的图像和原始彩色图像中的边缘进行检测：</p>
<pre><code class="python">import cv2.cv as cv

im=cv.LoadImage('img/building.png', cv.CV_LOAD_IMAGE_COLOR)

# Laplace on a gray scale picture
gray = cv.CreateImage(cv.GetSize(im), 8, 1)
cv.CvtColor(im, gray, cv.CV_BGR2GRAY)

aperture=3

dst = cv.CreateImage(cv.GetSize(gray), cv.IPL_DEPTH_32F, 1)
cv.Laplace(gray, dst,aperture)

cv.Convert(dst,gray)

thresholded = cv.CloneImage(im)
cv.Threshold(im, thresholded, 50, 255, cv.CV_THRESH_BINARY_INV)

cv.ShowImage('Laplaced grayscale',gray)
#------------------------------------

# Laplace on color
planes = [cv.CreateImage(cv.GetSize(im), 8, 1) for i in range(3)]
laplace = cv.CreateImage(cv.GetSize(im), cv.IPL_DEPTH_16S, 1)
colorlaplace = cv.CreateImage(cv.GetSize(im), 8, 3)

cv.Split(im, planes[0], planes[1], planes[2], None) #Split channels to apply laplace on each
for plane in planes:
    cv.Laplace(plane, laplace, 3)
    cv.ConvertScaleAbs(laplace, plane, 1, 0)

cv.Merge(planes[0], planes[1], planes[2], None, colorlaplace)

cv.ShowImage('Laplace Color', colorlaplace)
#-------------------------------------

cv.WaitKey(0)</code></pre>
<p>效果展示</p>
<p>原图</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/9631b1bbgw1ew0sb82sv5j20dw0adgnk.jpg" alt="原图" title="原图"></p>
<p>灰度化图片检测</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/9631b1bbgw1ew0sba88kkj20y00s6n5g.jpg" alt="灰度化图片检测" title="灰度化图片检测"></p>
<p>原始彩色图片检测</p>
<p><img src="http://ww2.sinaimg.cn/mw1024/9631b1bbgw1ew0sbe1cxkj20y00s6qgj.jpg" alt="" title=""></p>
<h3>0x02. Sobel 算法</h3>
<p>Sobel 也是很常用的一种轮廓识别的算法。</p>
<p>关于 Sobel 导数原理的介绍，可参考</p>
<ul><li><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/sobel_derivatives/sobel_derivatives.html?highlight=sobel">Sobel 导数</a></p></li></ul>
<p>以下是使用 Sobel 算法进行轮廓检测的代码和效果</p>
<pre><code class="python">import cv2.cv as cv

im=cv.LoadImage('img/building.png', cv.CV_LOAD_IMAGE_GRAYSCALE)

sobx = cv.CreateImage(cv.GetSize(im), cv.IPL_DEPTH_16S, 1)
cv.Sobel(im, sobx, 1, 0, 3) #Sobel with x-order=1

soby = cv.CreateImage(cv.GetSize(im), cv.IPL_DEPTH_16S, 1)
cv.Sobel(im, soby, 0, 1, 3) #Sobel withy-oder=1

cv.Abs(sobx, sobx)
cv.Abs(soby, soby)

result = cv.CloneImage(im)
cv.Add(sobx, soby, result) #Add the two results together.

cv.Threshold(result, result, 100, 255, cv.CV_THRESH_BINARY_INV)

cv.ShowImage('Image', im)
cv.ShowImage('Result', result)

cv.WaitKey(0)</code></pre>
<p>处理之后效果图（感觉比Laplace效果要好些）</p>
<p><img src="http://ww2.sinaimg.cn/mw1024/9631b1bbgw1ew0sj21zwpj20y00s6grr.jpg" alt="" title=""></p>
<h3>0x03. cv.MorphologyEx</h3>
<p>cv.MorphologyEx 是另外一种边缘检测的算法</p>
<pre><code class="python">import cv2.cv as cv

image=cv.LoadImage('img/build.png', cv.CV_LOAD_IMAGE_GRAYSCALE)

#Get edges
morphed = cv.CloneImage(image)
cv.MorphologyEx(image, morphed, None, None, cv.CV_MOP_GRADIENT) # Apply a dilate - Erode

cv.Threshold(morphed, morphed, 30, 255, cv.CV_THRESH_BINARY_INV)

cv.ShowImage("Image", image)
cv.ShowImage("Morphed", morphed)

cv.WaitKey(0)</code></pre>
<p><img src="http://ww1.sinaimg.cn/mw1024/9631b1bbgw1ew0sopwrrdj20y00s6dl7.jpg" alt="" title=""></p>
<h3>0x04. Canny 边缘检测</h3>
<p>Canny 算法可以对直线边界做出很好的检测；</p>
<p>关于 Canny 算法原理的描述，可参考：</p>
<ul><li><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html?highlight=canny#canny">Canny 边缘检测</a></p></li></ul>
<pre><code class="python">import cv2.cv as cv
import math

im=cv.LoadImage('img/road.png', cv.CV_LOAD_IMAGE_GRAYSCALE)

pi = math.pi #Pi value

dst = cv.CreateImage(cv.GetSize(im), 8, 1)

cv.Canny(im, dst, 200, 200)
cv.Threshold(dst, dst, 100, 255, cv.CV_THRESH_BINARY)

#---- Standard ----
color_dst_standard = cv.CreateImage(cv.GetSize(im), 8, 3)
cv.CvtColor(im, color_dst_standard, cv.CV_GRAY2BGR)#Create output image in RGB to put red lines

lines = cv.HoughLines2(dst, cv.CreateMemStorage(0), cv.CV_HOUGH_STANDARD, 1, pi / 180, 100, 0, 0)
for (rho, theta) in lines[:100]:
    a = math.cos(theta) #Calculate orientation in order to print them
    b = math.sin(theta)
    x0 = a * rho
    y0 = b * rho
    pt1 = (cv.Round(x0 + 1000*(-b)), cv.Round(y0 + 1000*(a)))
    pt2 = (cv.Round(x0 - 1000*(-b)), cv.Round(y0 - 1000*(a)))
    cv.Line(color_dst_standard, pt1, pt2, cv.CV_RGB(255, 0, 0), 2, 4) #Draw the line

#---- Probabilistic ----
color_dst_proba = cv.CreateImage(cv.GetSize(im), 8, 3)
cv.CvtColor(im, color_dst_proba, cv.CV_GRAY2BGR) # idem

rho=1
theta=pi/180
thresh = 50
minLength= 120 # Values can be changed approximately to fit your image edges
maxGap= 20

lines = cv.HoughLines2(dst, cv.CreateMemStorage(0), cv.CV_HOUGH_PROBABILISTIC, rho, theta, thresh, minLength, maxGap)
for line in lines:
    cv.Line(color_dst_proba, line[0], line[1], cv.CV_RGB(255, 0, 0), 2, 8)

cv.ShowImage('Image',im)
cv.ShowImage("Cannied", dst)
cv.ShowImage("Hough Standard", color_dst_standard)
cv.ShowImage("Hough Probabilistic", color_dst_proba)
cv.WaitKey(0)</code></pre>
<p>原图</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/9631b1bbgw1ew0sweuzlxj20di09nwfx.jpg" alt="" title=""></p>
<p>使用 Canny 算法处理之后</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/9631b1bbgw1ew0swfnjrgj20x80qqtcz.jpg" alt="" title=""></p>
<p>标记出标准的直线</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/9631b1bbgw1ew0swhnad5j20x80qq7ap.jpg" alt="" title=""></p>
<p>标记出所有可能的直线</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/9631b1bbgw1ew0swj5xbuj20x80qqgrv.jpg" alt="" title=""></p>
<h3>0x05. 轮廓检测</h3>
<p>OpenCV 提供一个 FindContours 函数可以用来检测出图像中对象的轮廓：</p>
<pre><code class="python">import cv2.cv as cv

orig = cv.LoadImage('img/build.png', cv.CV_LOAD_IMAGE_COLOR)
im = cv.CreateImage(cv.GetSize(orig), 8, 1)
cv.CvtColor(orig, im, cv.CV_BGR2GRAY)
#Keep the original in colour to draw contours in the end

cv.Threshold(im, im, 128, 255, cv.CV_THRESH_BINARY)
cv.ShowImage("Threshold 1", im)

element = cv.CreateStructuringElementEx(5*2+1, 5*2+1, 5, 5, cv.CV_SHAPE_RECT)

cv.MorphologyEx(im, im, None, element, cv.CV_MOP_OPEN) #Open and close to make appear contours
cv.MorphologyEx(im, im, None, element, cv.CV_MOP_CLOSE)
cv.Threshold(im, im, 128, 255, cv.CV_THRESH_BINARY_INV)
cv.ShowImage("After MorphologyEx", im)
# --------------------------------

vals = cv.CloneImage(im) #Make a clone because FindContours can modify the image
contours=cv.FindContours(vals, cv.CreateMemStorage(0), cv.CV_RETR_LIST, cv.CV_CHAIN_APPROX_SIMPLE, (0,0))

_red = (0, 0, 255); #Red for external contours
_green = (0, 255, 0);# Gren internal contours
levels=2 #1 contours drawn, 2 internal contours as well, 3 ...
cv.DrawContours (orig, contours, _red, _green, levels, 2, cv.CV_FILLED) #Draw contours on the colour image

cv.ShowImage("Image", orig)
cv.WaitKey(0)</code></pre>
<p>效果图：</p>
<p>原图</p>
<p><img src="http://ww2.sinaimg.cn/mw1024/9631b1bbgw1ew13euny9mj20dw0adgnk.jpg" alt="" title=""></p>
<p>识别结果</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/9631b1bbgw1ew13emfp9vj20dx0afabu.jpg" alt="" title=""></p>
<h3>0x06. 边界检测</h3>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/build.png", cv.CV_LOAD_IMAGE_GRAYSCALE)

dst_32f = cv.CreateImage(cv.GetSize(im), cv.IPL_DEPTH_32F, 1)

neighbourhood = 3
aperture = 3
k = 0.01
maxStrength = 0.0
threshold = 0.01
nonMaxSize = 3

cv.CornerHarris(im, dst_32f, neighbourhood, aperture, k)

minv, maxv, minl, maxl = cv.MinMaxLoc(dst_32f)

dilated = cv.CloneImage(dst_32f)
cv.Dilate(dst_32f, dilated) # By this way we are sure that pixel with local max value will not be changed, and all the others will

localMax = cv.CreateMat(dst_32f.height, dst_32f.width, cv.CV_8U)
cv.Cmp(dst_32f, dilated, localMax, cv.CV_CMP_EQ) #compare allow to keep only non modified pixel which are local maximum values which are corners.

threshold = 0.01 * maxv
cv.Threshold(dst_32f, dst_32f, threshold, 255, cv.CV_THRESH_BINARY)

cornerMap = cv.CreateMat(dst_32f.height, dst_32f.width, cv.CV_8U)
cv.Convert(dst_32f, cornerMap) #Convert to make the and
cv.And(cornerMap, localMax, cornerMap) #Delete all modified pixels

radius = 3
thickness = 2

l = []
for x in range(cornerMap.height): #Create the list of point take all pixel that are not 0 (so not black)
    for y in range(cornerMap.width):
        if cornerMap[x,y]:
            l.append((y,x))

for center in l:
    cv.Circle(im, center, radius, (255,255,255), thickness)


cv.ShowImage("Image", im)
cv.ShowImage("CornerHarris Result", dst_32f)
cv.ShowImage("Unique Points after Dilatation/CMP/And", cornerMap)

cv.WaitKey(0)</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742461";}i:35;a:11:{s:5:"title";s:68:"Python-OpenCV 处理图像（四）：图像直方图和反向投影";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742455";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742455";s:7:"updated";s:25:"2015-09-13T21:11:44+08:00";s:9:"published";s:25:"2015-09-13T21:11:44+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"Tairy";s:10:"author_uri";s:31:"http://segmentfault.com/u/tairy";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:3067:"
<blockquote><p><a href="http://segmentfault.com/a/1190000003742481">系列文章目录</a></p></blockquote>
<p>当我们想比较两张图片相似度的时候，可以使用这一节提到的技术</p>
<ul>
<li><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/histogram_comparison/histogram_comparison.html?highlight=%E7%9B%B4%E6%96%B9%E5%9B%BE">直方图对比</a></p></li>
<li><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/back_projection/back_projection.html">反向投影</a></p></li>
</ul>
<p>关于这两种技术的原理可以参考我上面贴的链接，下面是示例的代码：</p>
<h3>0x01. 绘制直方图</h3>
<pre><code class="python">import cv2.cv as cv

def drawGraph(ar,im, size): #Draw the histogram on the image
    minV, maxV, minloc, maxloc = cv.MinMaxLoc(ar) #Get the min and max value
    hpt = 0.9 * histsize
    for i in range(size):
        intensity = ar[i] * hpt / maxV #Calculate the intensity to make enter in the image
        cv.Line(im, (i,size), (i,int(size-intensity)),cv.Scalar(255,255,255)) #Draw the line
        i += 1

#---- Gray image
orig = cv.LoadImage("img/lena.jpg", cv.CV_8U)

histsize = 256 #Because we are working on grayscale pictures which values within 0-255

hist = cv.CreateHist([histsize], cv.CV_HIST_ARRAY, [[0,histsize]], 1)

cv.CalcHist([orig], hist) #Calculate histogram for the given grayscale picture

histImg = cv.CreateMat(histsize, histsize, cv.CV_8U) #Image that will contain the graph of the repartition of values
drawGraph(hist.bins, histImg, histsize)

cv.ShowImage("Original Image", orig)
cv.ShowImage("Original Histogram", histImg)
#---------------------

#---- Equalized image
imEq = cv.CloneImage(orig)
cv.EqualizeHist(imEq, imEq) #Equlize the original image

histEq = cv.CreateHist([histsize], cv.CV_HIST_ARRAY, [[0,histsize]], 1)
cv.CalcHist([imEq], histEq) #Calculate histogram for the given grayscale picture
eqImg = cv.CreateMat(histsize, histsize, cv.CV_8U) #Image that will contain the graph of the repartition of values
drawGraph(histEq.bins, eqImg, histsize)

cv.ShowImage("Image Equalized", imEq)
cv.ShowImage("Equalized HIstogram", eqImg)
#--------------------------------

cv.WaitKey(0)</code></pre>
<h3>0x02. 反向投影</h3>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/lena.jpg", cv.CV_8U)

cv.SetImageROI(im, (1, 1,30,30))

histsize = 256 #Because we are working on grayscale pictures
hist = cv.CreateHist([histsize], cv.CV_HIST_ARRAY, [[0,histsize]], 1)
cv.CalcHist([im], hist)


cv.NormalizeHist(hist,1) # The factor rescale values by multiplying values by the factor
_,max_value,_,_ = cv.GetMinMaxHistValue(hist)

if max_value == 0:
    max_value = 1.0
cv.NormalizeHist(hist,256/max_value)

cv.ResetImageROI(im)

res = cv.CreateMat(im.height, im.width, cv.CV_8U)
cv.CalcBackProject([im], res, hist)

cv.Rectangle(im, (1,1), (30,30), (0,0,255), 2, cv.CV_FILLED)
cv.ShowImage("Original Image", im)
cv.ShowImage("BackProjected", res)
cv.WaitKey(0)</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742455";}i:36;a:11:{s:5:"title";s:44:"yii2-按需加载并管理CSS样式/JS脚本";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742452";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742452";s:7:"updated";s:25:"2015-09-13T21:11:41+08:00";s:9:"published";s:25:"2015-09-13T21:11:41+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:8:"maclechn";s:10:"author_uri";s:35:"http://segmentfault.com/u/maclechan";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4900:"
<p>(注：以下为Yii2.0高级；注意代码中php标签自己补上)</p>
<h2>一、资源包定义</h2>
<p>Yii2对于CSS/JS 管理，使用AssetBundle资源包类。<br>创建如下：<br>backend/assets/AppAsset.php</p>
<pre><code class="php">namespace backend\assets;  
  
use yii\web\AssetBundle;  
  
/** 
 * @author chan &lt;maclechan@qq.com&gt; 
 * @since 2.0 
 */  
class AppAsset extends AssetBundle  
{  
    public $basePath = '@webroot';  
    public $baseUrl = '@web';  
    //全局CSS  
    public $css = [  
        'css/animate.css',  
        'css/style.min.css',  
    ];  
//全局JS  
public $js = [  
    'js/jquery-2.1.1.js'  
]; 
    //依赖关系  
    public $depends = [  
        'yii\web\YiiAsset',  
        'yii\bootstrap\BootstrapAsset',  
    ];  
  
     //定义按需加载JS方法，注意加载顺序在最后  
    public static function addScript($view, $jsfile) {  
        $view-&gt;registerJsFile($jsfile, [AppAsset::className(), 'depends' =&gt; 'backend\assets\AppAsset']);  
    }  
      
   //定义按需加载css方法，注意加载顺序在最后  
    public static function addCss($view, $cssfile) {  
        $view-&gt;registerCssFile($cssfile, [AppAsset::className(), 'depends' =&gt; 'backend\assets\AppAsset']);  
    }  
 }</code></pre>
<h2>二、视图使用：</h2>
<h3>1. 视图（或布局）使用全局CSS/JS</h3>
<pre><code class="php">use yii\helpers\Html;  
use backend\assets\AppAsset;  
use backend\widgets\Alert;  
  
/* @var $this \yii\web\View */  
/* @var $content string */  
  
AppAsset::register($this); </code></pre>
<p>查看源文件，看清CSS和JS的加载顺序 <br><img src="/img/bVpRJj" alt="图片描述" title="图片描述"></p>
<p>可以看出以此顺序为：依赖关系 -&gt; 自定义全局CSS/JS<br>如果，某个视图需要单独引入一个CSS/JS，并且，在页面中还要写些CSS/JS，该如何做？</p>
<h3>2. 在页面中单独写样式</h3>
<pre><code class="php">$cssString = ".gray-bg{color:red;}";  
$this-&gt;registerCss($cssString); </code></pre>
<h3>3. 在页面中单独写JS(使用数据块)</h3>
<pre><code class="php">&lt;div id="mybutton"&gt;点我弹出OK&lt;/div&gt;  
  
&lt;?php $this-&gt;beginBlock('test') ?&gt;  
    $(function($) {  
      $('#mybutton').click(function() {  
        alert('OK');  
      });  
    });  
&lt;?php $this-&gt;endBlock() ?&gt;  
&lt;?php $this-&gt;registerJs($this-&gt;blocks['test'], \yii\web\View::POS_END); ?&gt;  </code></pre>
<p>或者：</p>
<pre><code>&lt;?php
$this-&gt;registerJs(
   '$("document").ready(function(){ 
        $("#login-form").validate({
            errorElement : "small", 
            errorClass : "error",
            rules: {
                     "AgNav[nav_cn]": {
                         required: true,
                     },
            },
            messages:{
                   "AgNav[nav_cn]" : {  
                        required : "此字段不能为空.",
                    },
            }
        });
    });'
);
?&gt;</code></pre>
<h3>4.视图中引入CSS/JS文件</h3>
<p>然后再说下在视图中如何引入一个CSS/JS文件（不是定义在全局里的CSS或JS）<br>分别有两种方法：</p>
<ul><li><p>方法1<br>在资源包管理器里面定义一个方法，然后在视图中注册即可(推荐使用这种)<br>如上面代码己定义：</p></li></ul>
<pre><code class="php">//定义按需加载JS方法，注意加载顺序在最后  
public static function addScript($view, $jsfile) {  
    $view-&gt;registerJsFile($jsfile, [AppAsset::className(), 'depends' =&gt; 'backend\assets\AppAsset']);  
} </code></pre>
<p>视图中使用如下</p>
<pre><code class="php">AppAsset::register($this);  
//只在该视图中使用非全局的jui   
AppAsset::addScript($this,'@web/js/jquery-ui.custom.min.js');  
//AppAsset::addCss($this,'@web/css/font-awesome/css/font-awesome.min.css');  </code></pre>
<p>查看下源码，特别的注意下，加载的顺序，是我们想要的结果 <br><img src="/img/bVpRJR" alt="图片描述" title="图片描述"></p>
<p>此外注意：在上面的addScript方法中，如果没有 ’depends‘=&gt;’xxx‘ ,此处加载的顺序将会颠倒。</p>
<ul><li><p>方法2<br>不需要在资源包管理器中定义方法，只要在视图页面直接引入即可</p></li></ul>
<pre><code class="php">AppAsset::register($this);  
//css定义一样  
$this-&gt;registerCssFile('@web/css/font-awesome.min.css',['depends'=&gt;['backend\assets\AppAsset']]);  
  
 $this-&gt;registerJsFile('@web/js/jquery-ui.custom.min.js',['depends'=&gt;['backend\assets\AppAsset']]);  
//如下position是让定义CSS/JS出现的位置
//$this-&gt;registerJsFile('@web/js/jquery-ui.custom.min.js',['depends'=&gt;['backend\assets\AppAsset'],'position'=&gt;$this::POS_HEAD]);  </code></pre>
<p><img src="/img/bVpRKh" alt="图片描述" title="图片描述"></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742452";}i:37;a:11:{s:5:"title";s:59:"Python-OpenCV 处理图像（三）：图像像素点操作";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742442";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742442";s:7:"updated";s:25:"2015-09-13T21:10:20+08:00";s:9:"published";s:25:"2015-09-13T21:10:20+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"Tairy";s:10:"author_uri";s:31:"http://segmentfault.com/u/tairy";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:2228:"
<blockquote><p><a href="http://segmentfault.com/a/1190000003742481">系列文章目录</a></p></blockquote>
<h3>0x01. 像素</h3>
<p>有两种直接操作图片像素点的方法：</p>
<p>第一种办法就是将一张图片看成一个多维的list，例如对于一张图片im，想要操作第四行第四列的像素点就直接 im[3,3] 就可以获取到这个点的RGB值。</p>
<p>第二种就是使用 OpenCV 提供的 Get1D、 Get2D 等函数。</p>
<p>推荐使用第一种办法吧，毕竟简单。</p>
<h3>0x02. 获取行和列像素</h3>
<p>有一下四个函数：</p>
<ul>
<li><p>cv.GetCol(im, 0): 返回第一列的像素</p></li>
<li><p>cv GetCols(im, 0, 10): 返回前 10 列</p></li>
<li><p>cv.GetRow(im, 0): 返回第一行</p></li>
<li><p>cv.GetRows(im, 0, 10): 返回前 10 行</p></li>
</ul>
<h3>0x03. 批量处理</h3>
<p>需要批量处理所有的像素点的时候，只需要使用for循环迭代处理就可以了：</p>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/lena.jpg")

for i in range(im.height):
    for j in range(im.width):
        im[i,j] # 这里可以处理每个像素点</code></pre>
<p>还有一种迭代处理的方式是使用 LineIterator，不过在声明 LineIterator 的时候需要制定处理像素点的开始点和结束点。</p>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/lena.jpg")

li = cv.InitLineIterator(im, (0, 0), (im.rows, im.cols)) #So loop the entire matrix

for (r, g, b) in li:
    # 这里可以对每个像素点的 r g b 进行处理</code></pre>
<p>娱乐一下， 随机获取 5000 个像素点，然后把颜色换成一个随机的值(salt)：</p>
<pre><code class="python">import cv2.cv as cv

import random

# 这里也可以使用 Get2D/Set2D 来加载图片
im = cv.LoadImage("img/lena.jpg") 

for k in range(5000): #Create 5000 noisy pixels
    i = random.randint(0,im.height-1)
    j = random.randint(0,im.width-1)
    color = (random.randrange(256),random.randrange(256),random.randrange(256))
    im[i,j] = color

cv.ShowImage("Noize", im)
cv.WaitKey(0)</code></pre>
<p>效果图：</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/9631b1bbgw1ew0qy9vr14j20yo0zwdv9.jpg" alt="" title=""></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742442";}i:38;a:11:{s:5:"title";s:59:"Python-OpenCV 处理图像（二）：滤镜和图像运算";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742433";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742433";s:7:"updated";s:25:"2015-09-13T21:08:22+08:00";s:9:"published";s:25:"2015-09-13T21:08:22+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"Tairy";s:10:"author_uri";s:31:"http://segmentfault.com/u/tairy";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4222:"
<blockquote><p><a href="http://segmentfault.com/a/1190000003742481">系列文章目录</a></p></blockquote>
<h3>0x01. 滤镜</h3>
<p>喜欢自拍的人肯定都知道滤镜了，下面代码尝试使用一些简单的滤镜，包括图片的平滑处理、灰度化、二值化等：</p>
<pre><code class="python">import cv2.cv as cv

image=cv.LoadImage('img/lena.jpg', cv.CV_LOAD_IMAGE_COLOR) #Load the image
cv.ShowImage("Original", image)

grey = cv.CreateImage((image.width ,image.height),8,1) #8depth, 1 channel so grayscale
cv.CvtColor(image, grey, cv.CV_RGBA2GRAY) #Convert to gray so act as a filter
cv.ShowImage('Greyed', grey)

# 平滑变换
smoothed = cv.CloneImage(image)
cv.Smooth(image,smoothed,cv.CV_MEDIAN) #Apply a smooth alogrithm with the specified algorithm cv.MEDIAN
cv.ShowImage("Smoothed", smoothed)

# 均衡处理
cv.EqualizeHist(grey, grey) #Work only on grayscaled pictures
cv.ShowImage('Equalized', grey)

# 二值化处理
threshold1 = cv.CloneImage(grey)
cv.Threshold(threshold1,threshold1, 100, 255, cv.CV_THRESH_BINARY)
cv.ShowImage("Threshold", threshold1)

threshold2 = cv.CloneImage(grey)
cv.Threshold(threshold2,threshold2, 100, 255, cv.CV_THRESH_OTSU)
cv.ShowImage("Threshold 2", threshold2)

element_shape = cv.CV_SHAPE_RECT
pos=3
element = cv.CreateStructuringElementEx(pos*2+1, pos*2+1, pos, pos, element_shape)
cv.Dilate(grey,grey,element,2) #Replace a pixel value with the maximum value of neighboors
#There is others like Erode which replace take the lowest value of the neighborhood
#Note: The Structuring element is optionnal
cv.ShowImage("Dilated", grey)

cv.WaitKey(0)</code></pre>
<h3>0x02. HighGUI</h3>
<p>OpenCV 内建了一套简单的 GUI 工具，方便我们在处理界面上编写一些控件，动态的改变输出：</p>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/lena.jpg", cv.CV_LOAD_IMAGE_GRAYSCALE)
thresholded = cv.CreateImage(cv.GetSize(im), 8, 1)

def onChange(val):
    cv.Threshold(im, thresholded, val, 255, cv.CV_THRESH_BINARY)
    cv.ShowImage("Image", thresholded)

# 创建一个滑动条控件
onChange(100) #Call here otherwise at startup. Show nothing until we move the trackbar
cv.CreateTrackbar("Thresh", "Image", 100, 255, onChange) #Threshold value arbitrarily set to 100

cv.WaitKey(0)</code></pre>
<h3>0x03. 选区操作</h3>
<p>有事希望对图像中某一块区域进行变换等操作，就可以使用如下方式：</p>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/lena.jpg",3)

# 选择一块区域
cv.SetImageROI(im, (50,50,150,150)) #Give the rectangle coordinate of the selected area

# 变换操作
cv.Zero(im)
#cv.Set(im, cv.RGB(100, 100, 100)) put the image to a given value

# 解除选区
cv.ResetImageROI(im) # Reset the ROI

cv.ShowImage("Image",im)

cv.WaitKey(0)</code></pre>
<h3>0x04. 运算</h3>
<p>对于多张图片，我们可以进行一些运算操作(包括算数运算和逻辑运算)，下面的代码将演示一些基本的运算操作：</p>
<pre><code class="python">import cv2.cv as cv#or simply import cv

im = cv.LoadImage("img/lena.jpg")
im2 = cv.LoadImage("img/fruits-larger.jpg")
cv.ShowImage("Image1", im)
cv.ShowImage("Image2", im2)

res = cv.CreateImage(cv.GetSize(im2), 8, 3)

# 加
cv.Add(im, im2, res) #Add every pixels together (black is 0 so low change and white overload anyway)
cv.ShowImage("Add", res)

# 减
cv.AbsDiff(im, im2, res) # Like minus for each pixel im(i) - im2(i)
cv.ShowImage("AbsDiff", res)

# 乘
cv.Mul(im, im2, res) #Multiplie each pixels (almost white)
cv.ShowImage("Mult", res)

# 除
cv.Div(im, im2, res) #Values will be low so the image will likely to be almost black
cv.ShowImage("Div", res)

# 与
cv.And(im, im2, res) #Bit and for every pixels
cv.ShowImage("And", res)

# 或
cv.Or(im, im2, res) # Bit or for every pixels
cv.ShowImage("Or", res)

# 非
cv.Not(im, res) # Bit not of an image
cv.ShowImage("Not", res)

# 异或
cv.Xor(im, im2, res) #Bit Xor
cv.ShowImage("Xor", res)

# 乘方
cv.Pow(im, res, 2) #Pow the each pixel with the given value
cv.ShowImage("Pow", res)

# 最大值
cv.Max(im, im2, res) #Maximum between two pixels
#Same form Min MinS
cv.ShowImage("Max",res)

cv.WaitKey(0)</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742433";}i:39;a:11:{s:5:"title";s:50:"Python-OpenCV 处理图像（一）：基本操作";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742422";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742422";s:7:"updated";s:25:"2015-09-13T21:06:30+08:00";s:9:"published";s:25:"2015-09-13T21:06:30+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:5:"Tairy";s:10:"author_uri";s:31:"http://segmentfault.com/u/tairy";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:4435:"
<blockquote><p><a href="http://segmentfault.com/a/1190000003742481">系列文章目录</a></p></blockquote>
<h3>0x01. 图片读/写操作</h3>
<p>安装好 OpenCV 之后，首先尝试加载一张最简单的图片并显示出来，代码示例：</p>
<pre><code class="python">import cv2.cv as cv

# 读图片
image=cv.LoadImage('img/image.png', cv.CV_LOAD_IMAGE_COLOR)#Load the image
#Or just: image=cv.LoadImage('img/image.png')

cv.NamedWindow('a_window', cv.CV_WINDOW_AUTOSIZE) #Facultative
cv.ShowImage('a_window', image) #Show the image

# 写图片
cv.SaveImage("thumb.png", thumb)

cv.WaitKey(0) #Wait for user input and quit</code></pre>
<p>也可以直接使用cv2的<code>imread</code>和<code>imwrite</code>函数</p>
<pre><code class="python">import cv2
image = cv2.imread('img/image.png')
cv2.imwrite('img/image.png', image)</code></pre>
<p><code>imread</code>函数还可以定义加载的mode，默认是以RGB模式处理图片：</p>
<pre><code class="python">import cv2
grayImage = cv2.imread('MyPic.png', cv2.CV_LOAD_IMAGE_GRAYSCALE)
# 可选参数CV_LOAD_IMAGE_COLOR (BGR), CV_LOAD_IMAGE_GRAYSCALE (grayscale), CV_LOAD_IMAGE_UNCHANGED(neither)
cv2.imwrite('MyPicGray.png', grayImage)</code></pre>
<h3>0x02. 输出 Hello World</h3>
<p>在处理图片的时候，我们经常会需要把一些信息直接以文字的形式输出在图片上，下面的代码将实现这个效果：</p>
<pre><code class="python">import cv2.cv as cv

image=cv.LoadImage('img/lena.jpg', cv.CV_LOAD_IMAGE_COLOR) #Load the image

font = cv.InitFont(cv.CV_FONT_HERSHEY_SIMPLEX, 1, 1, 0, 3, 8) #Creates a font

y = image.height / 2 # y position of the text
x = image.width / 4 # x position of the text

cv.PutText(image,"Hello World !", (x,y),font, cv.RGB(255, 255, 255)) #Draw the text

cv.ShowImage('Hello World', image) #Show the image

cv.WaitKey(0)</code></pre>
<p>效果：</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/9631b1bbgw1ew0mzb086mj20e60e741v.jpg" alt="" title=""></p>
<h3>0x03. 缩放并保存图片</h3>
<p>下面的例子将实现缩放图片并保存，这个在使用 OpenCV 做图像处理的时候都是很常用的操作：</p>
<pre><code class="python">import cv2.cv as cv

im = cv.LoadImage("img/alkaline.jpg") #get the image

thumb = cv.CreateImage((im.width / 2, im.height / 2), 8, 3) #Create an image that is twice smaller than the original

cv.Resize(im, thumb) #resize the original image into thumb
#cv.PyrDown(im, thumb)

cv.SaveImage("thumb.png", thumb) # save the thumb image</code></pre>
<h3>0x04. 图像颜色变换</h3>
<p>实际使用过程中，我们经常也需要对一些图片的颜色做一些改变之类的：</p>
<pre><code class="python">import cv2.cv as cv

im=cv.LoadImage('img/fruits.jpg',cv.CV_LOAD_IMAGE_COLOR)

res = cv.CreateImage(cv.GetSize(im), cv.CV_8UC2, 3) #cv.CV_32F, cv.IPL_DEPTH_16S, ...

cv.Convert(im, res) cv.ShowImage("Converted",res)
res2 = cv.CreateImage(cv.GetSize(im), cv.CV_8UC2, 3)
cv.CvtColor(im, res2, cv.CV_RGB2BGR) # HLS, HSV, YCrCb, ....

cv.ShowImage("CvtColor", res2)
cv.WaitKey(0)</code></pre>
<p>效果：</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/9631b1bbgw1ew0n8opakrj20st0bldiz.jpg" alt="" title=""></p>
<h3>0x05. 通道的切分/合并处理</h3>
<p>对于一张图片的 R、G、B 通道，我们可以很方便的使用 OpenCV 获取并分离或者合并：</p>
<pre><code class="python">import cv2.cv as cv

orig = cv.LoadImage('img/fruits.jpg')
b = cv.CreateImage(cv.GetSize(orig), orig.depth, 1)
g = cv.CloneImage(b)
r = cv.CloneImage(b)
cv.Split(orig, b, g, r, None)

merged = cv.CreateImage(cv.GetSize(orig), 8, 3)
cv.Merge(g, b, r, None, merged)

cv.ShowImage("Image", orig)
cv.ShowImage("Blue", b)
cv.ShowImage("Green", g)
cv.ShowImage("Red", r)
cv.ShowImage("Merged", merged)

cv.WaitKey(0)</code></pre>
<p>效果：</p>
<p>原始图像</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/9631b1bbgw1ew0nh7msbdj20e80dcgnk.jpg" alt="原始图像" title="原始图像"></p>
<p>R 通道</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/9631b1bbgw1ew0nhe6r0pj20e80dcmyr.jpg" alt="R" title="R"></p>
<p>G 通道</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/9631b1bbgw1ew0nh8qf34j20e80dcmyr.jpg" alt="" title=""></p>
<p>B 通道</p>
<p><img src="http://ww2.sinaimg.cn/mw1024/9631b1bbgw1ew0nh6ppjfj20e80dcwg9.jpg" alt="" title=""></p>
<p>Merge</p>
<p><img src="http://ww2.sinaimg.cn/mw1024/9631b1bbgw1ew0nh9v8egj20e80dc0vr.jpg" alt="" title=""></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742422";}i:40;a:11:{s:5:"title";s:21:"如何使用CocoaPods";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742397";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742397";s:7:"updated";s:25:"2015-09-13T20:56:18+08:00";s:9:"published";s:25:"2015-09-13T20:56:18+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:7:"snowell";s:10:"author_uri";s:33:"http://segmentfault.com/u/snowell";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:7381:"
<h2>什么是CocoaPods</h2>
<p>CocoaPods是Xcode上的依赖管理工具。官网：<a href="https://cocoapods.org/"></a><a href="https://cocoapods.org/">https://cocoapods.org/</a>。</p>
<p>如果不使用依赖管理工具，那么当使用第三方库的时候就会苦不堪言。你需要把第三方库的源代码拷贝到工程中，如果这些库本身还有其它framework的依赖关系，那么还需要手动倒入。尤其是将来有更新的时候，更加的麻烦。但是使用了CocoaPods以后，这些工作CocoaPods都可以帮你完成。</p>
<h2>如何安装CocoaPods</h2>
<h3>关于Ruby</h3>
<p>CocoaPods是用Ruby来Build的，所以用Ruby的命令就可以进行安装。Mac OSX本身自带Ruby。在terminal里就能完成安装。如果你的gem版本比较低，可以在terminal里输入如下命令行来更新Ruby：</p>
<pre><code>$ sudu gem update --system
</code></pre>
<p>需要输入sudu的密码。</p>
<h3>gem命令</h3>
<p>我们使用Ruby的gem命令，来安装CocoaPods，敲入如下命令行：</p>
<pre><code>$ sudo gem install cocoapods
</code></pre>
<p>然后需要输入<code>sudo</code>的密码，接着就开始安装了。</p>
<p>如果你在国内，很可能会遇到下图中的错误：</p>
<pre><code>Could not find a valid gem 'cocoapods' (&gt;=0), here is why: 
Unable to download data from https://rubygems.org/ -Errno: ECONNRESET: Connection reset by peer - SSL_connect
(https://rubygems.org/latest_specs.4.8.gz)</code></pre>
<p>这是因为，Ruby的软件源（rubygems.org）使用的是亚马逊的云服务，而亚马逊的云服务被屏蔽了。所以我们要加个源。在terminal里输入如下命令行：</p>
<pre><code>$ gem sources --add http://rubygems.org/
</code></pre>
<p>输入之后，会提示你https的比http更加安全，不用管，再次执行安装命令行进行安装。</p>
<p>当然，如果原来的https源不需要了，也可以remove掉：</p>
<pre><code>$ gem sources --remove https://rubygems.org/
</code></pre>
<p>此外，如果不想使用<a href="http://rubygems.org/">http://rubygems.org/</a>的源，在国内的淘宝也有相应的源，可以加入淘宝的源：</p>
<pre><code>$ gem sources --add http://ruby.taobao.org/
</code></pre>
<p>源添加删除以后，可以查看一下现在的源都有哪些：</p>
<pre><code>$ gem sources -l
</code></pre>
<p>相应的源就会一一罗列出来，可以检查一下加的对不对。</p>
<p><img src="/img/bVpKn6" alt="terminal中安装CocoaPods" title="terminal中安装CocoaPods"></p>
<h3>在本地建立CocoaPods的Repo</h3>
<p>你也可以通过命令行来建立CocoaPods的Repo，在terminal里输入：</p>
<pre><code>$ pod setup
</code></pre>
<p>会显示“Setting up CocoaPods master repo”，此时，正在 ~/.cocoapods/路径下建立Repo。可以<code>cd</code>到这个路径下，用命令行<code>du -sh *</code>来查看下载进度。</p>
<p>如果速度比较慢，也许是因为Podspec的索引文件比较大，而Podspec的文件都在github上。国内有个好心人akinliu做了两个镜像，一个在GitCafe上，一个在OSChina上。这两个服务器都在国内，会比较快。可以这样重新设置CocoaPods的镜像：</p>
<pre><code>pod repo remove master
pod repo add master https://gitcafe.com/akuandev/Specs.git
pod repo update</code></pre>
<p>把<code>https://gitcafe.com/akuandev/Specs.git</code>换成<code>http://git.oschina.net/akuandev/Specs.git</code>就是OSChina上的镜像了。</p>
<h2>使用CocoaPods</h2>
<h3>建立Podfile文件</h3>
<p>首先要建立一个文本文件，起名叫Podfile，不需要任何的后缀。在文件里填写如下：</p>
<pre><code>platform :ios, '8.0'
use_frameworks!

target 'YourApp' do
  pod 'AFNetworking', '~&gt; 2.5'
  pod 'ORStackView', '~&gt; 2.0'
  pod 'SwiftyJSON', '~&gt; 2.1'
end
</code></pre>
<p><code>platform</code>代表CocoaPods应用的平台，这里就是8.0的iOS。<code>YourApp</code>就是你的工程的名字，<code>AFNetworking</code>、<code>ORStackView</code>和<code>SwiftyJSON</code>都是你需要倒入的库。</p>
<p>然后把这个文件copy到<code>YourApp</code>的根目录下。</p>
<p>在terminal里，首先先<code>cd</code>到<code>YourApp</code>的根目录，然后输入：</p>
<pre><code>$ pod install
</code></pre>
<p>这样，Podfile文件中所罗列的全部的第三方的库都已经自动设置好了依赖和编译参数，不需要做额外的操作了。</p>
<h3>用appledoc生成帮助文档</h3>
<p>可以用appledoc，让CocoaPods自动生成第三方库的帮助文档，在Xcode中，当按住option键单击类名或方法名的时候，就可以显示帮助信息。</p>
<p>在terminal中运行下列命令行完成安装：</p>
<pre><code>$ brew install appledoc
</code></pre>
<p>如果brew版本过低，可以运行：</p>
<pre><code>$ brew update
</code></pre>
<p>来更新。</p>
<h3>需要注意的几点问题</h3>
<p>但是，需要注意四点：</p>
<ol>
<li>
<p>每次再打开这个工程，不能运行原来的.xcodeproj文件，而是.xcworkspace文件来打开工程。可以<code>cd</code>到<code>YourApp</code>的根目录，然后输入：</p>
<pre><code>$ open YourApp.xcworkspace
</code></pre>
</li>
<li><p>一旦修改了Podfile文件，就需要重新运行一下<code>pod update</code>命令。</p></li>
<li><p>install以后，会在工程的根目录下生成一个Podfile.lock的文件，这个不能check in，需要在git的ignore文件中添加一下。因为这个文件会锁定第三方库的依赖版本，即使执行<code>pod install</code>也不会修改其版本，只有执行<code>pod update</code>才可以。所以不check in方便多人协作升级第三份库的依赖版本。</p></li>
<li>
<p>可以不更新podspec。因为每次运行<code>pod install</code>和<code>pod update</code>的时候，默认会先更新一次podspec索引。每次运行着两个命令行时，可以带上不更新索引的参数：</p>
<pre><code>$ pod install --no-repo-update
$ pod update --no-repo-update
</code></pre>
</li>
</ol>
<h2>查找第三方库</h2>
<p>只需要在terminal里输入：</p>
<pre><code>$ pod search JSON
</code></pre>
<p>就会罗列出全部符合条件的第三方开源库。<code>JSON</code>为你要找的关键字。</p>
<h2>使用私有的pod</h2>
<p>我们可以安装私有的pod，在terminal里输入：</p>
<pre><code>$ pod 'MyPod', :podspec =&gt; 'https://yourPodAddress/myPod.podspec'
</code></pre>
<h2>如何创建一个Pod</h2>
<pre><code>$ pod spec create Peanut
$ edit Peanut.podspec
$ pod spec lint Peanut.podspec</code></pre>
<p>创建了一个Peanut.podspec的文件，然后修改其内容。</p>
<h2>原理</h2>
<p>CocoaPods首先创建了一个名为Pods的工程，然后将全部的依赖库都放在里面。然后Pods工程会生成一个libPods.a的文件，让主工程依赖libPods.a文件。此外，CocoaPods还提供了一个Pods-resources.sh的bash脚本，这个脚本每次工程编译的时候都会运行，把第三方库的各种资源复制到目标目录中。最后，CocoaPods通过Pods.xcconfig文件在编译时设置所有的依赖和参数。</p>
<h2>参考文献</h2>
<ol>
<li><p>CocoaPods官网文档 <a href="https://cocoapods.org/"></a><a href="https://cocoapods.org/">https://cocoapods.org/</a></p></li>
<li><p>《iOS开发进阶》</p></li>
</ol>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742397";}i:41;a:11:{s:5:"title";s:30:"前端之Sass/Scss实战笔记";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742313";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742313";s:7:"updated";s:25:"2015-09-13T20:21:30+08:00";s:9:"published";s:25:"2015-09-13T20:21:30+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:25:"王下邀月熊_Chevalier";s:10:"author_uri";s:36:"http://segmentfault.com/u/wxyyxc1992";s:2:"re";a:1:{s:4:"rank";s:1:"3";}s:7:"summary";s:9553:"
<h1>Introduction</h1>
<p>Sass 有两种语法规则(syntaxes),目前新的语法规则（从 Sass 3开始）被称为 “SCSS”( 时髦的css（Sassy CSS）),它是css3语法的的拓展级，就是说每一个语法正确的CSS3文件也是合法的SCSS文件，SCSS文件使用.scss作为拓展名。第二种语法别成为缩进语法（或者 Sass），它受到了Haml的简洁精炼的启发，它是为了人们可以用和css相近的但是更精简的方式来书写css而诞生的。它没有括号，分号，它使用 行缩进 的方式来指定css 块，虽然sass不是最原始的语法，但是缩进语法将继续被支持，在缩进语法的文件以 .sass 为拓展名。</p>
<h2>注释</h2>
<p>有三种形式：</p>
<p>（1）//comment：该注释只是在.scss源文件中有，编译后的css文件中没有。</p>
<p>（2）/<em>! </em>/：重要注释，任何style的css文件中都会有，一般放置css文件版权说明等信息。</p>
<p>（3）/<em> </em>/：该注释在compressed的style的css中没有，其他style的css文件都会含有。</p>
<h2>Quick Start</h2>
<h3>Installation</h3>
<h3>Build</h3>
<p><strong>1.切换到.scss文件所在目录</strong></p>
<p>命令行下切换到代码文件夹目录（如Z:\），假设有文件test.scss文件，里面内容如下：（SASS完全支持css语法）</p>
<pre><code class="css">h1{
    font-size:17px;    
}
h2{
    font-size:18px;
}</code></pre>
<p><strong>2.编译scss文件为css文件</strong></p>
<p>　　运行命令：sass --style compressed test.scss test.css，即可生成压缩版的css文件，并且命名为test.css。几点说明：</p>
<p>（1）--style 后面可以有四个参数可选，分别为expanded、nested、compact、compressed，分别选用不同参数的效果可以自己尝试体验。</p>
<p>（2）test.scss和test.css文件目录可以自定义，例如把Z盘sass目录下的test.scss文件编译为压缩版的文件，并放置在Z盘css目录下，那么命令即：sass --style compressed z:\sass\test.scss z:\css\test.css</p>
<p>（3）开发过程中，只需要修改scss文件，然后编译；前端页面只需要引用相应的css文件即可。</p>
<p><strong>3.侦听文件和文件夹</strong></p>
<p>如果希望某一个scss文件或者相应的文件夹下面文件修改后，自动进行编译，那么可以使用侦听命令。</p>
<p>（1）侦听文件：</p>
<p>sass --watch --style compressed test.scss:test.css</p>
<p>当test.scss文件有修改后，会自动编译为test.css，并且是compressed的。</p>
<p>（2）侦听文件夹：</p>
<p>sass --watch --style compressed sass:css</p>
<p>当sass文件夹下.scss文件有修改的时候，会自动编译为与sass中文件同名的css文件。</p>
<p> <strong>备注：</strong></p>
<p>（1）注意源文件和目标文件之间是<strong>冒号</strong>，与编译命令中为空格不同。</p>
<p>（2）生成的map文件可以查找source map文件的作用。</p>
<h3>Webpack</h3>
<p>Webpack中也内置了sass-loader，通过简单的配置既可以使用。不过需要注意的是，Webpack的sass-loader还是依赖于node-sass以及sass(gem)，所以如果安装sass-loader报错可以先尝试安装sass。</p>
<h1>变量与选择器</h1>
<h2>变量</h2>
<h3>定义</h3>
<p>变量的定义一般以$开头，某个变量的作用域仅限于他们定义的层级以及子层级。如果变量是定义在所有嵌套选择器之外的，那么他们可以在各处被调用。</p>
<pre><code class="scss">$color1:#aeaeae;
.div1{
    background-color:$color1;
}</code></pre>
<p>编译后：</p>
<pre><code class="scss">.div1 {
  background-color: #aeaeae;
}
/*# sourceMappingURL=test.css.map */</code></pre>
<p>如果希望某个在子选择器中定义的变量能够成为全局变量，可以使用!global关键字：</p>
<pre><code>#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}</code></pre>
<h3>嵌套引用</h3>
<p>嵌套引用在其他编程语言中即是字符串插值，需要用#{}进行包裹：</p>
<pre><code class="scss">$left:left;
.div1{
    border-#{$left}-width:5px;
}</code></pre>
<h3>变量计算</h3>
<p>Sass中也是支持对于变量进行简单的计算：</p>
<pre><code class="scss">$left:20px;
.div1{
    margin-left:$left+12px;
}</code></pre>
<p>变量可以支持计算的类型，还是比较多的：</p>
<pre><code class="scss">p {
  font: 10px/8px;             // Plain CSS, no division
  $width: 1000px;
  width: $width/2;            // Uses a variable, does division
  width: round(1.5)/2;        // Uses a function, does division
  height: (500px/2);          // Uses parentheses, does division
  margin-left: 5px + 8px/2px; // Uses +, does division
  font: (italic bold 10px/8px); // In a list, parentheses don't count
}</code></pre>
<h2>选择器</h2>
<h3>嵌套</h3>
<pre><code class="scss">.div1{
    .span1{
        height: 12px;
    }
    .div2{
        width: 16px;
    }
}</code></pre>
<p>属性也可以嵌套，比如border-color属性，可以写成：</p>
<pre><code class="scss">　　p {
　　　　border: {
　　　　　　color: red;
　　　　}
　　}</code></pre>
<p>注意，border后面必须加上冒号。</p>
<h3>父元素引用</h3>
<p>在嵌套的子层级中，允许使用&amp;引用父元素：</p>
<pre><code class="scss">.div1{
    &amp;:hover{
        cursor: hand;
    }
}</code></pre>
<h1>代码重用</h1>
<h2>继承</h2>
<p>SASS允许一个选择器，继承另一个选择器。比如，现有class1：</p>
<pre><code class="scss">.class1{
    font-size:19px;
}
.class2{
    @extend .class1;
    color:black;
}</code></pre>
<p><strong>注意：如果在class2后面有设置了class1的属性，那么也会影响class2，如下：</strong></p>
<pre><code class="scss">.class1{
    font-size:19px;
}
.class2{
    @extend .class1;
    color:black;
}
.class1{
    font-weight:bold;
}</code></pre>
<p>由此可以看出Scss也是递归编译的。</p>
<h2><strong>引用外部css文件（Partials）</strong></h2>
<p>有时网页的不同部分会分成多个文件来写样式，或者引用通用的一些样式，那么可以使用@import。</p>
<pre><code class="scss">@import "_test1.scss";
@import "_test2.scss";
@import "_test3.scss";</code></pre>
<h2>Mixin&amp;Include</h2>
<p>Mixin有点像C语言的宏（macro），是可以重用的代码块。</p>
<p>使用@mixin命令，定义一个代码块。</p>
<pre><code class="scss">　　@mixin left {
　　　　float: left;
　　　　margin-left: 10px;
　　}</code></pre>
<p>使用@include命令，调用这个mixin。</p>
<pre><code class="scss">　　div {
　　　　@include left;
　　}</code></pre>
<h3>参数与缺省值</h3>
<ul><li><p>边距设置</p></li></ul>
<pre><code class="scss">@mixin common($value1,$value2,$defaultValue:12px){
    display:block;
    margin-left:$value1;
    margin-right:$value2;
    padding:$defaultValue;
}
.class1{
    font-size:16px;
    @include common(12px,13px,15px);
}
.class2{
    font-size:16px;
    @include common(12px,13px);
}</code></pre>
<ul><li><p>浏览器前缀设置设置</p></li></ul>
<p>下面是一个mixin的实例，用来生成浏览器前缀。</p>
<pre><code class="scss">　　@mixin rounded($vert, $horz, $radius: 10px) {
　　　　border-#{$vert}-#{$horz}-radius: $radius;
　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;
　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;
　　}</code></pre>
<p>使用的时候，可以像下面这样调用：</p>
<pre><code class="scss">　　#navbar li { @include rounded(top, left); }
　　#footer { @include rounded(top, left, 5px); }</code></pre>
<h1>编程式方法</h1>
<h2>流程控制</h2>
<h3>条件语句</h3>
<p>@if可以用来判断：</p>
<pre><code class="scss">　　p {
　　　　@if 1 + 1 == 2 { border: 1px solid; }
　　　　@if 5 &lt; 3 { border: 2px dotted; }
　　}</code></pre>
<p>配套的还有@else命令：</p>
<pre><code class="scss">　　@if lightness($color) &gt; 30% {
　　　　background-color: #000;
　　} @else {
　　　　background-color: #fff;
　　}</code></pre>
<h3>循环语句</h3>
<p>SASS支持for循环：</p>
<pre><code>　　@for $i from 1 to 10 {
　　　　.border-#{$i} {
　　　　　　border: #{$i}px solid blue;
　　　　}
　　}</code></pre>
<p>也支持while循环：</p>
<pre><code>　　$i: 6;
　　@while $i &gt; 0 {
　　　　.item-#{$i} { width: 2em * $i; }
　　　　$i: $i - 2;
　　}</code></pre>
<p>each命令，作用与for类似：</p>
<pre><code>　　@each $member in a, b, c, d {
　　　　.#{$member} {
　　　　　　background-image: url("/image/#{$member}.jpg");
　　　　}
　　}</code></pre>
<h2>函数</h2>
<p>Sass允许用户自定义函数，原型如下所示：</p>
<pre><code class="scss">　　@function double($n) {
　　　　@return $n * 2;
　　}

　　#sidebar {
　　　　width: double(5px);
　　}</code></pre>
<h3>颜色函数</h3>
<p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<pre><code class="scss">　　lighten(#cc3, 10%)  // #d6d65c
　　darken(#cc3, 10%)  //  #a3a329
　　grayscale(#cc3) // #808080
　　complement(#cc3) // #33c</code></pre>
<h1>Reference</h1>
<blockquote><ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html">阮一峰-SASS用法指南</a></p></li>
<li><p><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#variables_">Official Documentation</a></p></li>
</ul></blockquote>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742313";}i:42;a:11:{s:5:"title";s:44:"如何更新及替换ViewPager中的Fragment";s:4:"link";s:42:"http://segmentfault.com/a/1190000003742057";s:2:"id";s:42:"http://segmentfault.com/a/1190000003742057";s:7:"updated";s:25:"2015-09-13T17:55:10+08:00";s:9:"published";s:25:"2015-09-13T17:55:10+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:4:"li21";s:10:"author_uri";s:30:"http://segmentfault.com/u/li21";s:2:"re";a:1:{s:4:"rank";s:1:"1";}s:7:"summary";s:21191:"
<p>How to update and replace fragment in viewpager?</p>
<h1>ListView的工作原理</h1>
<p>在了解ViewPager的工作原理之前，先回顾ListView的工作原理：</p>
<blockquote><ol>
<li><p>ListView只有在需要显示某些列表项时，它才会去申请可用的视图对象；如果为所有的列表项数据创建视图对象，会浪费内存；</p></li>
<li><p>ListView找谁去申请视图对象呢？ 答案是adapter。<strong>adapter是一个控制器对象，负责从模型层获取数据，创建并填充必要的视图对象，将准备好的视图对象返回给ListView</strong>；</p></li>
<li><p>首先，通过调用adapter的getCount()方法，ListView询问数组列表中包含多少个对象（为避免出现数组越界的错误)；紧接着ListView就调用adapter的getView(int, View, ViewGroup)方法。</p></li>
</ol></blockquote>
<p>ViewPager某种程度上类似于ListView，区别在于：ListView通过<code>ArrayAdapter.getView(int position, View convertView, ViewGroup parent)</code>填充视图；ViewPager通过<code>FragmentPagerAdapter.getItem(int position)</code>生成指定位置的fragment.</p>
<p>而我们需要关注的是:</p>
<h1>ViewPager和它的adapter是如何配合工作的？</h1>
<p><strong>声明：本文内容针对android.support.v4.app.</strong>*<br>ViewPager有两个adapter：FragmentPagerAdapter和FragmentStatePagerAdapter：</p>
<ul><li><p><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentPagerAdapter.java#FragmentPagerAdapter">android.support.v4.app.FragmentPagerAdapter</a></p></li></ul>
<blockquote><p>继承自android.support.v4.view.PagerAdapter，每页都是一个Fragment，并且所有的Fragment实例一直保存在Fragment manager中。所以它适用于少量固定的fragment，比如一组用于分页显示的标签。除了当Fragment不可见时，它的视图层（view hierarchy）有可能被销毁外，每页的Fragment都会被保存在内存中。（翻译自代码文件的注释部分）</p></blockquote>
<ul><li><p><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentStatePagerAdapter.java#FragmentStatePagerAdapter">android.support.v4.app.FragmentStatePagerAdapter</a></p></li></ul>
<blockquote><p>继承自android.support.v4.view.PagerAdapter，每页都是一个Fragment，当Fragment不被需要时（比如不可见），整个Fragment都会被销毁，除了saved state被保存外（保存下来的bundle用于恢复Fragment实例）。所以它适用于很多页的情况。（翻译自代码文件的注释部分）</p></blockquote>
<p>它俩的子类，需要实现<code>getItem(int)</code> 和 <code>android.support.v4.view.PagerAdapter.getCount()</code>.</p>
<h2>先通过一段代码了解ViewPager和FragmentPagerAdapter的典型用法</h2>
<p>稍后做详细分析：</p>
<pre><code class="java">  // Set a PagerAdapter to supply views for this pager.
  ViewPager viewPager = (ViewPager) findViewById(R.id.my_viewpager_id);
  viewPager.setAdapter(mMyFragmentPagerAdapter);
 
  private FragmentPagerAdapter mMyFragmentPagerAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) {
    @Override
    public int getCount() {
      return 2; // Return the number of views available.
    }
 
    @Override
    public Fragment getItem(int position) {
      return new MyFragment(); // Return the Fragment associated with a specified position.
    }
 
    // Called when the host view is attempting to determine if an item's position has changed.
    @Override
    public int getItemPosition(Object object) {
      if (object instanceof MyFragment) {
        ((MyFragment)object).updateView();
      }
      return super.getItemPosition(object);
    }
  };
 
  private class MyFragment extends Fragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      // do something such as init data
    }
 
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
      View view = inflater.inflate(R.layout.fragment_my, container, false);
      // init view in the fragment
      return view;
    }
 
    public void updateView() {
      // do something to update the fragment
    }
  }</code></pre>
<p>FragmentPagerAdapter和FragmentStatePagerAdapter对Fragment的管理略有不同，在详细考察二者区别之前，我们通过两种较为直观的方式先感受下：</p>
<h2>通过两张图片直观的对比FragmentPagerAdapter和FragmentStatePagerAdapter的区别</h2>
<p><em>说明：这两张图片来自于《Android权威编程指南》，原图有3个Fragment，我增加了1个Fragment，以及被调到的方法。</em><br>FragmentPagerAdapter的Fragment管理：<br><img src="http://7xljdj.com1.z0.glb.clouddn.com/%E5%9B%BE11-4-FragmentPagerAdapter%E7%9A%84fragment%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png" alt="image-11-4-FragmentPagerAdapter的fragment管理-方法调用" title="image-11-4-FragmentPagerAdapter的fragment管理-方法调用"></p>
<p>FragmentStatePageAdapter的Fragment管理：<br><img src="http://7xljdj.com1.z0.glb.clouddn.com/%E5%9B%BE11-3FragmentStatePagerAdapter%E7%9A%84fragment%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png" alt="image-11-3FragmentStatePagerAdapter的fragment管理-方法调用" title="image-11-3FragmentStatePagerAdapter的fragment管理-方法调用"></p>
<h2>详细分析 adapter method和fragment lifecycle method 的调用情况</h2>
<p>好啦，感受完毕，我们需要探究其详情，梳理adapter创建、销毁Fragment的过程，过程中adapter method和fragment lifecycle method哪些被调到，有哪些一样，有哪些不一样。</p>
<p>最开始处于第0页时，adapter不仅为第0页创建Fragment实例，还为相邻的第1页创建了Fragment实例：</p>
<pre><code class="java">// 刚开始处在page0
D/Adapter (25946): getItem(0)
D/Fragment0(25946): newInstance(2015-09-10)  // 注释：newInstance()调用了Fragment的构造器方法，下同。
D/Adapter (25946): getItem(1)
D/Fragment1(25946): newInstance(Hello World, I'm li2.)
D/Fragment0(25946): onAttach()
D/Fragment0(25946): onCreate()
D/Fragment0(25946): onCreateView()
D/Fragment1(25946): onAttach()
D/Fragment1(25946): onCreate()
D/Fragment1(25946): onCreateView()</code></pre>
<p>第1次从第0页滑到第1页，adapter同样会为相邻的第2页创建Fragment实例；</p>
<pre><code class="java">// 第1次滑到page1
D/Adapter (25946): onPageSelected(1)
D/Adapter (25946): getItem(2)
D/Fragment2(25946): newInstance(true)
D/Fragment2(25946): onAttach()
D/Fragment2(25946): onCreate()
D/Fragment2(25946): onCreateView()</code></pre>
<blockquote><p>FragmentPagerAdapter和FragmentStatePagerAdapter齐声说：呐，请主公贰放心，属下定会为您准备好相邻的下一页视图哒！么么哒！</p></blockquote>
<p>它俩对待下一页的态度是相同的，但对于上上页，它俩做出了不一样的事情：</p>
<blockquote><p>FragmentPagerAdapter说：<strong>上上页的实例还保留着，只是销毁了它的视图</strong>：</p></blockquote>
<pre><code class="java">// 第N次（N不等于1）向右滑动选中page2
D/Adapter (25946): onPageSelected(2)
D/Adapter (25946): destroyItem(0)  // 销毁page0的视图
D/Fragment0(25946): onDestroyView()
D/Fragment3(25946): onCreateView()  // page3的Fragment实例仍保存在FragmentManager中，所以只需创建它的视图</code></pre>
<blockquote><p>FragmentStatePagerAdapter说：<strong>上上页的实例和视图都被俺销毁啦</strong>：</p></blockquote>
<pre><code class="java">// 第N次（N不等于1）向右滑选中page2
D/Adapter (27880): onPageSelected(2)
D/Adapter (27880): destroyItem(0)  // 销毁page0的实例和视图
D/Adapter (27880): getItem(3)  // 创建page3的Fragment
D/Fragment3(27880): newInstance()
D/Fragment0(27880): onDestroyView()
D/Fragment0(27880): onDestroy()
D/Fragment0(27880): onDetach()
D/Fragment3(27880): onAttach()
D/Fragment3(27880): onCreate()
D/Fragment3(27880): onCreateView()</code></pre>
<h2>Fragment getItem(int position)</h2>
<pre><code class="java">// Return the Fragment associated with a specified position.
public abstract Fragment getItem(int position);</code></pre>
<p>当adapter需要一个指定位置的Fragment，并且这个Fragment不存在时，getItem就被调到，返回一个Fragment实例给adapter。<br>所以，有必要再次强调，<strong>getItem是创建一个新的Fragment，但是这个方法名可能会被误认为是返回一个已经存在的Fragment</strong>。<br>对于FragmentPagerAdapter，当每页的Fragment被创建后，这个函数就不会被调到了。对于FragmentStatePagerAdapter，由于Fragment会被销毁，所以它仍会被调到。<br>由于我们必须在getItem中实例化一个Fragment，所以当getItem()被调用后，Fragment相应的生命周期函数也就被调到了：</p>
<pre><code class="java">D/Adapter (25946): getItem(1)
D/Fragment1(25946): newInstance(Hello World, I'm li2.)  // newInstance()调用了Fragment的构造器方法；
D/Fragment1(25946): onAttach()
D/Fragment1(25946): onCreate()
D/Fragment1(25946): onCreateView()</code></pre>
<h2>void destroyItem(ViewGroup container, int position, Object object)</h2>
<pre><code class="java">// Remove a page for the given position. 
public void FragmentPagerAdapter.destroyItem(ViewGroup container, int position, Object object) {
    mCurTransaction.detach((Fragment)object);
}

public void FragmentStatePagerAdapter.destroyItem(ViewGroup container, int position, Object object) {
    mSavedState.set(position, mFragmentManager.saveFragmentInstanceState(fragment));
    mFragments.set(position, null);
    mCurTransaction.remove(fragment);
}</code></pre>
<p>销毁指定位置的Fragment。从源码中可以看出二者的区别，一个detach，一个remove，这将调用到不同的Fragment生命周期函数：</p>
<pre><code class="java">// 对于FragmentPagerAdapter
D/Adapter (25946): onPageSelected(2)
D/Adapter (25946): destroyItem(0)
D/Fragment0(25946): onDestroyView()  // 销毁视图

// 对于FragmentStatePagerAdapter
D/Adapter (27880): onPageSelected(2)
D/Adapter (27880): destroyItem(0)
D/Fragment0(27880): onDestroyView()  // 销毁视图
D/Fragment0(27880): onDestroy()  // 销毁实例
D/Fragment0(27880): onDetach()</code></pre>
<h2>FragmentPagerAdapter和FragmentStatePagerAdapter对比总结</h2>
<blockquote>
<p>二者使用方法基本相同，唯一的区别就在卸载不再需要的fragment时，采用的处理方式不同：</p>
<ul>
<li><p>使用FragmentStatePagerAdapter会<strong>销毁掉不需要的fragment</strong>。事务提交后，可将fragment从activity的FragmentManager中彻底移除。类名中的“state”表明：在销毁fragment时，它会将其onSaveInstanceState(Bundle) 方法中的Bundle信息保存下来。用户切换回原来的页面后，保存的实例状态可用于恢复生成新的fragment.</p></li>
<li><p>FragmentPagerAdapter的做法大不相同。对于不再需要的fragment，FragmentPagerAdapter则选择调用事务的detach(Fragment) 方法，而非remove(Fragment)方法来处理它。也就是说，FragmentPagerAdapter<strong>只是销毁了fragment的视图</strong>，但仍将fragment实例保留在FragmentManager中。因此， FragmentPagerAdapter创建的fragment永远不会被销毁。</p></li>
</ul>
<p>(摘抄自《Android权威编程指南11.1.4》)</p>
</blockquote>
<h2>更新ViewPager中的Fragment</h2>
<p>调用<code>notifyDataSetChanged()</code>时，2个adapter的方法的调用情况相同，<strong>当前页和相邻的两页的getItemPosition都会被调用到</strong>。</p>
<pre><code class="java">// Called when the host view is attempting to determine if an item's position has changed. Returns POSITION_UNCHANGED if the position of the given item has not changed or POSITION_NONE if the item is no longer present in the adapter.
public int getItemPosition(Object object) {
    return POSITION_UNCHANGED;
}</code></pre>
<p><a href="http://stackoverflow.com/questions/18088076/update-fragment-from-viewpager/">从网上找到的解决办法是</a>，覆写getItemPosition使其返POSITION_NONE，以触发Fragment的销毁和重建。可是这将导致Fragment频繁的销毁和重建，并不是最佳的方法。<br>后来我把注意力放在了入口参数<code>object</code>上，"representing an item", 实际上就是Fragment，只需要为Fragment提供一个更新view的public方法：</p>
<pre><code>@Override
// To update fragment in ViewPager, we should override getItemPosition() method,
// in this method, we call the fragment's public updating method.
public int getItemPosition(Object object) {
    Log.d(TAG, "getItemPosition(" + object.getClass().getSimpleName() + ")");
    if (object instanceof Page0Fragment) {
        ((Page0Fragment) object).updateDate(mDate);
    } else if (object instanceof Page1Fragment) {
        ((Page1Fragment) object).updateContent(mContent);
    } else if (object instanceof Page2Fragment) {
        ((Page2Fragment) object).updateCheckedStatus(mChecked);
    } else if (...) {
    }
    return super.getItemPosition(object);
};

// 更新界面时方法的调用情况
// 当前页为0时
D/Adapter (21517): notifyDataSetChanged(+0)
D/Adapter (21517): getItemPosition(Page0Fragment)
D/Fragment0(21517): updateDate(2015-09-12)
D/Adapter (21517): getItemPosition(Page1Fragment)
D/Fragment1(21517): updateContent(Hello World, I am li2.)

// 当前页为1时
D/Adapter (21517): notifyDataSetChanged(+1)
D/Adapter (21517): getItemPosition(Page0Fragment)
D/Fragment0(21517): updateDate(2015-09-13)
D/Adapter (21517): getItemPosition(Page1Fragment)
D/Fragment1(21517): updateContent(Hello World, I am li2.)
D/Adapter (21517): getItemPosition(Page2Fragment)
D/Fragment2(21517): updateCheckedStatus(true)</code></pre>
<p><strong>在最开始调用notifyDataSetChanged试图更新Fragment时，我是这样做的：用arraylist保存所有的Fragment，当需要更新时，就从arraylist中取出Fragment，然后调用该Fragment的update方法。这种做法非常鱼唇，当时完全不懂得adapter的Fragment manager在替我管理所有的Fragment</strong>。而我只需要：</p>
<ul>
<li><p>覆写getCount告诉adapter有几个Fragment；</p></li>
<li><p>覆写getItem以实例化一个指定位置的Fragment返回给adapter；</p></li>
<li><p>覆写getItemPosition，把入口参数强制转型成自定义的Fragment，然后调用该Fragment的update方法以完成更新。</p></li>
</ul>
<p><strong>只需要覆写这几个adapter的方法，adapter会为你完成所有的管理工作，不需要自己保存、维护Fragment</strong>。</p>
<h2>替换ViewPager中的Fragment</h2>
<p>应用场景可能是这样，比如有一组按钮，Day/Month/Year，有一个包含几个Fragment的ViewPager。点击不同的按钮，需要秀出不同的Fragment。<br>具体怎么实现，请参考下面的代码：<br><a href="https://github.com/li2/Update_Replace_Fragment_In_ViewPager/blob/master/src/me/li2/update_replace_fragment_in_viewpager/ContainerFragment.java">github.com/li2/Update_Replace_Fragment_In_ViewPager/ContainerFragment.java</a></p>
<h2>一些误区</h2>
<p><code>ViewPager.getChildCount()</code> 返回的是当前ViewPager所管理的没有被销毁视图的Fragment，并不是所有的Fragment。想要获取所有的Fragment数量，应该调用<code>ViewPager.getAdapter().getCount()</code>.</p>
<h2>一个Demo</h2>
<p>为了总结ViewPager的用法，以及写这篇笔记，我写了一个demo，<a href="https://github.com/li2/Update_Replace_Fragment_In_ViewPager">你可以从这里获取它的源码 github.com/li2/</a></p>
<p>这一张gif图片，演示了一个包含4个Fragment的ViewPager，通过上面的date+-1 button、EditText、Checkbox来更新前3个Fragment的界面；最后一个Fragment嵌套着2个Fragment，通过ToggleButton来切换。<br><img src="http://7xljdj.com1.z0.glb.clouddn.com/update_fragment_in_viewpager_demo.gif" alt="image-update_fragment_in_viewpager_demo" title="image-update_fragment_in_viewpager_demo"></p>
<p>这一张gif演示了切换ViewPager页以及更新Fragment时，相关的方法调用。通过一个ScrollView和TextView展示出来。<br><img src="http://7xljdj.com1.z0.glb.clouddn.com/update_fragment_in_viewpager_log.gif" alt="image-update_fragment_in_viewpager_withlog" title="image-update_fragment_in_viewpager_withlog"></p>
<h1>参考</h1>
<ul>
<li><p><a href="http://www.cnblogs.com/dancefire/archive/2013/01/02/why-notifydatasetchanged-does-not-work.html">为什么调用 FragmentPagerAdapter.notifyDataSetChanged() 并不能更新其 Fragment？ - Dancefire</a><br><strong>这篇博文详细地解释了notifyDataSetChanged不能更新Fragment的原因，非常好。</strong></p></li>
<li><p><a href="http://stackoverflow.com/a/18088509/2722270">android - Update Fragment from ViewPager - Stack Overflow</a><br><strong>这个stackoverflow问答给出了两种更新Fragment的方法，非常好。</strong></p></li>
<li><p><a href="http://android.amberfog.com/?p=296">HowTo: ListView, Adapter, getView and different list items’ layouts in one ListView | Android Tales</a><br><strong>这篇博文详细地解释了ListView和它的Adapter是如何配合工作的，以及实现不同的listitem layout. 非常好。</strong></p></li>
<li><p><a href="http://stackoverflow.com/questions/8785221/retrieve-a-fragment-from-a-viewpager">android - R etrieve a fragment from ViewPager - Stack Overflow</a><br>这个statckoverflow问答讨论怎样从ViewPager中获取一个Fragment，但我目前还不知道拿到Fragment要做什么。</p></li>
<li><p><a href="http://blog.csdn.net/niu_gao/article/details/7172483">android Fragments详解四:管理fragment - nkmnkm的csdn博客</a><br>这是一篇翻译文章。</p></li>
<li><p>这些博文、问答的思路类似，讨论Fragment的tag，通过一个list&lt;String&gt; 存储所有Fragment的tag，然后再adapter里通过fm.findFragmentByTag获取Fragment，然后调用Fragment的update方法更新；<br>或者是通过一个list&lt;Fragment&gt;自己来管理所有的Fragment：<br><a href="http://blog.csdn.net/shadow066/article/details/17298675">ViewPager Fragment 数据更新问题 - shadow066的csnd专栏</a><br><a href="http://blog.csdn.net/leo8573/article/details/7893841">关于ViewPager的数据更新问题小结 - leo8573的csdn专栏</a><br><a href="http://www.cnphp6.com/archives/61068">Viewpager+fragment数据更新问题解析 | 姜糖水</a><br><a href="http://stackoverflow.com/questions/14035090/how-to-get-existing-fragments-when-using-fragmentpageradapter">android - How to get existing fragments when using FragmentPagerAdapter - Stack Overflow</a><br><a href="http://stackoverflow.com/questions/8785221/retrieve-a-fragment-from-a-viewpager">android - Retrieve a Fragment from a ViewPager - Stack Overflow</a><br>[android - support FragmentPagerAdapter holds reference to old fragments - Stack Overflow](<br><a href="http://stackoverflow.com/questions/9727173/support-fragmentpageradapter-holds-reference-to-old-fragments/9745935#9745935)">http://stackoverflow.com/questions/9727173/support-fragmentpageradapter-holds-reference-to-old-fragments/9745935#9745935)</a><br><strong>其中，这个问题的答案解释的特别好：However, the ones that are added to the fragment manager now are NOT the ones you have in your fragments list in your Activity. 企图这样更新界面是行不通的</strong>：<code>pagerAdapter.getItem(1)).update(id, name)</code></p></li>
<li><p><a href="http://stackoverflow.com/questions/7700226/display-fragment-viewpager-within-a-fragment">android - Display fragment viewpager within a fragment - Stack Overflow</a><br>Fragment里有一个ViewPager，ViewPager里有多个Fragment.</p></li>
<li><p>这些是<strong>Android Fragment相关的源码文件</strong>：<br><a href="http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/">Android源码仓库</a><br><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/Fragment.java">android.support.v4.app.Fragment</a><br><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/view/PagerAdapter.java">android.support.v4.view.PagerAdapter</a><br><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentPagerAdapter.java">android.support.v4.app.FragmentPagerAdapter</a><br><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentStatePagerAdapter.java">android.support.v4.app.FragmentStatePagerAdapter</a></p></li>
</ul>
<h1>关于作者</h1>
<p>Copyright (C) 2015 WeiYi Li (li21)    weiyi.just2@gmail.com    li2.me<br><strong>特别声明：禁止转载</strong></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003742057";}i:43;a:11:{s:5:"title";s:37:"javascript函数式编程入门小结";s:4:"link";s:42:"http://segmentfault.com/a/1190000003741941";s:2:"id";s:42:"http://segmentfault.com/a/1190000003741941";s:7:"updated";s:25:"2015-09-13T16:49:29+08:00";s:9:"published";s:25:"2015-09-13T16:49:29+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"zhouyg";s:10:"author_uri";s:35:"http://segmentfault.com/u/haraldred";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:5227:"
<h2>前言</h2>
<p>最近花了不少时间接触学习javascript的函数式的编程方式，而后为了加深理解，又去折腾haskell。</p>
<p>不同于人们比较熟悉的命令式编程，如面向对象编程（oop），函数式编程（fp）是一种更加抽象，更加‘数学’的编程方式。<br>当然，也是一种更加‘痛苦’的编程方式，尤其是刚接触时，总是难以摆脱的命令式的思维方式，大脑回路总是会迷路。<br>不过幸运的是，javascript天生具备了函数式编程的基本元素，所以学习的起点不会太低。</p>
<h2>初接触</h2>
<p>第一个实例，函数式编程是如何做一个番茄炒鸡蛋的。<br>伪代码，对比oop：</p>
<pre><code>Class Chef{
  cook(m1,m2){
    return m1+m2
  }
}
chef = new Chef
food = chef.cook('番茄','鸡蛋')
food //番茄炒蛋。</code></pre>
<p>fp的方式</p>
<pre><code>getMaterial(m){
  return function(){
    return m
  }
}
cook(getM1,getM2){
  return getM1()+getM2()
}
food = cook(getMaterial('番茄'),getMaterial('鸡蛋'));
food //番茄炒蛋</code></pre>
<p>那么现在，站在内存（拟作：你）变化的角度上，这两者的区别之处。<br>oop</p>
<pre><code>1.你面前出现了一个厨师

2.你前面出现了番茄，鸡蛋

3.厨师把番茄和鸡蛋炒在一起

4.厨师把番茄炒蛋装在盘子上

4.你获得了番茄炒蛋</code></pre>
<p>fp</p>
<pre><code>1.你拿一个空盘子，你决定弄点东西在上面

2.你面前出现了一个传说中的厨具。 //没错！小当家同款厨具，只要丢材料进去，它就能弄出美味佳肴！

3.你虽然没有材料，但幸运的是，你有两张藏宝图，分别标示了番茄和鸡蛋的位置。通过藏宝图，就能找到所需的材料。

4.你把两张藏宝图扔到厨具里，告诉它，它得自己去找材料。 //传说中的厨具就是这么牛逼!

5.厨具获得了番茄

6.厨具获得了鸡蛋

7.厨具终于炒了番茄和鸡蛋

7.finally,你获得了番茄炒蛋</code></pre>
<p>对比一下这个过程，可以发现：</p>
<p>oop方式总是是在告诉系统，第一步应该干什么（搞个厨师）然后干什么（弄到番茄和鸡蛋）、按部就班，最后你就能得到想要的值（番茄炒蛋）。</p>
<p>fp方式呢，恰恰相反，它是惰性的。只有你需要什么的时候，函数才会运算，才会返回数值，而不是一开始就存在的。</p>
<p>就好像学渣考90分，是因为在考试之前，他努力学习，到了90分。<br>这是结果。<br>而学霸考90分，只是因为考试的时候，做到90分时，懒癌发作，不想做题了。<br>这是过程。</p>
<h2>fp的特性</h2>
<p>这里列举了当前接触到fp中编程思想中的几个重要特性</p>
<p>1.不可变数据<br>  2.函数是一等公民，即能作为参数，也可以是返回值<br>  3.惰性求值</p>
<h3>1.不可变数据</h3>
<p>由于fp中都是函数，为了保证程序的可靠性，同样的参数，传入同一套的函数中，必须保证结果也是一样的。如：</p>
<pre><code>let o = {name:'zhouyg'};
r1 = fn1(fn2(fn3(o)))
r2 = fn1(fn2(fn3(o)))
r1 === r2 //true</code></pre>
<p>在javascript中的由于Array和Object的类型都是引用传递的。如果在函数内部改变了改变了原始o的值，那么改变了原始o的值，那么必然导致r1和r2的结果不一样。导致程序不可靠，不可维护。<br>这是javascript的特性引起的，需要额外的手段补救。</p>
<blockquote><p>每次传递Object和Array时候，都做一个拷贝，使用拷贝后的对象作为函数参数</p></blockquote>
<p>或者使用某些数据结构工具，例如F家著名的<a href="https://github.com/facebook/immutable-js">immutable.js</a></p>
<h3>2.函数是一等公民</h3>
<p>javascript天然满足，常见的各种回调。</p>
<h3>3.惰性求值</h3>
<p>顾名思义，只有在需要用到的才去计算。这里强行设定一种情景，如一个加法函数:<br>没有惰性求值</p>
<pre><code>function add(n1,n2){
  if(n1&lt;5){
    return n1
  }else{
    return n1+n2
  }
}
result = add(add(1,2),add(3,4)) //相当于add(3,4)的计算是浪费的。
result//3</code></pre>
<p>惰性求值</p>
<pre><code>function add(n1,n2){
  return n1+n2;
}
function preAdd(n1,n2){
  return function(){
    return add(n1,n2)
  }
}
function doAdd(fn1,fn2){
  n = fn1()
  if(n&lt;5){
    return n     //只需要运行fn1，得到一个计算结果即可。
  }else{
    return add(fn1,fn2())
  }
}
result = doAdd(preAdd(1,2),preAdd(3,4))
result//10</code></pre>
<p>对比一下可知，在javascript中的惰性求值，相当于先把参数先缓存着，return一个真正执行的计算的函数，等到需要结果采去执行。<br>这样的好处在于比较节省计算，尤其有时候这个在函数是不一定需要这个参数的时候。</p>
<h2>最后</h2>
<p>这里只是简单的回溯最近学习的fp的相关内容。并不是为了比较fp方式和其它编程方式的优劣，而是希望能够站在另外的一个角度，活跃大脑的思维，开拓视野，以更丰富的姿势来解决问题，毕竟俗话说得好，姿势就是力量。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003741941";}i:44;a:11:{s:5:"title";s:35:"js对象创建方法汇总及对比";s:4:"link";s:42:"http://segmentfault.com/a/1190000003741873";s:2:"id";s:42:"http://segmentfault.com/a/1190000003741873";s:7:"updated";s:25:"2015-09-13T16:21:27+08:00";s:9:"published";s:25:"2015-09-13T16:21:27+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:6:"xuehen";s:10:"author_uri";s:37:"http://segmentfault.com/u/xuehen_2015";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:5239:"
<p>js中创建对象的方式有很多，尤其是基于原型的方式创建对象，是理解基于原型继承的基础。因此在这里汇总一下，并对各种方法的利弊进行总结和对比，不至于以后对这些概念有模糊。</p>
<h2>简单方式创建</h2>
<pre><code>var o = new Object();</code></pre>
<p>我们都知道，实际上在javascript中并没有所谓的类的概念。因此在创建对象时不能像面向对象语言那样，通过类A new出来一个a对象。但是javascript有一个特殊的Object。我们可以借助Object来new一个对象。<br>然后可以通过如下方式给对象增加属性或方法：</p>
<pre><code>    o.name="abc";</code></pre>
<p>但是因为没有类的约束，这种方式创建出来的对象无法实现对象的重复利用，并且没有一种固定的约数，操作起来可能会出现这样或者那样的意想不到的问题。<br>有这样一个例子：</p>
<pre><code>    var a = new Object;  
    var b = new Object;  
    var c = new Object;  
    c[a]=a;  
    c[b]=b;  
    alert(c[a]===a); //输出什么</code></pre>
<p>关于这个例子的具体解答详见 <a href="http://driftcloudy.iteye.com/blog/949318">例子出处</a></p>
<h2>工厂方法创建</h2>
<p>直接看一个例子：</p>
<pre><code>    function createPerson(){
        var o = new Object();
        o.name = "abc";
        o.age = 20;
        return o;    
    }</code></pre>
<p>这种创建对象的方法是在一个function中new Object()，并且赋予属性和方法,最后return 带有这些属性和方法的对象。</p>
<p>但是当我们想通过</p>
<pre><code>    var p1 = createPerson();
    alert(typeof(p1));//Object 仅能得到这个结果，实际上没有太大意义
    alert(p1 instanceof(类名？？？))//会发现其实并不存在一个Person类</code></pre>
<h2>构造函数的方式</h2>
<pre><code>    function Person(name,age){
        this.name = name;
        this.age = age;
        this.say = function(){
            //
        }
    }
    
    var p1 = new Person('abc',20);</code></pre>
<p>构造函数的方式创建的对象:</p>
<ul>
<li><p>函数名即为类名</p></li>
<li><p>通过this来定义属性</p></li>
<li><p>通过new Person()创建对象</p></li>
<li><p>并且有如下属性：</p></li>
</ul>
<pre><code>    alert(typeof(p1));// Person
    alert(p1 instanceof(Person));// true</code></pre>
<ul><li>
<p>但是同时我们也发现这种方式创建对象的一个弊端。对于类中的say方法，每分配一个对象就会有一个say的内存空间被分配出来。有一个say的拷贝。如果方法特别多的时候，会造成内存空间的极大浪费。可以通过两种方式进行优化和改进：</p>
<ul>
<li>
<p>将say声明为全局的</p>
<pre><code>    function say(){
    
    }</code></pre>
<p>然后在类的定义中通过：</p>
<pre><code>    this.say = say;</code></pre>
</li>
<li><p>采用下面提到的基于原型的方式创建对象</p></li>
</ul>
</li></ul>
<p>让类中的行为统一指向全局的say方法。但是如果将所有的方法设为全局的时候，就可以被window对象调用，那么就破坏了对象的封装性；如果方法很多，会造成代码中充斥着大量的全局函数。</p>
<h2>基于原型创建对象</h2>
<pre><code>    function Person(){
        
    }
    Person.prototype.name = "abc";
    Person.prototype.age= 20;
    Person.prototype.say= function(){
        alert(this.name+this.age);
    }
    
    
    var p1 = new Person();
    p1.say();//ok
    say();//no 完成了封装
    </code></pre>
<p>原型是js中的一个特殊对象。当一个函数创建之后，会随之产生一个原型对象。该函数中的prototype属性指向该源性对象；<br>当通过该函数的构造函数创建一个具体对象时，在这个对象中，就会有一个_prop_属性指向原型。这些是js中的很重要的一种继承方式--基于原型的继承的基础。这里不再赘述。</p>
<p>基于原型创建对象时，如果对象的属性和方法特别多时，可以通过如下方式进行定义：</p>
<pre><code>    Person.prototype = {
        name:"abc",
        age：20，
        say:function(){
        
        }
    }</code></pre>
<p>称为原型重写。原型重写之后当我们再通过 var p1 = new Person()创建一个对象时，p1 的constructor != Person()了。由于原型重写了，而且没有通过prototype指向，从而指向了Object()。<br>如果constructor比较重要，可以再json格式的定义中手动制定</p>
<pre><code>    constructor:Pserson</code></pre>
<p>关于原型重写，我画了个示意图，比较容易理解：</p>
<p><img src="/img/bVpRBO" alt="图片描述" title="图片描述"></p>
<p>p1是原型重写前声明的对象，p2是原型重写</p>
<pre><code>    Person.prototype.name = "123";</code></pre>
<p>之后的声明的对象。<br>可以看出</p>
<ul>
<li><p>constructor的指向确实没有自动变换，除非通过上述手动的方式进行修改。</p></li>
<li><p>通过p2.name = "456",设置name时，会在自己的存储空间中存储。当然查找name属性时，也是从自己的内存空间中读取name值。</p></li>
</ul>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003741873";}i:45;a:11:{s:5:"title";s:17:"Mysql日志分析";s:4:"link";s:42:"http://segmentfault.com/a/1190000003740891";s:2:"id";s:42:"http://segmentfault.com/a/1190000003740891";s:7:"updated";s:25:"2015-09-13T01:44:50+08:00";s:9:"published";s:25:"2015-09-13T01:44:50+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:12:"夏日小草";s:10:"author_uri";s:33:"http://segmentfault.com/u/xiaocao";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:12907:"
<p><img src="http://xiaocao.u.qiniudn.com/blog/logo-mysql.png" alt="mysql-log" title="mysql-log"></p>
<p><br></p>
<h1>0x01.About</h1>
<p>MySQL有四种类型的日志：Error Log、General Query Log、Binary Log 和 Slow Query Log。</p>
<p>第一种错误日志，记录MySQL运行过程ERROR,WARNING,NOTE等信息，系统出错或者某条记录出问题可以查看ERROR日志。</p>
<p>第二种日常运行日志，记录MySQL运行中的每条请求数据。</p>
<p>第三种二进制日志，包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，也包括一些潜在改动，主要用于备份恢复、回滚等操作。</p>
<p>第四种慢查询日志，用于MySQL性能调优。</p>
<p><br></p>
<hr>
<h1>0x02.Error Log</h1>
<p>MySQL错误日志默认以<code>hostname.err</code>存放在MySQL日志目录，如果不知道MySQL当前的错误日志目录可以使用查询语句：</p>
<blockquote><p>mysql&gt;  show variables like 'log_error';</p></blockquote>
<pre><code>+---------------+--------------------------------------+
| Variable_name | Value                                |
+---------------+--------------------------------------+
| log_error     | /usr/local/var/mysql/mysql-error.log |
+---------------+--------------------------------------+</code></pre>
<p>修改错误日志地址可以在<code>/etc/my.cnf</code>中添加<code>--log-error[=file_name]</code>选项来开启mysql错误日志。</p>
<p>错误日志记录了MySQL Server每次启动和关闭的详细信息以及运行过程中所有较为严重的警告和错误信息。</p>
<p>知道了MySQL错误日志地址，我们就可以查看MySQL错误日志：</p>
<pre><code>2015-09-12 16:03:20 2624 [ERROR] InnoDB: Unable to lock ./ibdata1, error: 35
2015-09-12 16:03:20 2624 [Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.
2015-09-13 00:03:21 2183 [Note] InnoDB: Shutdown completed; log sequence number 426783897</code></pre>
<p><code>InnoDB: Unable to lock ./ibdata1, error: 35</code> 可以得出资源被抢占，有可能是开了多个MySQL线程。</p>
<p><br></p>
<hr>
<h1>0x03.General Query Log</h1>
<p>日常请求的SQL：<br>添加方式一样在 <code>/etc/my.cnf</code> 中添加 <code>general-log-file[=file_name]</code>。</p>
<p><br></p>
<hr>
<h1>0x04.Binary Log</h1>
<h2>启用Binlog</h2>
<p>修改 <code>/etc/my.cnf</code>：</p>
<pre><code>binlog_format = STATEMENT
binlog_cache_size = 2M
max_binlog_cache_size = 4M
max_binlog_size = 512M
log-bin = master-bin
log-bin-index = master-bin.index</code></pre>
<p><code>log-bin-index</code> 指向 <code>master-bin</code> 这个文件，记录有哪些分块的Binlog文件名。<br><code>log-bin</code> 记录Binlog文件名前缀，后缀会用数字递增。</p>
<h2>Binlog格式</h2>
<p>Binlog有3种格式，STATMENT,ROW,MIXED。<a href="https://dev.mysql.com/doc/refman/5.1/en/binary-log-mixed.html"></a><a href="https://dev.mysql.com/doc/refman/5.1/en/binary-log-mixed.html">https://dev.mysql.com/doc/refman/5.1/en/binary-log-mixed.html</a></p>
<p>混合格式（mixed）会在适当时候切换row和statment格式，statment就是直接的SQL语句格式。</p>
<h2>分析Binlog</h2>
<p>通过MySQL自带的mysqlbinlog 命令，可以直接查看到Binlog转码数据：</p>
<blockquote><p>mysqlbinlog /usr/local/var/mysql/master-bin.000117</p></blockquote>
<p>得到：</p>
<pre><code># at 335
#150913  0:05:12 server id 1  end_log_pos 366 CRC32 0xa31b50db     Xid = 151
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</code></pre>
<p>第一行包含日志文件偏移字节值（335）。</p>
<p>第二行包含：</p>
<ul>
<li><p>事件的日期事件，MySQL会使用他们来产生SET TIMESTAMP</p></li>
<li><p>服务器的服务器id</p></li>
<li><p>end_log_pos 下一个事件的偏移字节</p></li>
<li><p>事件类型，这里是Xid，常见的还有其他，例如：Intvar，Query，Stop，Format_desc</p></li>
<li><p>原服务器上执行语句的线程id，用于审计和CONNECTION_ID()</p></li>
<li><p>exec_time对于master端的Binlog来说是执行这个event所花费的时间</p></li>
<li><p>原服务器产生的错误代码</p></li>
</ul>
<p>通过</p>
<blockquote><p>mysql&gt; show binlog events;</p></blockquote>
<p>也可以的到binlog数据：</p>
<pre><code>| master-bin.000002 | 3861 | Query       |         1 |        3954 | BEGIN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| master-bin.000002 | 3954 | Intvar      |         1 |        3986 | INSERT_ID=5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| master-bin.000002 | 3986 | Query       |         1 |        4475 | use `dropbox`; INSERT INTO `UserLog` (`uid`, `fids`, `nids`, `msg`, `log`, `from`, `type`, `ctime`) VALUES ('1', '[\"35\",\"33\",\"21\"]', '[\"22\",\"21\",\"11\",\"4\",\"3\"]', '从垃圾箱恢复: 恢复文件 \'[\"35\",\"33\",\"21\"]\' 恢复文件夹 \'[\"22\",\"21\",\"11\",\"4\",\"3\"]\'', '[[\"35\",\"33\",\"21\"],[\"22\",\"21\",\"11\",\"4\",\"3\"]]', 'cloud.jue.so', 'recover_by_trash', '2015-09-07 00:51:31')                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| master-bin.000002 | 4475 | Xid         |         1 |        4506 | COMMIT /* xid=423 */</code></pre>
<h2>查看Binlog信息</h2>
<blockquote><p>mysql&gt; show variables like '%binlog%';</p></blockquote>
<pre><code>+-----------------------------------------+----------------------+
| Variable_name                           | Value                |
+-----------------------------------------+----------------------+
| binlog_cache_size                       | 2097152              |
| binlog_checksum                         | CRC32                |
| binlog_direct_non_transactional_updates | OFF                  |
| binlog_error_action                     | IGNORE_ERROR         |
| binlog_format                           | STATEMENT            |
| binlog_gtid_simple_recovery             | OFF                  |
| binlog_max_flush_queue_time             | 0                    |
| binlog_order_commits                    | ON                   |
| binlog_rows_query_log_events            | OFF                  |
| binlog_stmt_cache_size                  | 32768                |
| binlogging_impossible_mode              | IGNORE_ERROR         |
| innodb_api_enable_binlog                | OFF                  |
| innodb_locks_unsafe_for_binlog          | OFF                  |
| max_binlog_cache_size                   | 4194304              |
| max_binlog_size                         | 536870912            |
| max_binlog_stmt_cache_size              | 18446744073709547520 |
| simplified_binlog_gtid_recovery         | OFF                  |
+-----------------------------------------+----------------------+</code></pre>
<p><br></p>
<hr>
<h1>Slow Query Log</h1>
<h2>开启 Slow Query</h2>
<p>修改<code>/etc/my.cnf</code>：</p>
<pre><code>slow-query-log = 1
slow-query-log-file = /usr/loval/var/mysql/mysql-slow.log
long_query_time = 1 #设置满请求时间
log-queries-not-using-indexes</code></pre>
<h2>Slow Query工具</h2>
<p>Slow Query有很多查看工具，比如：MySQL自带的mysqldumpslow 和 mysqlsla，用的比较多的 py-query-digest，还可以将满请求数据丢给zabbix做显示分析处理。</p>
<p>这里我用 <code>py-query-digest /usr/local/var/mysql/mysql-slow.log</code> 导出了满请求的数据，例如：</p>
<pre><code># Query 1: 0.02 QPS, 0.55x concurrency, ID 0xFC19E4D04D8E60BF at byte 12547
# This item is included in the report because it matches --limit.
# Scores: V/M = 118.26
# Time range: 2015-09-12 05:52:03 to 05:57:54
# Attribute    pct   total     min     max     avg     95%  stddev  median
# ============ === ======= ======= ======= ======= ======= ======= =======
# Count          1       7
# Exec time     78    194s   250ms    169s     28s    167s     57s   992ms
# Lock time      0   901us   111us   158us   128us   152us    18us   119us
# Rows sent      0       5       0       1    0.71    0.99    0.45    0.99
# Rows examine   7 545.01k  14.18k  97.66k  77.86k  97.04k  32.08k  97.04k
# Query size     0     868     123     125     124  124.25       1  118.34
# String:
# Databases    mysqltest
# Hosts        localhost
# Users        root
# Query_time distribution
#   1us
#  10us
# 100us
#   1ms
#  10ms
# 100ms  ################################################################
#    1s  ##########################################
#  10s+  ##########################################
# Tables
#    SHOW TABLE STATUS FROM `mysqltest` LIKE 'File'\G
#    SHOW CREATE TABLE `mysqltest`.`File`\G
#    SHOW TABLE STATUS FROM `mysqltest` LIKE 'User'\G
#    SHOW CREATE TABLE `mysqltest`.`User`\G
# EXPLAIN /*!50100 PARTITIONS*/
SELECT count(*) FROM `File` LEFT JOIN `User` ON `User`.`name`= `File`.`name` WHERE `User`.`name` LIKE '%r%' order by `last`\G</code></pre>
<p>可以看到该SQL被调用7次，平均每次28s，好慢...平均检测数据大小77.86k。</p>
<p>再来看看SQL语句：</p>
<blockquote><p>SELECT count(*) FROM <code>File</code> LEFT JOIN <code>User</code> ON <code>User</code>.<code>name</code>= <code>File</code>.<code>name</code> WHERE <code>User</code>.<code>name</code> LIKE '%r%' order by last</p></blockquote>
<p>看着都觉得慢 <code>ON User.name= File.name</code> 在没有建立索引的情况下，所有数据将进行字符串匹配name字段。</p>
<p>这个库有 15W条User数据，10W条File数据，也就是要比对15*10 WW 次数据。</p>
<p>MySQL的slow log的作用也就在这里了，优化慢查询。</p>
<p><br></p>
<hr>
<h2>参考：</h2>
<p>1.《高性能MySQL》</p>
<p>2.(Analyse slow-query-log using mysqldumpslow &amp; pt-query-digest)[<a href="https://rtcamp.com/tutorials/mysql/slow-query-log/">https://rtcamp.com/tutorials/mysql/slow-query-log/</a>]</p>
<p>3.<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;mid=210390215&amp;idx=1&amp;sn=c19ae436ff78a9ab79b1abb758242e9f&amp;scene=1&amp;srcid=DwbZiaiebW46zADnAG06&amp;key=dffc561732c226514afb61cf0568d83ae54cbe7903c2454bb586d31b3d549f1364f16f9f322fde5b24cf7c777f9777d3&amp;ascene=0&amp;uin=NDI0ODQwODk1&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.10.5+build(14F27">初探：MySQL 的 Binlog</a>&amp;version=11020201&amp;pass_ticket=DNtPK7ePVYl93tx1FiRMBNsJMm3DEgwRdO1XEZUustRXuYf6KyUU4gID1Lv7aVTB)</p>
<p><br></p>
<h4>本文出自 <a href="http://homeway.me">夏日小草</a>,转载请注明出处:<a href="http://homeway.me/2015/09/12/mysql-log"></a><a href="http://homeway.me/2015/09/12/mysql-log">http://homeway.me/2015/09/12/mysql-log</a>
</h4>
<p>-by小草</p>
<p>2015-09-12 01:49:10</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003740891";}i:46;a:11:{s:5:"title";s:72:"[译]使用 Postgres 递归公共表表达式解决旅行销售员问题";s:4:"link";s:42:"http://segmentfault.com/a/1190000003739666";s:2:"id";s:42:"http://segmentfault.com/a/1190000003739666";s:7:"updated";s:25:"2015-09-12T16:58:42+08:00";s:9:"published";s:25:"2015-09-12T16:58:42+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:9:"halfcoder";s:10:"author_uri";s:35:"http://segmentfault.com/u/halfcoder";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:14070:"
<blockquote><p>原文：<a href="https://www.periscope.io/blog/postgres-recursive-cte.html">Solving the Traveling Salesman Problem with Postgres Recursive CTEs</a></p></blockquote>
<p>Many SQL implementations don't have loops, making some kinds of analysis very difficult. Postgres, SQL Server, and several others have the next best thing — recursive CTEs!</p>
<p>许多 SQL 实现没有将循环包括在内，使进行一些分析工作变得很困难。Postgres、SQL Server 以及一些其它的 SQL 实现则提供了下面将要提到的优良特性：递归公共表表达式（recursive CTE）。</p>
<p>We'll use them to solve the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman Problem</a> and find the shortest round-trip route through several US cities.</p>
<p>我们将使用它们来解决旅行销售员问题（<a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman Problem</a> ）并且找出经过若干美国城市的最短巡回路径。</p>
<p><img src="/img/bVpQOa" alt="//s3.amazonaws.com/periscope-blog-assets/postgres-ctes/map.png" title="//s3.amazonaws.com/periscope-blog-assets/postgres-ctes/map.png"></p>
<h3>使用递归</h3>
<p>Normal CTEs are great at helping to organize large queries. They are a simple way to make temporary tables you can access later in your query.</p>
<p>一般的公共表表达式（CTE）主要用于帮助组织大型查询语句。你可以简便地创建临时表，并在稍后的查询语句中访问它们。</p>
<p><a href="http://www.postgresql.org/docs/8.4/static/queries-with.html">Recursive CTEs</a> are more powerful - they reference themselves and allow you to explore hierarchical data. While that may sound complicated, the underlying concept is very similar to a <code>for</code> loop in other programming languages.</p>
<p>递归公共表表达式（<a href="http://www.postgresql.org/docs/8.4/static/queries-with.html">Recursive CTEs</a>）的能力更强——它们通过自引用，使你能够探索层次化的数据。虽然这听起来很复杂，但其背后的概念和其它编程语言中的 <code>for</code> 循环十分相似。 </p>
<p>These CTEs have two parts — an <code>anchor</code> member and a <code>recursive</code> member. The <code>anchor</code> member selects the starting rows for the recursive steps.</p>
<p>该公共表表达式（CTE）包含两个部分——一个 <strong>anchor</strong> 部分和一个 <strong>recursive</strong> 部分。 <strong>anchor</strong> 部分提供了递归步骤的起始数据。</p>
<p>The <code>recursive</code> member generates more rows for the CTE by first joining against the <code>anchor</code> rows, and then joining against rows created in previous recursions. The <code>recursive</code> member comes after a <code>union all</code> in the CTE definition.</p>
<p><strong>recursive</strong> 部分为此公共表表达式（CTE）生成更多的数据，方法是先连接（join） <strong>anchor</strong> 数据，然后连接（join）上次递归产生的数据。在公共表表达式（CTE）的定义语句中，<strong>recursive</strong> 部分接在 <code>union all</code> 关键字后面。</p>
<p>Here's a simple recursive CTE that generates the numbers 1 to 10. The <code>anchor</code> member selects the value 1, and the <code>recursive</code> member adds to it up to the number 10:</p>
<p>这是一个能产生数字1到10的简单的递归公共表表达式（CTE）。其中 <strong>anchor</strong> 部分提供了数据值1，然后 <strong>recursive</strong> 部分将其逐步累加至10。</p>
<pre><code class="sql">with recursive incrementer(prev_val) as (
  select 1 -- anchor member
  union all
  select -- recursive member
    incrementer.prev_val + 1
  from incrementer
  where prev_val &lt; 10 -- termination condition
)

select * from incrementer</code></pre>
<p>The first time the recursive CTE runs it generates a single row <code>1</code> using the <code>anchor</code> member. In the second execution, the <code>recursive</code> member joins against the <code>1</code> and outputs a second row, <code>2</code>. In the third execution the <code>recursive</code> step joins against both rows <code>1</code> and <code>2</code> and adds the rows <code>2</code> (a duplicate) and <code>3</code>.</p>
<p>该递归公共表表达式（recursive CTE）在第一次执行的时候根据 <strong>anchor</strong> 部分生成了一行数据“1”。在第二次执行中， <strong>recursive</strong> 部分连接到数据“1”并输出了第二行“2”。在第三次执行中，<strong>recursive</strong> 部分同时连接到了数据“1”和“2”并且添加了新数据“2”（重复）和“3”。</p>
<p>Recursive CTEs also only return distinct rows. Even though our CTE above creates many rows with the same value, only a distinct set of rows will be returned.</p>
<p>同时递归公共表表达式（recursive CTE）只返回互不相同的数据。虽然我们的公共表表达式（CTE）创建了许多相同的数据行，但返回的数据集只包含互不相同的数据。</p>
<p>Notice how the CTE specifies its output as the named value <code>prev_val</code>. This lets us refer to the output of the previous recursive step.</p>
<p>注意该公共表表达式（CTE）是如何将其输出命名为 <code>prev_val</code> 的。这使得我们可以引用上一次递归的输出结果。</p>
<p>And at the very end there is a termination condition to halt the recursion once the sum gets to 10. Without this condition, the CTE would enter an infinite loop!</p>
<p>并且在最后的最后有一个终止条件：一旦 sum 到达10就停止递归。如果没有这个条件，该公共表表达式（CTE）将会进入一个无限循环！</p>
<p>Under the hood, the database is building up a table named after this recursive CTE using unions:</p>
<p>这样，数据库以该递归公共表表达式（recursive CTE）为名字，基于并集建立了一个数据表：</p>
<p><img src="/img/bVpQOi" alt="//s3.amazonaws.com/periscope-blog-assets/postgres-ctes/incrementer.png" title="//s3.amazonaws.com/periscope-blog-assets/postgres-ctes/incrementer.png"></p>
<p>Recursive CTEs can also have many parameters. Here's one that takes the sum, double, and square of starting values of 1, 2 and 3:</p>
<p>递归公共表表达式（recursive CTE）还可以包含多个参数。下面的例子以1、2和3为初始值，分别计算了依次加1的和、倍增值和依次平方的值。</p>
<pre><code class="sql">with recursive cruncher(inc, double, square) as (
  select 1, 2.0, 3.0 -- anchor member
  union all
  select -- recursive member
    cruncher.inc + 1,
    cruncher.double * 2,
    cruncher.square ^ 2
  from cruncher
  where inc &lt; 10
)

select * from cruncher</code></pre>
<p>With recursive CTEs we can solve the Traveling Salesman Problem.</p>
<p>通过使用递归公共表表达式（recursive CTE），我们能够解决旅行销售员问题。</p>
<h3>找出最短路径</h3>
<p>There are many algorithms for finding the shortest round-trip path through several cities. We'll use the simplest: brute force. Our recursive CTE will enumerate all possible routes and their total distances. We'll then sort to find the shortest.</p>
<p>有许多算法可以用于找出经过若干城市的最短巡回路径。我们将使用最简单的一种：暴力搜索。我们的递归公共表表达式（recursive CTE）将枚举所有可能的路径和它们的总距离，然后排序以找出最短的一条。</p>
<p>First, a list of cities with Periscope customers, along with their latitudes and longitudes:</p>
<p>首先是一个顾客所在城市的列表，包含它们的纬度和经度。</p>
<pre><code class="sql">create table places as (
  select
    'Seattle' as name, 47.6097 as lat, 122.3331 as lon
    union all select 'San Francisco', 37.7833, 122.4167
    union all select 'Austin', 30.2500, 97.7500
    union all select 'New York', 40.7127, 74.0059
    union all select 'Boston', 42.3601, 71.0589
    union all select 'Chicago', 41.8369, 87.6847
    union all select 'Los Angeles', 34.0500, 118.2500
    union all select 'Denver', 39.7392, 104.9903
)</code></pre>
<p>And we'll need a distance function to compute how far two lat/lons are from each other (thanks to <a href="http://stackoverflow.com/questions/10034636/postgres-longitude-longitude-query">strkol on stackoverflow.com</a>):</p>
<p>然后我们需要一个距离函数来计算两个经纬度之间的距离（<a href="http://stackoverflow.com/questions/10034636/postgres-longitude-longitude-query">感谢 strkol 在 stackoverflow.com 上的回答</a>）：</p>
<pre><code class="sql">create or replace function lat_lon_distance(
  lat1 float, lon1 float, lat2 float, lon2 float
) returns float as $$
declare
  x float = 69.1 * (lat2 - lat1);
  y float = 69.1 * (lon2 - lon1) * cos(lat1 / 57.3);
begin
  return sqrt(x * x + y * y);
end
$$ language plpgsql</code></pre>
<p>Our CTE will use San Francisco as its anchor city, and then recurse from there to every other city:</p>
<p>我们的公共表表达式（CTE）将使用 San Francisco 作为出发城市，然后从那开始递归抵达其它城市。</p>
<pre><code class="sql">with recursive travel(places_chain, last_lat, last_lon,
    total_distance, num_places) as (
  select -- anchor member
    name, lat, lon, 0::float, 1
    from places
    where name = 'San Francisco'
  union all
  select -- recursive member
    -- add to the current places_chain
    travel.places_chain || ' -&gt; ' || places.name,
    places.lat,
    places.lon,
    -- add to the current total_distance
    travel.total_distance + 
      lat_lon_distance(last_lat, last_lon, places.lat, places.lon),
    travel.num_places + 1
  from
    places, travel
  where
    position(places.name in travel.places_chain) = 0
)</code></pre>
<p>The parameters in the CTE are:</p>
<ul>
<li><p><code>places_chain</code>: The list of places visited so far, which will be different for each instance of the recursion</p></li>
<li><p><code>last_lat and last_lon</code>: The latitude and longitude of the last place in the <code>places_chain</code></p></li>
<li><p><code>total_distance</code>: The distance traveled going from one place to the next in the <code>places_chain</code></p></li>
<li><p><code>num_places</code>: The number of places in <code>places_chain</code> — we'll use this to tell which routes are complete because they visited all cities</p></li>
</ul>
<p>该公共表表达式（CTE）中的参数有：</p>
<ul>
<li><p><code>places_chain</code>：截至目前访问过的位置的列表，在每条递归路径中都是不同的</p></li>
<li><p><code>last_lat and last_lon</code>：<code>places_chain</code> 中最后一个位置的纬度和经度。</p></li>
<li><p><code>total_distance</code>：<code>places_chain</code> 中相邻位置的距离的总和</p></li>
<li><p><code>num_places</code>：<code>places_chain</code> 中位置的数目——我们使用该参数来分辨哪条路径已经完成，由其访问过了所有城市</p></li>
</ul>
<p>In the <code>recursive</code> member, the <code>where</code> clause ensures that we never repeat a place. If we've already visited Denver, <code>position(...)</code> will return a number greater than 0, invalidating this instance of the recursion.</p>
<p>在 <code>recursive</code> 部分中，<code>where</code> 子句确保了我们不会重复访问一个地方。（比如说）如果我们已经访问过 Denver，<code>position(...)</code> 将返回一个大于0的数字，使得该递归路径无效化。</p>
<p>We can see all possible routes by selecting all 8-city chains:</p>
<p>通过列出所有包含了8个城市的城市链，我们可以看到所有可能的路径：</p>
<pre><code class="sql">select * from travel where num_places = 8</code></pre>
<p>We need to add in the distance from the last city back to San Francisco to complete the round-trip. We could hard code San Francisco's lat/lon, but a join is more elegant. Once that's done we sort by distance and show the smallest:</p>
<p>我们需要加上从最后一个城市回到 San Francisco 的距离以完成回路。我们可以在代码中显式写入 San Francisco 的经纬度，但使用连接操作看起来更加优雅。一完成这个我们就可以根据距离进行排序并输出最短路径：</p>
<pre><code>select
  travel.places_chain || ' -&gt; ' || places.name,
  total_distance + lat_lon_distance(
      travel.last_lat, travel.last_lon,
      places.lat, places.lon) as final_dist
from travel, places
where
  travel.num_places = 8
  and places.name = 'San Francisco'
order by 2 -- ascending!
limit 1</code></pre>
<p>Even though this query is significantly more complicated than the <code>incrementer</code> query earlier, the database is doing the same things behind the scenes. The top branch is the creating the CTE's rows, the bottom branch is the final join and sort:</p>
<p>虽然该查询语句明显复杂于之前的 <code>incrementer</code> 查询，数据库在幕后做的事情依然一样。最顶上的分支是创建该公共表表达式（CTE）的数据，最底部的分支是最终的连接和排序。</p>
<p><img src="/img/bVpQOp" alt="//s3.amazonaws.com/periscope-blog-assets/postgres-ctes/postgres-cte.png" title="//s3.amazonaws.com/periscope-blog-assets/postgres-ctes/postgres-cte.png"></p>
<p>Run this query and you'll see the shortest route takes 6671 miles and visits the cities in this order:</p>
<p>执行该查询语句，你会看到最短路径需要 6671 英里并且按顺序经过了下列城市：</p>
<blockquote><p>San Francisco -&gt; Seattle -&gt; Denver -&gt;<br>Chicago -&gt; Boston -&gt; New York -&gt; Austin -&gt;<br>Los Angeles -&gt; San Francisco</p></blockquote>
<p>Thanks to recursive CTEs, we can solve the Traveling Salesman Problem in SQL!</p>
<p>得益于递归公共表表达式（recursive CTE），我们成功地用 SQL 解决了旅行销售员问题！</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003739666";}i:47;a:11:{s:5:"title";s:69:"使用git和github管理自己的项目---真实开发环境的策略";s:4:"link";s:42:"http://segmentfault.com/a/1190000003739324";s:2:"id";s:42:"http://segmentfault.com/a/1190000003739324";s:7:"updated";s:25:"2015-09-12T14:59:12+08:00";s:9:"published";s:25:"2015-09-12T14:59:12+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:8:"xumenger";s:10:"author_uri";s:34:"http://segmentfault.com/u/xumenger";s:2:"re";a:1:{s:4:"rank";s:1:"8";}s:7:"summary";s:24962:"
<p>基础知识和命令先参考：<a href="http://segmentfault.com/a/1190000003728094">使用git和github管理自己的项目---基础操作学习</a></p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000">13.分支管理策略</a></h2>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<ul>
<li><p><code>git checkout -b dev</code> 创建并切换到dev分支</p></li>
<li><p><code>vim readme.txt</code> 修改readme.txt文件</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m "add merge"</code> 提交一个新的commit</p></li>
<li><p><code>git checkout master</code> 切回master分支</p></li>
<li><p><code>git merge --no-ff -m "merge with with no-ff" dev</code> 准备合并dev分支，注意<code>--no-ff</code>参数表示禁用Fast forward，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</p></li>
<li><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 合并后查看分支历史</p></li>
</ul>
<p>合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000">14.分支策略</a></h2>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<ul>
<li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活</p></li>
<li><p>那在哪里干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如2.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发新版本</p></li>
<li><p>你和你的小伙伴每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时往<code>dev</code>分支上合并就可以了</p></li>
</ul>
<p>所以，团队合作的分支看起来就像这个样子：<br><img src="/img/bVcc7H" alt="图片描述" title="图片描述"></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000">15.Bug分支</a></h2>
<p>软件开发中，bug就像是家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你街道一个修复代号为101的bug的任务的时候，很自然的，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<ul><li><p><code>git status</code> 查看状态</p></li></ul>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<ul>
<li><p><code>git stash</code> 用该命令查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心的创建分支来修复bug了。</p></li>
<li><p><code>git checkout master</code> 从dev分支切换回master</p></li>
<li><p><code>git checkout -b issue-101</code>  假定需要在master分支上修复，就从<code>master</code>创建临时分支</p></li>
<li><p>假设现在修复好了bug，本例中，就假如在readme.txt文件中做了修改</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m "fic bug 101"</code> 修改之后提交</p></li>
<li><p><code>git checkout master</code> 从issue-101切换回master</p></li>
<li><p><code>git merge --no-ff -m "merged bug fix 101" issue-101</code> 合并分支选择不适用Fast forward模式，然后添加必要的描述信息</p></li>
<li><p><code>git branch -d issue-101</code> 删除issue-101这个临时bug修复分支</p></li>
<li><p>太棒了，bug搞定了，现在可以回到<code>dev</code>分支干活了</p></li>
<li><p><code>git checkout dev</code> 切换回dev分支</p></li>
<li><p><code>git status</code> 可以看出工作区是干净的，那么刚才的工作现场存在哪里呢？</p></li>
<li><p><code>git stash list</code> 看到工作现场还在，Git吧stash内容存在某个地方了，但是需要恢复一下</p></li>
<li><p>方法一<code>git stash apply</code>，但是回复后，stash内容并不删除，你需要使用<code>git stash drop</code>来删除</p></li>
<li><p>方法二<code>git stash pop</code>，恢复的同时也把stas内容删除了</p></li>
<li><p><code>git stash list</code> 再用git stash list查看，就看不到任何stash内容了</p></li>
<li><p>你可以多次<code>stash</code>，恢复的时候，先用<code>giit stash list</code> 查看，然后恢复指定的stash，使用如下的命令</p></li>
<li><p><code>git stash apply stash@{0}</code></p></li>
</ul>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除。</p>
<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376026233004c47f22a16d1f4fa289ce45f14bbc8f11000">16.Feature分支</a></h2>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。于是开始准备工作</p>
<ul>
<li><p><code>git checkout -b feature-vulcan</code> 在dev分支上创建并且换到feature-vulcan分支，用来开发新功能</p></li>
<li><p>假如现在经过一定的时间后，工作完成了</p></li>
<li><p><code>git add vulcan.py</code></p></li>
<li><p><code>git status</code> 查看状态</p></li>
<li><p><code>git commit -m "add feature vulcan"</code> 提交</p></li>
<li><p><code>git checkout dev</code> 切换回dev分支</p></li>
<li><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁，不要再合并了:</p></li>
<li><p><code>git branch -d feature-vulcan</code> 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p></li>
<li><p><code>git branch -D feature-vulcan</code></p></li>
</ul>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013760174128707b935b0be6fc4fc6ace66c4f15618f8d000">17.多人协作</a></h2>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p><strong>推送分支</strong></p>
<ul>
<li><p><code>git remote</code> 查看远程库的信息</p></li>
<li><p><code>git remote -v</code> 显示更为详细的信息</p></li>
<li><p><code>git push origin master</code> 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</p></li>
<li><p><code>git push origin dev</code> 也可以推送到其他的分支，比如dev分支</p></li>
<li><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p></li>
</ul>
<p><strong>抓取分支</strong></p>
<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>
<ul>
<li><p><code>git clone git@github.com:michaelliao/learngit.git</code>  现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆。</p></li>
<li><p><code>git branch</code> 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支，所以执行这条命令只能看到master分支</p></li>
<li><p><code>git checkout -b dev origin/dev</code> 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支</p></li>
<li><p><code>git commit -m "add /usr/bin/env"</code> 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。</p></li>
<li><p><code>git add hello.py</code> <code>git commit -m "add coding: utf-8"</code> <code> git push origin dev</code> 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突。</p></li>
<li><p><code>git pull</code> 解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p></li>
<li><p><code>git branch --set-upstream dev origin/dev</code> git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。</p></li>
<li><p><code>git pull</code> 再次pull，这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</p></li>
<li><p><code>git commit -m "merge &amp; fix hello.py"</code> <code>git push origin dev</code> 解决冲突后，再提交，再push</p></li>
</ul>
<p><strong>因此，多人协作的工作模式通常是这样的：</strong></p>
<ul>
<li><p>首先，可以试图用<code>git push origin branch-name</code> 推送自己的修改</p></li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并</p></li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交</p></li>
<li><p>没有冲突或者解决掉冲突之后，再用<code>git push origin branch-name</code>推送就能成功</p></li>
<li><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。<strong>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</strong></p></li>
</ul>
<h2>18.标签管理</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。<strong>所以，标签也是版本库的一个快照。</strong></p>
<p><strong>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</strong></p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376951758572072ce1dc172b4178b910d31bc7521ee4000">19.创建标签</a></h2>
<ul>
<li><p><code>git branch</code> 查看当前有哪些分支</p></li>
<li><p><code>git checkout master</code> 在Git中打标签非常简单，首先，切换到需要打标签的分支上</p></li>
<li><p><code>git tag tagnamev1.0</code> 打一个新标签</p></li>
<li><p><code>git tag</code> 查看所有标签</p></li>
<li><p>默认标签是打在最新提交的commit上的（也就是<code>HEAD</code>）。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p></li>
<li><p><code>git log --pretty=oneline --abbrev-commit</code> 方法是找到历史提交的commit id，然后打上就可以了，这时候显示了提交的历史信息 ，假如有这么一条就是你想打标签的历史commit：<code>6224937 add merge</code></p></li>
<li><p><code>git tag tagnamev2.0 6224937</code> 就可以给这次提交打标签了</p></li>
<li><p><code>git tag</code> 可以查看标签信息，注意，标签不是按时间顺序列出，而是按字母排序的</p></li>
<li><p><code>git show tagnamev2.0</code> 查看具体的某个标签的信息</p></li>
<li><p><code>git tag -a v0.1 -m "version 0.1 released" 3628164</code> 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</p></li>
<li><p><code>git show v0.1</code> 查看具体的某个标签的信息，可以看到说明文字</p></li>
<li><p><code>git tag -s v0.2 -m "signed version 0.2 released" fec145a</code> 还可以通过-s用私钥签名一个标签，签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错</p></li>
<li><p><code>git show v0.2</code>  用命令git show &lt;tagname&gt;可以看到PGP签名信息，用PGP签名的标签是不可伪造的，因为可以验证PGP签名。</p></li>
</ul>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376951885068a0ac7d81c3a64912b35a59b58a1d926b000">20.操作标签</a></h2>
<ul>
<li><p><code>git tag -d v0.1</code> 假如标签打错了，也可以删除，因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p></li>
<li><p><code>git push origin v1.0</code> 要推送某个标签到远程</p></li>
<li><p><code>git push origin --tags</code> 或者，一次性推送全部尚未推送到远程的本地标签</p></li>
<li><p><code>git tag -d v0.9</code> 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除</p></li>
<li><p><code>git push origin :refs/tags/v0.9</code> 然后，从远程删除。删除命令也是push，但是格式要注意</p></li>
</ul>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137628548491051ccfaef0ccb470894c858999603fedf000">21.使用Github</a></h2>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架。</p>
<ul>
<li><p>你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库</p></li>
<li><p><code>git clone git@github.com:yourname/bootstrap.git</code> 然后，从自己的账号下clone</p></li>
<li><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p></li>
</ul>
<p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：<br><img src="/img/bVpQU9" alt="图片描述" title="图片描述"></p>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p><strong>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</strong></p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下廖雪峰的仓库：<a href="https://github.com/michaelliao/learngit">https://github.com/michaelliao/learngit</a>，创建一个<code>your-github-id.txt</code>的文本文件，比如我的：<code>xumenger.txt</code>，写点自己学习Git的心得，然后推送一个pull request给他，他会视心情而定是否接受。</p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137621280731812dec22ecc9b44f4b2ca1c680f181a5b000">22.自定义Git</a></h2>
<p>之前已经说过在使用之前必须先配置<code>user.name</code>和<code>user.email</code>，否则后面commit的时候可能会有错误，实际上git还有很多可配置的：</p>
<ul><li><p><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目，自己去试试一些git命令的输出看看是不是有色！</p></li></ul>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000">23.忽略特殊文件</a></h2>
<p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
<p><strong>忽略文件的原则是：</strong></p>
<ul>
<li><p>忽略操作系统自动生成的文件，比如缩略图等；</p></li>
<li><p>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</p></li>
<li><p>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p></li>
</ul>
<p><strong>举个例子</strong></p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini
</code></pre>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：</p>
<pre><code># Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build
</code></pre>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini

# Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build

# My configurations:
db.ini
deploy_key_rsa
</code></pre>
<p>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令还会不会再说working directory clean。<strong>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</strong></p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<blockquote><p>再次建议：有钱的买mac，没钱的用ubuntu--或者其他的linux发行版、被逼无奈的用Windows--但是被逼之余的自主时间一定要远离Windows。</p></blockquote>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000">24.配置别名</a></h2>
<blockquote><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p></blockquote>
<ul>
<li><p><code>git config --global alias.st status</code> 有没有经常敲错命令？比如git status？status这个单词真心不好记。如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p></li>
<li><p><code>git config --global alias.co checkout</code></p></li>
<li><p><code>git config --global alias.ci commit</code></p></li>
<li><p><code>git config --global alias.br branch</code></p></li>
<li><p>很多人都用co表示checkout，ci表示commit，br表示branch</p></li>
<li><p><code>git ci -m "bala bala bala..."</code> 以后提交就可以简写成这样</p></li>
<li><p><code>git config --global alias.unstage 'reset HEAD'</code> 在<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000">撤销修改</a>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名</p></li>
<li><p><code>git unstage test.py</code> 当你敲入此命令，实际上Git执行的是：<code>git reset HEAD test.py</code></p></li>
<li><p><code>git config --global alias.last 'log -1'</code> 配置一个git last，让其显示最后一次提交信息</p></li>
<li><p><code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</code> 甚至还有人这样的配置，那么，这时候<code>git lg</code>的效果是这样的<br><img src="/img/bVpQW9" alt="图片描述" title="图片描述"></p></li>
</ul>
<p><strong>配置文件</strong></p>
<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<pre><code>$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote "origin"]
    url = git@github.com:michaelliao/learngit.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master
[alias]
    last = log -1
</code></pre>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<pre><code>$ cat .gitconfig
[alias]
    co = checkout
    ci = commit
    br = branch
    st = status
[user]
    name = Your Name
    email = your@email.com
</code></pre>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h2><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">25.搭建Git服务器</a></h2>
<p>如果需要的话，请自己参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">廖雪峰的教程</a></p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003739324";}i:48;a:11:{s:5:"title";s:24:"spring事务管理总结";s:4:"link";s:42:"http://segmentfault.com/a/1190000003739293";s:2:"id";s:42:"http://segmentfault.com/a/1190000003739293";s:7:"updated";s:25:"2015-09-12T14:48:36+08:00";s:9:"published";s:25:"2015-09-12T14:48:36+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:10:"yemengying";s:10:"author_uri";s:36:"http://segmentfault.com/u/yemengying";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:6329:"
<p>在项目开发过程中经常会使用事务来确保数据的一致性。根据网上的资料整理一下在spring中配置事务的几种方式。<br>无论是哪种方式都需要在配置文件中配置连接池和事务管理器,代码如下。</p>
<pre><code class="xml">   &lt;!-- 读取配置文件 --&gt;
   &lt;bean
        class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
        &lt;property name="locations"&gt;
            &lt;list&gt;
                &lt;value&gt;classpath:database.properties&lt;/value&gt;
                &lt;value&gt;classpath:service.properties&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="fileEncoding" value="UTF-8" /&gt;
        &lt;property name="ignoreResourceNotFound" value="false" /&gt;
    &lt;/bean&gt;
    &lt;!--连接池 --&gt;
    &lt;bean id="dataSource"
        class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="driverClassName" value="${db.driver}" /&gt;
        &lt;property name="url" value="${db.url}" /&gt;
        &lt;property name="username" value="${db.username}" /&gt;
        &lt;property name="password" value="${db.password}" /&gt;
    &lt;/bean&gt;
    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id="transactionManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;</code></pre>
<h2>声明式事务管理</h2>
<h3>基于AspectJ的XML方式的配置</h3>
<p>这是我觉得最好的方式，基于aop配置，当新增的方法要使用事务管理时，无需修改代码。<br>首先在配置文件xml中引入aop和tx的命名空间</p>
<pre><code>xmlns:tx="http://www.springframework.org/schema/tx" 
xmlns:aop="http://www.springframework.org/schema/aop"
xsi:schemaLocation="http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
http://www.springframework.org/schema/aop   
http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</code></pre>
<p>然后在xml中加入aop的配置,下面的配置就是在services的切入点上应用txAdvice的增强，services的切入点就是ymy.com.service.impl包下的所有方法应用txAdvice的增强。然后txAdvice是在所有以create,add,delete,update,change开头的方法上加上事务管理。</p>
<pre><code>    &lt;!-- 定义事务通知 （事务的增强）--&gt;
    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;
        &lt;!-- 定义方法的过滤规则 --&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 所有方法都使用事务 --&gt;
            &lt;!-- 
                propagation:事务传播行为
                isolation：事务隔离
                read-only:只读
                rollback-for:发生哪些异常回滚
                no-rollback-for:发生哪些异常不回滚 
                timeout:过期信息    
             --&gt;
            &lt;tx:method name="create*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="add*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="delete*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="update*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="change*" propagation="REQUIRED"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
      
    &lt;!-- 定义AOP配置 配置切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 定义一个切入点 --&gt;
        &lt;aop:pointcut expression="execution (* ymy.com.service.impl.*.*(..))" id="services"/&gt;
        &lt;!-- 对切入点和事务的通知，进行适配 --&gt;
        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="services"/&gt;
    &lt;/aop:config&gt; </code></pre>
<p>采用这种方式配置，当方法是按照事务定义的规则命名时，都会加入事务管理。</p>
<h3>基于注解</h3>
<p>这种方式是我觉得最简单的，第二推荐。要采用注解的方式，需要在配置文件中开启注解事务。</p>
<pre><code>&lt;!-- 开启注解事务 --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</code></pre>
<p>在使用时只需在对应的类上添加注解@Transactional即可</p>
<pre><code>@Service
@Transactional
public class TaskService implements ITaskService {

}</code></pre>
<p>也可在使用注解时定义事物的传播级别 隔离行为等。。</p>
<pre><code>@Transactional(propagation=Propagation.REQUIRED)</code></pre>
<h3>基于TransactionProxyFactoryBean</h3>
<p>这种方式配置比较麻烦，需要为每一个需要事务管理的类配置一个代理类，不推荐使用。例如我要对taskService进行事务管理，需要如下配置，用代理类对目标类进行增强。</p>
<pre><code>    &lt;!-- 配置service层的代理 --&gt;
    &lt;bean id = "taskServiceProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;!-- 配置目标对象 --&gt;
        &lt;property name = "target" ref="taskService"&gt;&lt;/property&gt;
        &lt;!-- 注入事务管理器 --&gt;
        &lt;property name = "transactionManager" ref="transactionManager"&gt;&lt;/property&gt;
        &lt;!-- 设置需要事务管理的方法 --&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre>
<p>之后在注入service类时，就要注入它的代理类。</p>
<pre><code>@Resource(name = "taskServiceProxy")
private ITaskService taskSerivce;</code></pre>
<h2>编程式事务管理</h2>
<p>超级不推荐，需要为每个类注入事务模板，然后在需要事务管理的方法中使用事务模板。</p>
<pre><code>private TransactionTemplate transactionTemplate;
public void test(){
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                //进行事务相应的操作。。。
                //方法一...
                //方法二...
            }
        });
    }</code></pre>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003739293";}i:49;a:11:{s:5:"title";s:55:"Lumen如何实现类Laravel5用户友好的错误页面";s:4:"link";s:42:"http://segmentfault.com/a/1190000003738977";s:2:"id";s:42:"http://segmentfault.com/a/1190000003738977";s:7:"updated";s:25:"2015-09-12T12:38:04+08:00";s:9:"published";s:25:"2015-09-12T12:38:04+08:00";s:6:"author";s:3:"


";s:11:"author_name";s:15:"一堆好人卡";s:10:"author_uri";s:35:"http://segmentfault.com/u/silentred";s:2:"re";a:1:{s:4:"rank";s:1:"0";}s:7:"summary";s:3523:"
<blockquote><p>Laravel5实现用户友好的错误页面非常简单，例如想要返回status 404，只需要在<code>view/errors</code>中添加一个<code>404.blade.php</code>文件即可。Lumen中没有默认实现这种便利，于是自己添加一个。</p></blockquote>
<h1>Lumen如何实现类Laravel5用户友好的错误页面</h1>
<h2>原理</h2>
<p>抛出错误的函数是<code>abort()</code>, 进入该函数一看究竟，会发现只是抛出一个<code>HttpException</code>. 在Application中，处理http request的时候，有一个try catch的过程，Exception就是在这里被捕获的。</p>
<pre><code class="php">try {
    return $this-&gt;sendThroughPipeline($this-&gt;middleware, function () use ($method, $pathInfo) {
        if (isset($this-&gt;routes[$method.$pathInfo])) {
            return $this-&gt;handleFoundRoute([true, $this-&gt;routes[$method.$pathInfo]['action'], []]);
        }

        return $this-&gt;handleDispatcherResponse(
            $this-&gt;createDispatcher()-&gt;dispatch($method, $pathInfo)
        );
    });
} catch (Exception $e) {
    return $this-&gt;sendExceptionToHandler($e);
}</code></pre>
<p>接着可以看出，Exception是交给了<code>sendExceptionToHandler</code>去处理了。这里的handler具体是哪个类呢？是实现了<code>Illuminate\Contracts\Debug\ExceptionHandler</code>的一个单例。为啥说他是单例？因为在bootstrap的时候，已经初始化为单例了，请看。</p>
<pre><code class="php">$app-&gt;singleton(
    Illuminate\Contracts\Debug\ExceptionHandler::class,
    App\Exceptions\Handler::class
);</code></pre>
<p>进入该类看一下，他有一个<code>render</code>方法，好吧，找到问题所在了，修改一下这个方法即可。</p>
<pre><code class="php">public function render($request, Exception $e)
{
    return parent::render($request, $e);
}</code></pre>
<h2>动手修改</h2>
<p>由于Laravel已经有实现了，所以最简便的方法就是复制黏贴。在<code>render</code>中先判断下是否为<code>HttpException</code>, 如果是，就去<code>errors</code>目录下找对应status code的view，如果找到，就渲染它输出。就这么简单。修改<code>Handler</code>如下：</p>
<pre><code class="php">/**
 * Render an exception into an HTTP response.
 *
 * @param  \Illuminate\Http\Request  $request
 * @param  \Exception  $e
 * @return \Illuminate\Http\Response
 */
public function render($request, Exception $e)
{
    if( !env('APP_DEBUG') and $this-&gt;isHttpException($e)) {
        return $this-&gt;renderHttpException($e);
    }
    return parent::render($request, $e);
}

/**
 * Render the given HttpException.
 *
 * @param  \Symfony\Component\HttpKernel\Exception\HttpException  $e
 * @return \Symfony\Component\HttpFoundation\Response
 */
protected function renderHttpException(HttpException $e)
{
    $status = $e-&gt;getStatusCode();

    if (view()-&gt;exists("errors.{$status}"))
    {
        return response(view("errors.{$status}", []), $status);
    }
    else
    {
        return (new SymfonyExceptionHandler(env('APP_DEBUG', false)))-&gt;createResponse($e);
    }
}

/**
 * Determine if the given exception is an HTTP exception.
 *
 * @param  \Exception  $e
 * @return bool
 */
protected function isHttpException(Exception $e)
{
    return $e instanceof HttpException;
}</code></pre>
<p>好了，在<code>errors</code>目录下新建一个<code>404.blade.php</code>文件，在controller中尝试 <code>abort(404)</code>看一下吧。</p>
";s:12:"link_replies";s:42:"http://segmentfault.com/a/1190000003738977";}}s:7:"channel";a:6:{s:5:"title";s:28:"SegmentFault 最新的文章";s:7:"updated";s:25:"2015-09-16T12:27:58+08:00";s:4:"link";s:29:"http://segmentfault.com/blogs";s:9:"link_self";s:35:"http://segmentfault.com/feeds/blogs";s:2:"id";s:35:"http://segmentfault.com/feeds/blogs";s:15:"creativecommons";a:1:{s:7:"license";s:53:"http://www.creativecommons.org/licenses/by-sa/2.5/rdf";}}s:9:"textinput";a:0:{}s:5:"image";a:0:{}s:9:"feed_type";s:4:"Atom";s:12:"feed_version";N;s:8:"encoding";s:5:"UTF-8";s:16:"_source_encoding";s:0:"";s:5:"ERROR";s:0:"";s:7:"WARNING";s:0:"";s:19:"_CONTENT_CONSTRUCTS";a:6:{i:0;s:7:"content";i:1;s:7:"summary";i:2;s:4:"info";i:3;s:5:"title";i:4;s:7:"tagline";i:5;s:9:"copyright";}s:16:"_KNOWN_ENCODINGS";a:3:{i:0;s:5:"UTF-8";i:1;s:8:"US-ASCII";i:2;s:10:"ISO-8859-1";}s:5:"stack";a:0:{}s:9:"inchannel";b:0;s:6:"initem";b:0;s:9:"incontent";b:0;s:11:"intextinput";b:0;s:7:"inimage";b:0;s:17:"current_namespace";b:0;}