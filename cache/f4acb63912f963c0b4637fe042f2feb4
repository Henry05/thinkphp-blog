O:9:"MagpieRSS":22:{s:6:"parser";i:0;s:12:"current_item";a:0:{}s:5:"items";a:20:{i:0;a:7:{s:5:"title";s:44:"基于百度网盘构建的Android SDK镜像";s:5:"link_";s:68:"http://efe.baidu.com/blog/android-mirror-proxy-based-on-baidu-cloud/";s:2:"id";s:68:"http://efe.baidu.com/blog/android-mirror-proxy-based-on-baidu-cloud/";s:9:"published";s:24:"2015-08-23T16:00:00.000Z";s:7:"updated";s:24:"2015-08-24T05:08:00.000Z";s:12:"atom_content";s:3861:"<p>因为某些奇怪的原因，国内访问 Android 镜像的时候总是会失败，导致更新 Android SDK 的时候非常困难，虽然国内有一个 <a href="http://www.androiddevtools.cn/" class="uri" target="_blank" rel="external">http://www.androiddevtools.cn/</a> 收集了很多 Android 开发相关的资源。</p>
<p>但是对于我本人而言，使用这里面提供的代理服务器的时候，速度还是慢的跟蜗牛一样。另外我使用的是中国电信的宽带，虽然购买了 VPN 但是速度还是很不理想，可能也跟 <a href="http://www.zhihu.com/question/31646893" target="_blank" rel="external">如何看待上海电信访问国外网站困难，并推出国际精品网、国际氮气瓶业务？</a> 有些关系。</p>
<p>知乎上面也有一个相关的话题讨论 <a href="http://www.zhihu.com/question/32212970" target="_blank" rel="external">谷歌不能访问了 怎么构建安卓开发环境？</a></p>
<p>因此我开始考虑是否可以自己弄一个代理服务器，借助于百度网盘的CDN网络，提供更快的下载速度。</p>
<a id="more"></a>
<p>为了构建这个代理服务器，首先需要有资源。</p>
<p>我直接使用了百度网盘的离线下载功能，把 <a href="http://mirrors.neusoft.edu.cn/android/repository/" class="uri" target="_blank" rel="external">http://mirrors.neusoft.edu.cn/android/repository/</a> 的内容镜像了一次，这部分主要是人肉的工作，因为提交的 URL 多了之后，需要手工输入验证码，花费了大概2，3个小时的时间。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: <span class="string">http:</span><span class="comment">//pan.baidu.com/s/1mgGhdlm 密码: 526k</span></span><br></pre></td></tr></table></figure>
<p>有了资源之后，就需要考虑如何通过代理服务器下载，代理服务器本质上就是一个 Web 服务器，当收到类似 <code>/android/repository/addons_list-1.xml</code> 的请求之后，就从百度网盘里面下载所需要的资源。</p>
<p>要自动获取百度网盘中资源的下载地址，需要先人肉登录，然后得到 BDUSS 和 BAIDUID 这两个 Cookie。相信对于大部分同学来说，应该不是很大的问题，只需要在 Chrome Dev Tools 里面看看 Request Header 就能得到这部分数据了。</p>
<p>有了 <code>BDUSS</code> 和 <code>BAIDUID</code> 这两个 Cookie 之后，把上面的分享的内容转存到自己网盘的<code>根目录</code>，然后下载这部分的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/leeight/baidu-cloud-mirror.git</span><br><span class="line"><span class="built_in">cd</span> baidu-cloud-mirror</span><br><span class="line">npm install</span><br><span class="line">DEBUG=* node main.js --bduss=<span class="variable">$BDUSS</span> --baiduid=<span class="variable">$BAIDUID</span> --port=<span class="number">8964</span></span><br></pre></td></tr></table></figure>
<p>然后就可以通过 <code>wget http://localhost:8964/android/repository/samples-22_r06.zip</code> 测试下载速度了。</p>
<p>对于我的 <code>100M</code> 电信宽带来说，未开通了百度网盘会员之前，下载速度在 <code>300K</code> 左右，开通了之后，下载速度是 <code>6M ~ 7M</code> 左右。</p>
<div class="figure">
<img src="/blog/android-mirror-proxy-based-on-baidu-cloud/android-sdk-download-speed.png" alt="android-sdk-download-speed"><p class="caption">android-sdk-download-speed</p>
</div>
";s:7:"summary";s:1022:"
    <p>因为某些奇怪的原因，国内访问 Android 镜像的时候总是会失败，导致更新 Android SDK 的时候非常困难，虽然国内有一个 <a href="http://www.androiddevtools.cn/" class="uri">http://www.androiddevtools.cn/</a> 收集了很多 Android 开发相关的资源。</p>
<p>但是对于我本人而言，使用这里面提供的代理服务器的时候，速度还是慢的跟蜗牛一样。另外我使用的是中国电信的宽带，虽然购买了 VPN 但是速度还是很不理想，可能也跟 <a href="http://www.zhihu.com/question/31646893">如何看待上海电信访问国外网站困难，并推出国际精品网、国际氮气瓶业务？</a> 有些关系。</p>
<p>知乎上面也有一个相关的话题讨论 <a href="http://www.zhihu.com/question/32212970">谷歌不能访问了 怎么构建安卓开发环境？</a></p>
<p>因此我开始考虑是否可以自己弄一个代理服务器，借助于百度网盘的CDN网络，提供更快的下载速度。</p>
    
    ";}i:1;a:7:{s:5:"title";s:28:"CSS 代码静态质量检查";s:5:"link_";s:36:"http://efe.baidu.com/blog/css-lints/";s:2:"id";s:36:"http://efe.baidu.com/blog/css-lints/";s:9:"published";s:24:"2015-07-30T16:00:00.000Z";s:7:"updated";s:24:"2015-07-31T04:57:19.000Z";s:12:"atom_content";s:12167:"<p>关于代码静态质量检查，在大佛的上一篇文章 《<a href="http://efe.baidu.com/blog/js-lints/" target="_blank" rel="external">JavaScript 代码静态质量检查</a>》中已经说得很明白了，虽然主要讲的是 JavaScript 方面，但代码静态质量检查的本质是不变的，今天我们来介绍一下 CSS 方面的静态质量检查。</p>
<p>CSS 中也有一些 Lint 工具，例如 <a href="https://github.com/CSSLint/csslint" target="_blank" rel="external">CSSLint</a>，<a href="https://github.com/fidian/PrettyCSS" target="_blank" rel="external">PrettyCSS</a>，<a href="https://github.com/twitter/recess" target="_blank" rel="external">recess</a>，<a href="https://github.com/wangjeaf/ckstyle-node" target="_blank" rel="external">CKStyle</a>，<a href="https://github.com/stylelint/stylelint" target="_blank" rel="external">stylelint</a>，当然还有百度 EFE 出品的 CSS 代码风格检查工具 <a href="https://github.com/ecomfe/node-csshint" target="_blank" rel="external">CSSHint</a>。本文将从功能、性能、适用范围、规则实现、个性化几个方面对这几个 Lint 工具进行对比。</p>
<a id="more"></a>
<h3 id="csslint"><a href="http://csslint.net" target="_blank" rel="external">CSSLint</a></h3>
<p><code>CSSLint</code> 和它底层所使用的解析器 <a href="https://github.com/CSSLint/parser-lib" target="_blank" rel="external"><code>parserlib</code></a> 都是 <a href="http://www.nczonline.net/" target="_blank" rel="external">Nicholas C. Zakas</a> 的作品（当然，<a href="https://github.com/eslint/eslint" target="_blank" rel="external"><code>ESLint</code></a> 也是他的作品）。它适用于浏览器以及 CLI 环境，在浏览器端和 CLI 环境中分别是两套代码，这么做的原因是它的底层库 <code>parserlib</code> 在浏览器和 CLI 环境分别是两套。</p>
<p>功能上，<code>CSSLint</code> 提供了对 CSS 的解析、检查等功能。在规则实现方面，无法通过 JSON 配置来管理，默认的规则全部在 <code>src/rules/</code> 目录中，要添加自定义规则，必须通过全局的 <strong>CSSLint.addRule</strong> 方法来实现。</p>
<p>实现上，<code>CSSLint</code> 主要是利用事件监听，在底层 parse CSS 过程中触发事件，例如 <strong>startstylesheet</strong>、<strong>endstylesheet</strong>、<strong>charset</strong>、<strong>import</strong>、<strong>namespace</strong>、<strong>startmedia</strong>、<strong>endmedia</strong>、<strong>startpage</strong>、<strong>endpage</strong>、<strong>startrul</strong> 和 <strong>endrule</strong> 等，事件回调中会返回当前 AST 的信息，开发者根据这些信息来进行规则检测。</p>
<p>性能上，如果不添加自定义的规则，性能还是不错的，但是一旦添加自定义规则，性能就会打些折扣。这是底层解析器 <code>parserlib</code> 的原因，<code>parserlib</code> 功能比较单一，而且返回的 AST 上信息不是很丰富，也不支持插件机制，因此要实现一些自定义的规则，基本只能靠正则匹配来实现。</p>
<p><code>CSSLint</code> 开发时间比较早，同时也因为大神的影响力，因此现在周边配套非常丰富，支持各种编辑器例如：<code>Textmate</code>, <code>Sublime Text</code>, <code>Atom</code>, <code>Vim</code>, <code>Emacs</code> 等等。</p>
<h3 id="prettycss"><a href="https://github.com/fidian/PrettyCSS" target="_blank" rel="external">PrettyCSS</a></h3>
<p><code>PrettyCSS</code> 是一个比较出色的 Lint 工具，但它并不算是一个纯粹的 Linter，更应该把它称作一个 Parser，这也是它出色的原因。在 Parser 里面实现的 Linter 以及 Pretty，这样可以最大程度的保证 Linter 的精确度。它适用于浏览器端、作为 Node.js 模块以及 CLI 工具。</p>
<p>实现上来说，在 Parser 中集成 Linter 即在 Parse 阶段就把 Linter 的规则给检测了，因此性能较好。当然缺点也比较明显，就是无法自定义规则。</p>
<p>如果 <code>PrettyCSS</code> 未来能够提供插件机制，允许自定义规则，会更有吸引力。</p>
<h3 id="recess"><a href="http://twitter.github.com/recess" target="_blank" rel="external">recess</a></h3>
<p>Twitter 出品的 CSS 代码质量检查工具，可以作为 Node.js 模块和 CLI 工具来使用，不知道是什么原因，master 分支已经两年没有维护了，v2.0.0 分支也有将近半年没有更新了。</p>
<p>比较有特点的是，<code>recess</code> 没有用任何 CSS 解析器，而是直接用 Less 解析器来做的，因此也就默认了一个编译 Less 的功能，但其他方面的功能就比较弱了，可能是时间比较早的原因吧。所有默认规则都在 <strong>lib/lint/</strong> 目录下，没有插件机制，无法扩展。</p>
<p>实现上，结合 Less parse 出来的 AST 进行规则分析检查，性能上表现一般，因为 Less parse 后还会有 <strong>toCSS</strong> 这么一步，本质上就会比纯 CSS 解析器要多一个步骤。在规则的实现程度上也比较一般，只实现了<strong>八</strong>个规则，这可能也是因为底层是 Less 解析器的原因。</p>
<p>就目前来看，v2.0.0 相对于 master 来说并没有改动太多，整体结构没有变化，底层还是使用 Less 解析器，区别仅仅是增加了一个 <strong>data-uri</strong> 的规则以及修改了一些 codestyle。</p>
<h3 id="ckstyle"><a href="http://ckstyle.github.io" target="_blank" rel="external">CKStyle</a></h3>
<p><code>CKStyle</code> 是国产的 CSS 代码检查工具，定位是<code>一脉相承的 CSS 检查、美化、修复、压缩工具</code>。适用范围包括在浏览器端使用、作为 Node.js 模块以及 CLI 工具。这个工具最开始是 <a href="https://github.com/wangjeaf/CSSCheckStyle" target="_blank" rel="external">python 版本</a>的，大约一年前改成 Node.js 版本了。这个版本和之前的 python 版本比较起来，增加了一些默认的规则实现以及提供了浏览器端的支持。</p>
<p><code>CKStyle</code> 在功能上还是比较丰富的，它提供了对 CSS 的解析、检查、fix 和压缩。但是它同样无法通过配置文件来管理规则，默认的规则全部在 <strong>ckstyle/plugins/</strong> 目录中，要添加自定义规则，只能在全局 <code>global</code> 上挂载一个 <code>RuleChecker</code> 的子类。</p>
<p>实现上，<code>CKStyle</code> 直接解析 CSS 文件，然后结合返回的 AST 对象做一些规则的检测。性能比较不错，这是因为底层 CSS 解析器是自己根据默认的规则来定制的，很少有正则上的一些匹配。这就好像是坑是自己挖的，那么自己总能想到一个简单快速的方法把坑填满一样。</p>
<p><code>CKStyle</code> 整体规模上看起来比较大，但是不知道什么原因，并没有在社区流行。亮点是功能很丰富，检查、美化、修复和压缩全都有，甚至提供了一个服务 <code>CKService</code>，帮助检查网站的 CSS。</p>
<h3 id="stylelint"><a href="https://github.com/stylelint/stylelint" target="_blank" rel="external">stylelint</a></h3>
<p><code>stylelint</code> 本质上和下面将要介绍的 <code>CSSHint</code> 是一样的，都是基于 <code>postcss</code> 解析器实现的，除了规则实现的数量不一样，最大的区别就是 <code>stylelint</code> 是用 ES6 写的。所以这里就不介绍了，直接看下面的 <code>CSSHint</code> 了。</p>
<h3 id="csshint"><a href="https://github.com/ecomfe/node-csshint" target="_blank" rel="external">CSSHint</a></h3>
<p><code>CSSHint</code> 是百度 EFE 出品的 CSS 代码风格检查工具，在 2014 年底应公司内部全面推行代码规范检查的需求而产生的。目前 <code>CSSHint</code> 支持 Node.js 模块以及 CLI 方式使用，提供对 CSS 的解析和检查等功能，通过 JSON 文件来管理规则的配置。</p>
<p>在项目刚开始设计阶段，我们曾考虑使用大神的 <code>CSSLint</code>，但在经过调研后发现，<code>CSSLint</code> 在针对我们自己的<a href="https://github.com/ecomfe/spec/blob/master/css-style-guide.md" target="_blank" rel="external">规范</a>做规则检测的时候，发现一些问题：首先 <code>CSSLint</code> 默认实现的规则里面并不能完全覆盖我们自己的<a href="https://github.com/ecomfe/spec/blob/master/css-style-guide.md" target="_blank" rel="external">规范</a>，其次，在单条规则上，对规则匹配度也不够，最后，基于 <code>CSSLint</code> 来写插件不太方便。因此，我们决定基于 <code>CSSLint</code> 解析器 <code>parserlib</code> 重新实现一套 CSS 代码检查工具。这就是 <strong>0.1.0</strong> 版本之前的 <code>CSSHint</code>，经过一段时间的使用我们发现这个解析器返回的 AST 上信息太少，而且针对解析器来写插件也不方便。因此在 <strong>0.1.0</strong> 版本的重构中，我们把底层解析器换成了 <a href="https://github.com/postcss/postcss" target="_blank" rel="external"><code>postcss</code></a>(<code>postcss</code> 和 <code>parserlib</code> 相比，最大的优点是优秀的插件机制，而且 AST 上的信息也更完整），同时改变了实现的方式，在性能和功能上较 <strong>0.1.0</strong> 之前版本有较大的提升。</p>
<p>得益于 <code>postcss</code> 优秀的插件机制，<code>CSSHint</code> 提供了较为丰富的规则实现，每个规则实际上就是一个 <code>postcss</code> 的插件，扩展新规则比较方便，只需注册到 <strong>postcss.plugin</strong> 上即可。</p>
<p>在实现上，也是直接解析 CSS 文件，然后在每个插件里面调用 <strong>node.eachRule</strong> 或者 <strong>rule.eachDecl</strong> 来实现对选择器或者属性的遍历，回调函数中返回的是 AST，然后根据这些信息做规则的检测。同时针对我们的需求，<code>CSSHint</code> 提供了行内注释的方式来动态的配置规则。</p>
<p><code>CSSHint</code> 目前还不支持浏览器端使用，相对于 <code>CKStyle</code> 的大而全，<code>CSSHint</code> 更加专注于 Lint 本身。覆盖更多的规则（包括 <a href="https://github.com/CSSLint/csslint/wiki/Rules" target="_blank" rel="external">CSSLint的规则</a>）、提供更易用扩展方式、提供更加灵活的行内注释指令匹配方式（开启、关闭、嵌套）等功能才是 <code>CSSHint</code> 的专注方向。</p>
<h3 id="总结">总结</h3>
<p><code>CSSLint</code> 中规中矩，各个方面比较均衡，如果你是大神<strong>Nicholas C. Zakas</strong>的粉丝，那么 <code>CSSLint</code> 是你的必选项。</p>
<p><code>PrettyCSS</code> 性能比较好，如果 <code>PrettyCSS</code> 默认实现的规则可以满足你并且你不会有自定义规则的需求的话，那么 <code>PrettyCSS</code> 就是你的不二之选。</p>
<p><code>recess</code> 虽然师出名门，但是维护跟不上，在功能上已经不能满足如今的需求了，只能当做代码学习来使用了。</p>
<p><code>CKStyle</code> 功能丰富，但是精细程度不是太高，如果你要求不太高，对功能的丰富程度更加在意，那么推荐使用 <code>CKStyle</code>，而且是国人出品，中文文档，看起来也比较方便。</p>
<p><code>stylelint</code> 本质上和 <code>CSSHint</code> 一样，可以作为一个 ES6 的学习项目。</p>
<p><code>CSSHint</code> 已经发布了 <code>0.2.0</code> 版本，在扩展性、规则的自定义上表现不错，同时，除了满足我们自己的<a href="https://github.com/ecomfe/spec/blob/master/css-style-guide.md" target="_blank" rel="external">规范</a>，还覆盖了 <code>CSSLint</code> 的规则。目前来看，<code>CSSHint</code> 是覆盖规则最全的一个 CSS 代码风格检查工具了，而且扩展起来也比较方便，另外，行内注释指令的功能在其他 Lint 工具上也是没有的，个人来看，未来的潜力比较大。</p>
";s:7:"summary";s:961:"
    <p>关于代码静态质量检查，在大佛的上一篇文章 《<a href="http://efe.baidu.com/blog/js-lints/">JavaScript 代码静态质量检查</a>》中已经说得很明白了，虽然主要讲的是 JavaScript 方面，但代码静态质量检查的本质是不变的，今天我们来介绍一下 CSS 方面的静态质量检查。</p>
<p>CSS 中也有一些 Lint 工具，例如 <a href="https://github.com/CSSLint/csslint">CSSLint</a>，<a href="https://github.com/fidian/PrettyCSS">PrettyCSS</a>，<a href="https://github.com/twitter/recess">recess</a>，<a href="https://github.com/wangjeaf/ckstyle-node">CKStyle</a>，<a href="https://github.com/stylelint/stylelint">stylelint</a>，当然还有百度 EFE 出品的 CSS 代码风格检查工具 <a href="https://github.com/ecomfe/node-csshint">CSSHint</a>。本文将从功能、性能、适用范围、规则实现、个性化几个方面对这几个 Lint 工具进行对比。</p>
    
    ";}i:2;a:7:{s:5:"title";s:20:"避免使用 forEach";s:5:"link_";s:40:"http://efe.baidu.com/blog/avoid-foreach/";s:2:"id";s:40:"http://efe.baidu.com/blog/avoid-foreach/";s:9:"published";s:24:"2015-07-27T16:00:00.000Z";s:7:"updated";s:24:"2015-07-28T09:04:25.000Z";s:12:"atom_content";s:28625:"<p>原文：<a href="http://aeflash.com/2014-11/avoid-foreach.html" class="uri" target="_blank" rel="external">http://aeflash.com/2014-11/avoid-foreach.html</a></p>
<blockquote>
<p>遍历集合，会产生副作用。——如 <a href="http://swannodette.github.io/mori/#each" target="_blank" rel="external">mori.each 文档</a>所说</p>
</blockquote>
<p>首先声明，本文和性能无关。执行 <code>for</code> 循环总是比执行 <code>Array.forEach</code> 快。如果性能测试显示迭代的开销足够显著并且性能优先，那么你绝对应该使用 <code>for</code> 循环而不是 <code>forEach</code>（总是使用 <code>for</code> 循环是典型的过早优化。<code>forEach</code> 仍然可以在 1 微秒内遍历长度为 50 的数组）。本文和编码风格有关，是我对 <code>forEach</code> 和其它 <code>Array.prototype</code> 方法的思考，与性能无关。</p>
<a id="more"></a>
<h3 id="foreach-为副作用而生">forEach 为副作用而生</h3>
<p>当人们想要把代码重构成一个更加实用的风格时，往往首选 <code>[].forEach</code> 或 <code>_.each</code>。<code>forEach</code> 直接模拟最基本的 <code>for</code> 循环——遍历数组并且执行一些操作——所以它是一个很机械的转换。但是就像 <code>for</code> 循环一样，<code>forEach</code> 在程序的某个地方必定会产生副作用。它必须修改父作用域中的对象，或者调用一个外部方法，或者使用迭代函数以外的其它变量。使用 <code>forEach</code> 也意味着你的迭代函数和它所在的作用域产生了耦合。</p>
<p>在编程中，我们通常认为副作用是不好的。他们使程序更难理解，可能导致 bug 的产生，而且难以重构。当然，<code>forEach</code> 在大项目中引起的副作用是微不足道的，但是这些副作用是不必要的。</p>
<p>当然也有一些副作用是无法避免的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种情况完全可以接受。</p>
<h3 id="foreach-隐藏了迭代的意图"><code>forEach</code> 隐藏了迭代的意图</h3>
<p>阅读 <code>forEach</code> 代码段的时候，你并不能马上知道它的作用，只知道它会在某个地方产生副作用，然后必须阅读这段代码或者注释才明白。这是一个非语义的方法。</p>
<p>除了 <code>forEach</code>，还有更好的迭代方法。比如 <code>map</code>——在使用迭代函数以后会返回一个新数组；比如 <code>filter</code>——返回由符合条件的元素组成的新数组；比如 <code>some</code>（或者 <code>_.any</code>）——如果数组中至少有一个元素满足要求时返回 <code>true</code>；比如 <code>every</code>（或者 <code>_.all</code>）——如果数组中所有元素满足要求时返回 <code>true</code>；比如 <code>reduce</code>——遍历数组并且使用数组中的所有元素进行某种操作迭代生成一个新的变量，数组中的很多方法都可以用 <code>reduce</code> 来实现。ES5 的数组方法非常强大，希望你对此并不陌生。<a href="https://lodash.com/" target="_blank" rel="external">Lodash</a>/Underscore 库增强了 ES5 的方法，增加了很多有用且语义化的迭代函数（此外还提供了可用于对象的数组原型方法的更优实现）。</p>
<h3 id="重构">重构</h3>
<p>下面是一些实际项目中使用 <code>each</code> 的例子，看看如何更好地重构它们。</p>
<h4 id="例-1">例 1</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span><br><span class="line">    obj[item.key] = item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是一个很常见的操作——将数组转换为对象。由于迭代函数依赖 <code>obj</code>，所以 <code>forEach</code> 跟它所在的作用域耦合在一起。迭代函数不能在它的闭包作用域之外执行。我们换个方式来重写它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = arr.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(newObj, item)</span> </span>&#123;</span><br><span class="line">    newObj[item.key] = item;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>现在归并函数只依赖于它的形参，没有别的。<code>reduce</code> 无副作用——遍历集合，并且只产出一个东西。它是 ES5 方法中最不语义的方法，但它很灵活，可以用来实现所有其余的函数。</p>
<p>Lodash 还有更语义化的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = _.zipObject(_.pluck(arr, <span class="string">'key'</span>), arr);</span><br></pre></td></tr></table></figure>
<p>这里需要遍历2次，但是看起来更直观。</p>
<blockquote>
<p>译者注：实际上有更好的方法 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = _.indexBy(arr, <span class="string">'key'</span>);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="例-2">例 2</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replacement = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> replacedUrls = urls;</span><br><span class="line"></span><br><span class="line">urls.forEach(<span class="function"><span class="keyword">function</span> <span class="title">replaceToken</span><span class="params">(url, index)</span> </span>&#123;</span><br><span class="line">    replacedUrls[index] = url.replace(<span class="string">'&#123;token&#125;'</span>, replacement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用 <code>map</code> 重构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replacement = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> replacedUrls;</span><br><span class="line"></span><br><span class="line">replacedUrls = urls.map(<span class="function"><span class="keyword">function</span> <span class="params">(url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url.replace(<span class="string">'&#123;token&#125;'</span>, replacement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>map</code> 函数仍然依赖于 <code>replacement</code> 的作用域，但是迭代的意图更加清晰。前一种方法改变了 <code>urls</code> 数组，而 <code>map</code> 函数则分配了一个新的数组。需要注意的是，它对 <code>urls</code> 的修改不易被察觉，其它地方可能仍然期望 <code>urls</code> 中会含有 <code>{token}</code>。采用分配新数组的方法可以防止这个小细节引发的问题，代价就是需要多一点内存开销。</p>
<h4 id="例-3">例 3</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">_.each(<span class="keyword">this</span>.values, <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">'radio_button_'</span> + self.groupName + <span class="string">'_'</span> + value.id;</span><br><span class="line"></span><br><span class="line">    html += <span class="string">''</span></span><br><span class="line">        + <span class="string">'&lt;li&gt;'</span></span><br><span class="line">        +   <span class="string">'&lt;input type="radio" name="'</span> + self.groupName + <span class="string">'" id="'</span> + id + <span class="string">'" value="'</span> + value.id + <span class="string">'"&gt;'</span></span><br><span class="line">        +   <span class="string">'&lt;label for="'</span> + id + <span class="string">'"&gt;'</span> + value.description + <span class="string">'&lt;/label&gt;'</span></span><br><span class="line">        + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!touchEnabled) &#123;</span><br><span class="line">        <span class="keyword">var</span> tooltip = value.getTooltip();</span><br><span class="line">        <span class="keyword">if</span> (tooltip) &#123;</span><br><span class="line">            self.tooltips.push(tooltip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子稍微复杂一点。这段代码实际上做了两件事：拼接 HTML 字符串，为每一个 <code>value</code> 创建 <code>tooltips</code>。其实迭代函数没必要这么复杂——或者如 Rich Hickey 所说的 「<a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="external">complected</a>」。它将两种操作放在一个函数里，而实际上没有必要。第一部分操作是典型的 <code>reduce</code> 函数的应用范围，所以我们把这两部分操作分开：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">html = _.reduce(<span class="keyword">this</span>.values, <span class="function"><span class="keyword">function</span> <span class="params">(str, value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">'radio_button_'</span> + self.groupName + <span class="string">'_'</span> + value.id;</span><br><span class="line"></span><br><span class="line">    str += <span class="string">''</span></span><br><span class="line">        + <span class="string">'&lt;li&gt;'</span></span><br><span class="line">        +   <span class="string">'&lt;input type="radio" name="'</span> + self.groupName + <span class="string">'" id="'</span> + id + <span class="string">'" value="'</span> + value.id + <span class="string">'"&gt;'</span></span><br><span class="line">        +   <span class="string">'&lt;label for="'</span> + id + <span class="string">'"&gt;'</span> + value.description + <span class="string">'&lt;/label&gt;'</span></span><br><span class="line">        + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">_.each(<span class="keyword">this</span>.values, <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!touchEnabled) &#123;</span><br><span class="line">        <span class="keyword">var</span> tooltip = value.getTooltip();</span><br><span class="line">        <span class="keyword">if</span> (tooltip) &#123;</span><br><span class="line">            self.tooltips.push(tooltip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在第一部分就可以接受了。在 <code>values</code> 上迭代，最后生成 HTML 字符串。它仍然依赖于 <code>self.groupName</code>，不过可以通过偏函数（<a href="https://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="external">partial application</a>）来避免。</p>
<blockquote>
<p>译者注：Underscore 中提供了偏函数 <code>_.partial</code> 可以帮助我们解决这个问题，相应的代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> part = _.partial(<span class="function"><span class="keyword">function</span> <span class="params">(groupName, str, value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;, self.groupName);</span><br><span class="line"></span><br><span class="line">_.reduce(<span class="keyword">this</span>.values, part, <span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<p>现在来看一下第二部分。如果 <code>touchEnabled</code> 为假，可以得到 <code>tooltip</code>。这时不确定会不会返回一个有效的 <code>tooltip</code>，因此将每个实例对应的 <code>tooltip</code> 放进数组中的操作是带条件的。我们可以把多个方法串联起来解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!touchEnabled) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tooltips = <span class="keyword">this</span>.tooltips.concat(</span><br><span class="line">        <span class="keyword">this</span>.values</span><br><span class="line">            .map(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.getTooltip();</span><br><span class="line">            &#125;)</span><br><span class="line">            .filter(_.identity)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 touch 检查移到循环的外面，因为只需要检查一次就够了。然后对集合使用 <code>map</code> 方法，在每次迭代中调用 <code>getTooltip()</code>，然后过滤掉不符合条件的值。最后结果合并到 <code>tooltips</code> 数组。这种方法每次都会创建临时数组，但是正如我在其它例子中所说的，表达清晰更重要。</p>
<p>你可以定义一个辅助函数把上面的内联函数去掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dot = _.curry(<span class="function"><span class="keyword">function</span> <span class="params">(methodName, object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object[methodName]();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">this</span>.tooltips = <span class="keyword">this</span>.tooltips.concat(</span><br><span class="line">    <span class="keyword">this</span>.values</span><br><span class="line">        .map(dot(<span class="string">'getTooltip'</span>))</span><br><span class="line">        .filter(_.identity)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样更简洁直观。</p>
<blockquote>
<p>译者注：这里其实可以直接用 <code>_.invoke</code> 函数和 <code>_.union</code> 函数，更加简洁。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.tooltips = _.union(<span class="keyword">this</span>.tooltips, _.filter(_.invoke(<span class="keyword">this</span>.values, <span class="string">'getTooltip'</span>), _.identity));</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="例-4">例 4</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> nonMatches = [];</span><br><span class="line"></span><br><span class="line">values.forEach(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matchesSomething(value)) &#123;</span><br><span class="line">        matches.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        nonMatches.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子看起来很简单——基于判断条件将数组拆分成两个。但还不够简单。我会这样重写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = values.filter(matchesSomething);</span><br><span class="line"><span class="keyword">var</span> nonMatches = values.filter(not(matchesSomething));</span><br></pre></td></tr></table></figure>
<p>迭代函数实际上在做两件事，拆分成两个迭代函数更加清晰。如果确实有成千上万的值，或者 <code>matchesSomething</code> 操作非常耗时，我会保留第一种方案。</p>
<blockquote>
<p>译者注：这段代码其实可以用 <code>reduce</code> 加以改进：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(result, value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matchesSomething(value)) &#123;</span><br><span class="line">        result.matches.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        result.nonMatches.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;matches: [], nonMatches: []&#125;);</span><br></pre></td></tr></table></figure>
<p>重构时你会发现多了些东西，如果这些东西使程序更简单，那就没问题。多个简单的东西组合起来会比一个大而复杂的东西更容易理解。</p>
<h3 id="转换器">转换器</h3>
<p>让我们再看一下例 3 的最终代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.tooltips = <span class="keyword">this</span>.tooltips.concat(</span><br><span class="line">    <span class="keyword">this</span>.values</span><br><span class="line">        .map(dot(<span class="string">'getTooltip'</span>))</span><br><span class="line">        .filter(_.identity)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>map</code> 和 <code>filter</code> 的串联操作意味着临时数组的创建和删除。对于元素较少的数组来说是可以接受的，额外的开销可以忽略不计。但是如果这个数组包含了数千个元素，或者要做很多次的映射和过滤操作呢？这时单一的迭代函数又变得诱人了。</p>
<p>幸运的是，随着 <a href="http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming" target="_blank" rel="external">Transducers</a>（其实是 transform 和 reducer 的合成词，transform 是变换，reducer 就是 JS 中的 reducer）的出现，你可以任性地将很多 <code>map</code> 和 <code>filter</code> 函数放在一个迭代中。也就是说，先在第一个元素上应用所有变换（<code>map</code> 和 <code>filter</code> 或者其它），然后依次处理其它元素。本文中不会深入研究 Transducers 的原理（<a href="http://phuu.net/2014/08/31/csp-and-transducers.html" target="_blank" rel="external">这里有关于它的介绍</a>），不过经过 Transducers 改造以后会是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'transducers-js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tooltips = t.transduce(</span><br><span class="line">    t.comp( <span class="comment">// 变换函数</span></span><br><span class="line">        t.map(dot(<span class="string">'getTooltip'</span>)),</span><br><span class="line">        t.filter(_.identity),</span><br><span class="line">        <span class="comment">// 想加多少map和filter就加多少</span></span><br><span class="line">        t.map(someFunction),</span><br><span class="line">        t.filter(somePredicate)</span><br><span class="line">    ),</span><br><span class="line">    concat, <span class="comment">// reducer</span></span><br><span class="line">    [], <span class="comment">// 初始值</span></span><br><span class="line">    values <span class="comment">// 输入</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>它看上去有点不一样，和 <code>reduce</code> 类似，但是它只涉及到一个迭代器，而且只分配了一个唯一的数组。你想加入多少 <code>map</code> 和 <code>filter</code>，就加入多少，它只会迭代一次。通过使用其它函数替换 <code>concat</code>，你也可以让它返回任何类型的结果。如果你想了解更多，那就深入地研究一下 <code>Transducers</code> 吧。</p>
<blockquote>
<p>译者注：有了 ES6 的 Generator，这事就是原生支持的了。</p>
</blockquote>
<h2 id="总结">总结</h2>
<ul>
<li><p><code>forEach</code> 总会产生副作用。如果你想避免产生副作用，那就不要使用它了。</p></li>
<li><p><code>forEach</code> 隐藏了迭代的意图。推荐使用更加语义化的迭代方法，例如 <code>map</code>、<code>filter</code> 和 <code>some</code>。</p></li>
<li><p>如果每次迭代包含了太多操作，将它们拆分到不同的函数中。</p></li>
<li><p>通过多个方法的串联调用，将不同的数据转换隔离开来。如果性能不可接受，那就使用 Transducers 重构它。</p></li>
<li><p>改造后的程序最终会多了操作，但是如果你处理得当，那么每一步都会更容易理解。</p></li>
<li><p>如果你确实需要循环产生的副作用，完全可以用 <code>forEach</code>。</p></li>
<li><p>最后，如果性能测试表明更加语义化的迭代函数是性能瓶颈或者被频繁执行， 那就用 <code>for</code> 循环好了。</p></li>
</ul>
";s:7:"summary";s:868:"
    <p>原文：<a href="http://aeflash.com/2014-11/avoid-foreach.html" class="uri">http://aeflash.com/2014-11/avoid-foreach.html</a></p>
<blockquote>
<p>遍历集合，会产生副作用。——如 <a href="http://swannodette.github.io/mori/#each">mori.each 文档</a>所说</p>
</blockquote>
<p>首先声明，本文和性能无关。执行 <code>for</code> 循环总是比执行 <code>Array.forEach</code> 快。如果性能测试显示迭代的开销足够显著并且性能优先，那么你绝对应该使用 <code>for</code> 循环而不是 <code>forEach</code>（总是使用 <code>for</code> 循环是典型的过早优化。<code>forEach</code> 仍然可以在 1 微秒内遍历长度为 50 的数组）。本文和编码风格有关，是我对 <code>forEach</code> 和其它 <code>Array.prototype</code> 方法的思考，与性能无关。</p>
    
    ";}i:3;a:7:{s:5:"title";s:45:"谈谈使用 promise 时候的一些反模式";s:5:"link_";s:48:"http://efe.baidu.com/blog/promises-anti-pattern/";s:2:"id";s:48:"http://efe.baidu.com/blog/promises-anti-pattern/";s:9:"published";s:24:"2015-07-23T16:00:00.000Z";s:7:"updated";s:24:"2015-07-28T09:04:25.000Z";s:12:"atom_content";s:59938:"<blockquote>
<p>本文翻译自 <a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">We have a problem with promises</a>，为原文题目重新起了一个题目并且对原文有删改。</p>
</blockquote>
<p>各位 JavaScript 程序员，是时候承认了，我们在使用 promise 的时候，会写出许多有问题的 promise 代码。 当然并不是 promise 本身的问题，<a href="https://promisesaplus.com/" target="_blank" rel="external">A+ spec</a> 规范定义的 promise 非常棒。 在过去的几年中，笔者看到了很多程序员在调用 PouchDB 或者其他 promise 化的 API 时遇到了很多困难。这让笔者认识到，在 JavaScript 程序员之中，只有少数人是真正理解了 promise 规范的。如果这个事实让你难以接受，那么思考一下我在 <a href="https://twitter.com/nolanlawson/status/578948854411878400" target="_blank" rel="external">Twitter</a> 上出的题：</p>
<blockquote>
<p>问：下面四个使用 promise 的语句之间的不同点在哪儿？</p>
</blockquote>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(<span class="keyword">function</span> <span class="literal">()</span> &#123;</span><br><span class="line">    return doSomethingElse<span class="literal">()</span>;</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomethin<span class="literal">()</span>.<span class="keyword">then</span>(functiuoin <span class="literal">()</span> &#123;</span><br><span class="line">    doSomethingElse<span class="literal">()</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(doSomethingElse<span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(doSomethingElse);</span><br></pre></td></tr></table></figure>
<p>如果你知道这个问题的答案，那么恭喜你，你已经是一个 promise 大师并且可以直接关闭这个网页了。</p>
<p>但是对于不能回答这个问题的程序员中 <strong>99.9%</strong> 的人，别担心，你们不是少数派。没有人能够在笔者的 tweet 上完全正确的回答这个问题，而且对于 #3 最终答案也令我感到震惊，即便我是出题人。</p>
<p>答案在本文的底部，但是首先，笔者必须先探究一下 promise 为何如此复杂，为什么不管是新手还是专家都有被 promise 折磨的经历。同时，笔者也会给出自认为能够快速、准确理解 promise 的方法。而且笔者确信读过这篇文章之后，理解 promise 不会那么难了。</p>
<p>在此之前，我们先了解一下有关 promise 的一些常识。</p>
<a id="more"></a>
<h3 id="promise-的起源">Promise 的起源</h3>
<p>如果你读过有关 promise 的文章，你会发现文章中一定会提到 <a href="https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf" target="_blank" rel="external">Callback hell</a>，不说别的，在视觉上，回调金字塔会让你的代码最终超过屏幕的宽度。</p>
<p>promise 是能够解决这个问题的，但是它解决的问题不仅仅是缩进。在讨论到如何 <a href="https://www.youtube.com/watch?v=hf1T_AONQJU&amp;feature=youtu.be" target="_blank" rel="external">解决 Callback hell 问题</a> 的时候，我们遇到真正的难题是回调函数剥夺了程序员使用 return 和 throw 的能力。而程序的执行流程的基础建立于一个函数在执行过程中调用另一个函数时产生的副作用。(译者注：个人对这里副作用的理解是，函数调用函数会产生函数调用栈，而回调函数是不运行在栈上的，因此不能使用 return 和 throw)。</p>
<p>事实上，回调函数还有更恼人的——剥夺我们在栈上执行代码的能力，而在其他语言当中，我们始终都能够在栈上执行代码。编写不在栈上运行的代码就像开没有刹车的车一样，在你真正需要它的时候，才明白它有多么的重要。</p>
<p>promise 被设计为能够让我们重新使用那些编程语言的基本要素：return，throw，栈。在想要使用 promise 之前，我们首先要学会正确使用它。</p>
<h3 id="常见错误">常见错误</h3>
<p>一些人尝试使用 <a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html" target="_blank" rel="external">漫画</a> 的方式解释 promise，或者是像是解释名词一样解释它：它表示同步代码中的值，并且能在代码中被传递。</p>
<p>笔者并没有觉得这些解释对理解 promise 有用。笔者自己的理解是：promise 是关于代码结构和代码运行流程的。因此，笔者认为展示一些常见错误，并告诉大家如何修正它才是王道。</p>
<p>扯远一点，对于 promise，不同的人有不同的理解，为了本文的最终目的，我在这里只讨论 promise 的官方 <a href="https://promisesaplus.com/" target="_blank" rel="external">规范</a>，在较新版本的浏览器会作为 window 对象的一个属性被暴露出来。然而并不是所有的浏览器都支持这一特性，但是到目前为止有许多 polyfill，比如这个名字很大胆并且实现非常简洁的 promise 库：<a href="https://github.com/calvinmetcalf/lie" target="_blank" rel="external">Lie</a>。</p>
<h4 id="新手错误-no.1callback-hell">新手错误 No.1：Callback hell</h4>
<p>PouchDB 有许多 promise 风格的API，程序员在写有关 PouchDB 的代码的时候，常常将 promise 用的一塌糊涂。下面给出一种很常见的糟糕写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">remote.allDocs(&#123;</span><br><span class="line">    include_docs: <span class="literal">true</span>,</span><br><span class="line">    attachment: <span class="literal">true</span></span><br><span class="line">&#125;).then(functionb (result) &#123;</span><br><span class="line">    <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span> </span>&#123;</span><br><span class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span>&#123;</span><br><span class="line">            alert(<span class="string">'pulled doc with id'</span> + element.doc._id + <span class="string">'and added to local db.'</span>);&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err.status == <span class="number">409</span>) &#123;</span><br><span class="line">            localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> <span class="params">(resp)</span> </span>&#123;</span><br><span class="line">             localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> <span class="params">(resp)</span> </span>&#123;</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></table></figure>
<p>你确实可以将 promise 当做回调函数来使用，但这却是一种杀鸡用牛刀的行为。不过这么做也是可行的。 你可能会认为这种错误是那些刚入行的新手才会犯的。但是笔者在黑莓的 <a href="http://devblog.blackberry.com/2015/05/connecting-to-couchbase-with-pouchdb/" target="_blank" rel="external">开发者博客</a> 上曾经看到类似的代码。过去的书写回调函数的习惯是很难改变的。</p>
<p>下面给出一种代码风格更好的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(functioin (resultofAllDocs) &#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(resultOfPut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(resultOfGet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这就是 promise 的链式调用，它体现 promise 的强大之处，每个函数在上一个 promise 的状态变为 resolved 的时候才会被调用，并且能够得到上一个 promise 的输出结果。稍后还有详细的解释。</p>
<h4 id="新手错误-2怎样用-foreach-处理-promise">新手错误 2：怎样用 <code>forEach()</code> 处理 promise</h4>
<p>这个问题是大多数人掌握 promise 的绊脚石，当这些人想在代码中使用他们熟悉的 <code>forEach()</code> 方法或者是写一个 <code>for</code> 循环，抑或是 <code>while</code> 循环的时候，都会为如何使用 promise 而疑惑不已。他们会写下这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I want to remove() all docs</span></span><br><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(row)</span> </span>&#123;</span><br><span class="line">        db.remove(row.doc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// I naively believe all docs have been removed() now!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码的问题在于第一个回调函数实际上返回的是 <code>undefined</code>，也就意味着第二个函数并不是在所有的 <code>db.remove()</code> 执行结束之后才执行。事实上，第二个函数的执行不会有任何延时，它执行的时候被删除的 doc 数量可能为任意整数。</p>
<p>这段代码看起来是能够正常工作的，因此这个 bug 也具有一定的隐藏性。写这代码的人以为 PouchDB 已经删除了这些 docs，可以更新 UI 了。这个 bug 会在一定几率下出现，或者是特定的浏览器。而一旦出现，这种 bug 是很难调试的。</p>
<p>一言以蔽之，你需要的不是 <code>forEach()</code>/<code>for</code>/<code>while</code> 而是 <code>Promise.all()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Promise.all(result.rows.map(<span class="function"><span class="keyword">function</span> <span class="params">(row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(arrayObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从根本上说，<code>Promise.all()</code> 以一个 promise 对象组成的数组为输入，返回另一个 promise 对象。这个对象的状态只会在数组中所有的 promise 对象的状态都变为 resolved 的时候才会变成 resolved。可以将其理解为异步的 for 循环。</p>
<p><code>Promise.all()</code> 还会将计算结果以数组的形式传递给下一个函数，这一点十分有用。举例来说，如果你想用 get() 方法从 PouchDB 得到多个值的时候，就可以利用这个特性。同时，作为输入的一系列 promise 对象中，如果有一个的状态变为 rejected，那么 <code>all()</code>返回的 promise 对象的状态也会变为 rejected。</p>
<h4 id="新手错误-3忘记添加-catch-方法">新手错误 3：忘记添加 catch() 方法</h4>
<p>这是一个很常见的错误。很多程序员对他们代码中的 promise 调用十分自信，觉得代码永远不会抛出一个 <code>error</code>，也可能他们只是简单的忘了加 <code>catch()</code> 方法。不幸的是，不加 <code>catch()</code> 方法会让回调函数中抛出的异常被吞噬，在你的控制台是看不到相应的错误的，这对调试来说是非常痛苦的。</p>
<p>为了避免这种糟糕的情况，我已经养成了在自己的 promise 调用链最后添加如下代码的习惯：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">&#125;).catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></span><br></pre></td></tr></table></figure>
<p>即使你并不打算在代码中处理异常，在代码中添加 <code>catch()</code> 也是一个谨慎的编程风格的体现。在某种情况下你原先的假设出错的时候，这会让你的调试工作轻松一些。</p>
<h4 id="新手错误-4使用-deferred">新手错误 4：使用 “deferred”</h4>
<p>这类型 <a href="http://gonehybrid.com/how-to-use-pouchdb-sqlite-for-local-storage-in-your-ionic-app/" target="_blank" rel="external">错误</a> 笔者经常看到，在这里我也不想重复它了。简而言之，promise 经过了很长一段时间的发展，有一定的历史包袱。JavaScript 社区用了很长的时间才纠正了发展道路上的一些错误。jQuery 和 Angular 早期都在使用 ‘deferred’ 类型的 promise。而在最新的 ES6 的 Promise 标准中，这种实现方式已经被替代了，同时，一些 Promise 的库，比如 Q，bluebid，Lie 也是参照 ES6 的标准来实现的。</p>
<p>如果你还在代码中使用 ‘deferred’ 的话，那么你就是走在错误的道路上了，这里笔者给出一些修正的办法。</p>
<p>首先，绝大多数的库都给出了将第三方库的方法包装成 promise 对象的方法。举例来说，Angular 的 <span class="math">\(q 模块可以使用 `\)</span>q.when()` 完成这一包装过程。因此，在 Angular 中，包装 PouchDB 的 promise API的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then(...) <span class="comment">// &lt;-- this is all the code you need</span></span><br></pre></td></tr></table></figure>
<p>另一种方法就是使用暴露给程序员的 <a href="https://blog.domenic.me/the-revealing-constructor-pattern/" target="_blank" rel="external">构造函数</a>。promise 的构造函数能够包装那些非 promise 的 API。下面给出一个例子，在该例中将 Node.js 提供的 <code>fs.readFile()</code> 方法包装成 promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure>
<p>齐活！</p>
<blockquote>
<p>如果你想更多的了解为什么这样的写法是一个反模式，猛戳这里 <a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="external">the Bluebird wiki page on promise anti-patterns</a></p>
</blockquote>
<h4 id="新手错误-5不显式调用-return">新手错误 5：不显式调用 return</h4>
<p>下面这段代码的问题在哪里？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    someOtherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Gee, I hope someOtherPromise() has resolved</span></span><br><span class="line">    <span class="comment">// Spoiler alert: it hasn't</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在该讨论所有需要了解的关于 promise 的知识点了。理解了这一个知识点，笔者提到的一些错误你都不会犯了。</p>
<p>正如笔者前面所说的，promise 的神奇之处在于让我们能够在回调函数里面使用 return 和 throw。但是实践的时候是什么样子呢？</p>
<p>每一个 promise 对象都会提供一个 then 方法或者是 catch 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 then 方法内部，我们可以做三件事：</p>
<ol style="list-style-type: decimal">
<li><code>return</code> 一个 promise 对象</li>
<li><code>return</code> 一个同步的值或者是 <code>undefined</code></li>
<li>同步的 <code>throw</code> 一个错误</li>
</ol>
<p>理解这三种情况之后，你就会理解 promise 了。</p>
<ol style="list-style-type: decimal">
<li>返回另一个 promise 对象</li>
</ol>
<p>在有关 promise 的相关文章中，这种写法很常见，就像上文提到的构成 promise 链的一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(funcxtion (userAccount) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码里面的 return 非常关键，没有这个 return 的话，<code>getUserAccountById</code> 只是一个普通的被别的函数调用的函数。下一个回调函数会接收到 <code>undefined</code> 而不是 <code>userAccount</code></p>
<ol start="2" style="list-style-type: decimal">
<li>返回一个同步的值或者是 <code>undefined</code></li>
</ol>
<p>返回一个 <code>undefined</code> 大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成 promise 风格代码的好方法。举个例子，现在在内存中有 users。我们可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(fcuntion (user) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inMemoryCache[user.id];  <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a promise</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// I got a user account</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第二个回调函数并不关心 <code>userAccount</code> 是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数即可以返回同步的值又可以返回异步的值。</p>
<p>不幸的是，如果不显式调用 return 语句的话，JavaScript 里的函数会返回 <code>undefined</code>。这也就意味着在你想返回一些值的时候，不显式调用 return 会产生一些副作用。</p>
<p>鉴于以上原因，笔者养成了一个在 then 方法内部永远显式的调用 return 或者 throw 的习惯。建议你也这样做。</p>
<ol start="3" style="list-style-type: decimal">
<li>抛出一个同步的错误</li>
</ol>
<p>说到 throw，这又体现了 promise 的功能强大。在用户退出的情况下，我们的代码中会采用抛出异常的方式进行处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Boo, I got an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果用户已经登出的话，<code>catch()</code> 会收到一个同步的错误，如果有 promise 对象的状态变为 rejected 的话，它还会收到一个异步的错误。<code>catch()</code> 的回调函数不用关心错误是异步的还是同步的。</p>
<p>在使用 promise 的时候抛出异常在开发阶段很有用，它能帮助我们定位代码中的错误。比方说，在 then 函数内部调用 <code>JSON.parse（）</code>，如果 JSON 对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用 promise 之后，我们就可以捕获到这个异常了。</p>
<h3 id="进阶错误">进阶错误</h3>
<p>接下来我们讨论一下使用 promise 的边界情况。</p>
<p>下面的错误笔者将他们归类为 <strong>“进阶错误”</strong>，因为这些错误发生在那些已经相对熟练使用 promise 的程序员身上。但是为了解决本文开头提出的问题，还是有必要对其进行讨论。</p>
<h4 id="进阶错误-1不了解-promise.resolve">进阶错误 1：不了解 Promise.resolve()</h4>
<p>就像之前所说的，promise 能够将同步代码包装成异步的形式。然而，如果你经常写出如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line">  resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(...);</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>Promise.resolve()</code> 将上述代码精简。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(someSynchronousValue).then(...);</span><br></pre></td></tr></table></figure>
<p>在捕获同步异常的时候这个做法也是很有效的。我在编写 API 的时候已经养成了使用 <code>Promise.resolve()</code> 的习惯：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Promise.resolve().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomethingThatMayThrow();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">  &#125;).then(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住，有可能抛出错误的代码都有可能因为错误被吞噬而对你的工作造成困扰。但是如果你用 <code>Promise.resolve()</code> 包装了代码的话，你永远都可以在代码后面加上 <code>catch()</code>。</p>
<p>相同的，使用 <code>Promise.reject()</code> 可以立即返回一个状态为 rejected 的 promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</span><br></pre></td></tr></table></figure>
<h4 id="进阶错误-2cacth-和-thennull-...-并不完全相同">进阶错误 2：<code>cacth()</code> 和 <code>then(null, ...)</code> 并不完全相同</h4>
<p>笔者提到过 <code>cacth()</code> 是 <code>then(null, ...)</code> 的语法糖，因此下面两个代码片段是等价的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是，这并不意味着下面的两个代码片段是等价的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你不理解的话，那么请思考一下如果第一个回调函数抛出一个错误会发生什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// I caught your error! :)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结论就是，当使用 <code>then(resolveHandler, rejectHandler)</code>，<code>rejectHandler</code> 不会捕获在 <code>resolveHandler</code> 中抛出的错误。</p>
<p>因为，笔者的个人习惯是从不使用 then 方法的第二个参数，转而使用 <code>catch()</code> 方法。但是也有例外，就是在笔者写异步的 <a href="http://mochajs.org/" target="_blank" rel="external">Mocha</a> 的测试用例的时候，如果想确认一个错误被抛出的话，代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingThatThrows().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I expected an error!'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">    should.exist(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>说到测试，将 mocha 和 Chai 联合使用是一种很好的测试 promise API 的方案。</p>
<h4 id="进阶错误-3promise-vs-promise-factories">进阶错误 3：promise vs promise factories</h4>
<p>某些情况下你想一个接一个的执行一系列 promise，这时候你想要一个类似于 <code>Promise.all()</code> 的方法，但是 <code>Proimise.all()</code> 是并行执行的，不符合要求。你可能一时脑抽写下这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span><span class="params">(promises)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = Promise.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(promise)</span> </span>&#123;</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，这段代码不会按照你所想的那样执行，那些 promise 对象里的异步调用还是会并行的执行。原因是你根本不应当在 promise 对象组成的数组这个层级上操作。对于每个 promise 对象来说，一旦它被创建，相关的异步代码就开始执行了。因此，这里你真正想要的是一个 promise 工厂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span><span class="params">(promiseFactories)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = Promise.resolve();</span><br><span class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(promiseFactory)</span> </span>&#123;</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 promise 工厂非常简单，它就是一个返回 promise 对象的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么采用 promise 对象就可以达到目的呢？因为 promise 工厂只有在调用的时候才会创建 promise 对象。它和 <code>then()</code> 方法的工作方式很像，事实上，它们就是一样的东西。</p>
<h4 id="进阶错误-4如果我想要两个-promise-的结果应当如何做呢">进阶错误 4：如果我想要两个 promise 的结果应当如何做呢？</h4>
<p>很多时候，一个 promise 的执行是依赖另一个 promise 的。但是在某些情况下，我们想得到两个 promise 的执行结果，比方说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// dangit, I need the "user" object too!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了避免金字塔问题，我们可能会在外层作用域存储 user 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">  user = result;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// okay, I have both the "user" and the "userAccount"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码能够到达想要的效果，但是这种显得不够专业，我建议抛开成见，拥抱金字塔：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>至少，是暂时拥抱金字塔。如果缩进真的成为了你代码中的一个大问题，那么你可以像每一个 JavaScript 程序员从开始写代码起就被教导的一样，将其中的部分抽出来作为一个单独的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span><span class="params">(user, userAccount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(onGetUser)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>随着你的 promise 代码越来越复杂，你会将越来越多的代码作为函数抽离出来。笔者发现这会促进代码风格变得优美：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn()</span><br><span class="line">  .then(putYourRightFootOut)</span><br><span class="line">  .then(putYourRightFootIn)</span><br><span class="line">  .then(shakeItAllAbout);</span><br></pre></td></tr></table></figure>
<p>这就是 promise 的最终目的。</p>
<h4 id="进阶错误-5promise-穿透">进阶错误 5：promise 穿透</h4>
<p>这个错误我在前文中提到的问题中间接的给出了。这是个非常令人费解的案例，或许你永远不会写出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'foo'</span>).then(Promise.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你认为输出的是 bar，那么你就错了。实际上它输出的是 foo！</p>
<p>产生这样的输出是因为你给 then 方法传递了一个非函数（比如 promise 对象）的值，代码会这样理解：<code>then(null)</code>，因此导致前一个 promise 的结果产生了坠落的效果。你可以自己测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'foo'</span>).then(<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>随便添加任意多个 <code>then(null)</code>，结果都是不变的</p>
<p>让我们回到之前讲解 promise vs promise factoriesde 的地方。简而言之，如果你直接给 then 方法传递一个 promise 对象，代码的运行是和你所想的不一样的。then 方法应当接受一个函数作为参数。因此你应当这样书写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Promise.resolve(<span class="string">'bar'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就会如愿输出 bar。</p>
<h3 id="答案来了">答案来了！</h3>
<p>下面给出前文题目的解答</p>
<p>#1</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;).<span class="keyword">then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案： <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line"><span class="string">|-----------------|</span></span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  <span class="string">|------------------|</span></span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     <span class="string">|------------------|</span></span><br></pre></td></tr></table></figure></p>
<p>#2</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(<span class="keyword">function</span> <span class="literal">()</span> &#123;</span><br><span class="line">  doSomethingElse<span class="literal">()</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line"><span class="string">|-----------------|</span></span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  <span class="string">|------------------|</span></span><br><span class="line">                  finalHandler(undefined)</span><br><span class="line">                  <span class="string">|------------------|</span></span><br></pre></td></tr></table></figure>
<p>#3</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(doSomethingElse<span class="literal">()</span>)</span><br><span class="line">  .<span class="keyword">then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line"><span class="string">|-----------------|</span></span><br><span class="line">doSomethingElse(undefined)</span><br><span class="line"><span class="string">|---------------------------------|</span></span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  <span class="string">|------------------|</span></span><br></pre></td></tr></table></figure>
<p>#4</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(doSomethingElse)</span><br><span class="line">  .<span class="keyword">then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line"><span class="string">|-----------------|</span></span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  <span class="string">|------------------|</span></span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     <span class="string">|------------------|</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要说明的是，在上述的例子中，我都假设 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 返回一个 promise 对象，这些 promise 对象都代表了一个异步操作，这样的操作会在当前 event loop 之外结束，比如说有关 IndexedDB，network 的操作，或者是使用 <code>setTimeout</code>。这里给出 <a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="external">JSBin</a> 上的示例。</p>
</blockquote>
<h3 id="最后的话">最后的话</h3>
<p>promise 是个好东西。如果你还在使用传统的回调函数的话，我建议你迁移到 promise 上。这样你的代码会更简洁，更优雅，可读性也更强。</p>
<p>有这样的观点：promise 是不完美的。promise 确实比使用回调函数好，但是，如果你有别的选择的话，这两种方式最好都不要用。</p>
<p>尽管相比回调函数有许多优点，promise 仍然是难于理解的，并且使用起来很容易出错。新手和卖家都会经常将 promise 用的乱七八糟。不过这并不是他们的错。问题在于 promise 和我们写的同步代码非常相似，但仅此而已，并不尽然。</p>
<p>在同步环境下，你无需学习这些晦涩难懂的规则和新的 API。你可以随意使用像 return、catch 和 throw 这样的关键字以及 for 循环。你不需要时刻在脑中保持两个相并列的编程思想。</p>
<h3 id="等待-asyncawait">等待 async/await</h3>
<p>笔者在了解了ES7中的 async 和 await 关键字，以及它们是如何将 promise 的思想融入到语言本身当中之后，写了这样一篇博文 <a href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html" target="_blank" rel="external">用ES7驯服异步这个猛兽</a>。使用 ES7，我们将没有必要再写 catch() 这样的伪同步的代码，我们将能使用 try/catch/return 这样的关键字，就像刚开始学计算机那样。</p>
<p>这对 JavaScript 这门语言来说是很好的，因为到头来，只要没有工具提醒我们，这些 promise 的反模式会持续出现。</p>
<p>从 JavaScript 发展历史中距离来说，笔者认为 JSLint 和 JSHint 对社区的贡献要大于 <a href="http://www.amazon.com/dp/0596517742/ref=cm_sw_su_dp" target="_blank" rel="external">JavaScript:The Good Parts</a>，尽管它们实际上包含的信息是相同的。区别就在于使用工具可以告诉程序员代码中所犯的错误，而阅读却是让你了解别人犯的错误。</p>
<p>ES7 中的 async 和 await 关键字的美妙之处在于，你代码中的错误将会成为语法错误或者是编译错误，而不是细微的运行时错误。到了那时，我们会完全掌握 promise 究竟能做什么，以及在 ES5 和 ES6 中如何合理的应用。</p>
";s:7:"summary";s:3292:"
    <blockquote>
<p>本文翻译自 <a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html">We have a problem with promises</a>，为原文题目重新起了一个题目并且对原文有删改。</p>
</blockquote>
<p>各位 JavaScript 程序员，是时候承认了，我们在使用 promise 的时候，会写出许多有问题的 promise 代码。 当然并不是 promise 本身的问题，<a href="https://promisesaplus.com/">A+ spec</a> 规范定义的 promise 非常棒。 在过去的几年中，笔者看到了很多程序员在调用 PouchDB 或者其他 promise 化的 API 时遇到了很多困难。这让笔者认识到，在 JavaScript 程序员之中，只有少数人是真正理解了 promise 规范的。如果这个事实让你难以接受，那么思考一下我在 <a href="https://twitter.com/nolanlawson/status/578948854411878400">Twitter</a> 上出的题：</p>
<blockquote>
<p>问：下面四个使用 promise 的语句之间的不同点在哪儿？</p>
</blockquote>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(<span class="keyword">function</span> <span class="literal">()</span> &#123;</span><br><span class="line">    return doSomethingElse<span class="literal">()</span>;</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomethin<span class="literal">()</span>.<span class="keyword">then</span>(functiuoin <span class="literal">()</span> &#123;</span><br><span class="line">    doSomethingElse<span class="literal">()</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(doSomethingElse<span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">doSomething<span class="literal">()</span>.<span class="keyword">then</span>(doSomethingElse);</span><br></pre></td></tr></table></figure>
<p>如果你知道这个问题的答案，那么恭喜你，你已经是一个 promise 大师并且可以直接关闭这个网页了。</p>
<p>但是对于不能回答这个问题的程序员中 <strong>99.9%</strong> 的人，别担心，你们不是少数派。没有人能够在笔者的 tweet 上完全正确的回答这个问题，而且对于 #3 最终答案也令我感到震惊，即便我是出题人。</p>
<p>答案在本文的底部，但是首先，笔者必须先探究一下 promise 为何如此复杂，为什么不管是新手还是专家都有被 promise 折磨的经历。同时，笔者也会给出自认为能够快速、准确理解 promise 的方法。而且笔者确信读过这篇文章之后，理解 promise 不会那么难了。</p>
<p>在此之前，我们先了解一下有关 promise 的一些常识。</p>
    
    ";}i:4;a:7:{s:5:"title";s:19:"ES Decorators简介";s:5:"link_";s:55:"http://efe.baidu.com/blog/introduction-to-es-decorator/";s:2:"id";s:55:"http://efe.baidu.com/blog/introduction-to-es-decorator/";s:9:"published";s:24:"2015-07-16T16:00:00.000Z";s:7:"updated";s:24:"2015-07-17T07:08:46.000Z";s:12:"atom_content";s:41878:"<p>我跟你说，我最讨厌“简介”这种文章了，要不是语文是体育老师教的，早就换标题了！</p>
<p><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">Decorators</a>是ECMAScript现在处于<a href="https://github.com/tc39/ecma262" target="_blank" rel="external">Stage 1</a>的一个提案。当然ECMAScript会有很多新的特性，特地介绍这一个是因为它能够在实际的编程中提供很大的帮助，甚至于改变不少功能的设计。</p>
<h3 id="先说说怎么回事">先说说怎么回事</h3>
<p>如果光从概念上来介绍的话，官方是这么说的：</p>
<blockquote>
<p>Decorators make it possible to annotate and modify classes and properties at design time.</p>
</blockquote>
<p>我翻译一下：</p>
<blockquote>
<p>装饰器让你可以在设计时对类和类的属性进行注解和修改。</p>
</blockquote>
<p>什么鬼，说人话！</p>
<p>所以我们还是用一段代码来看一下好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span><span class="params">(target, key, descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Map();</span><br><span class="line">    <span class="keyword">let</span> oldMethod = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="params">(...args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> hash = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (cache.has(hash)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> value = oldMethod.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        cache.set(hash, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    @memoize;</span><br><span class="line">    getFooById(id) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别去试上面的代码，瞎写的，估计跑不起来就是了。这个代码的作用其实看函数的命名就能明白，我们要给<code>Foo#getFooById</code>方法加一个缓存，缓存使用第一个参数作为对应的键。</p>
<p>可以看出来，上面代码的重点在于：</p>
<a id="more"></a>
<ol style="list-style-type: decimal">
<li>有一个<code>memoize</code>函数。</li>
<li>在类的某个方法上加了<code>@memoize;</code>这样一个标记。</li>
</ol>
<p>而这个<code>@memoize</code>就是所谓的Decorator，我称之为装饰器。一个装饰器有以下特点：</p>
<ol style="list-style-type: decimal">
<li>首先它是一个函数。</li>
<li>这个函数会接收3个参数，分别是<code>target</code>、<code>key</code>和<code>descriptor</code>，具体的作用后面再说。</li>
<li>它可以修改<code>descriptor</code>做一些额外的逻辑。</li>
</ol>
<p>看到了基本用法其实并不能说明什么，我们有几个核心的问题有待说明：</p>
<h4 id="有几种装饰器">有几种装饰器</h4>
<p>现阶段官方说有2种装饰器，但从实际使用上来看是有4种，分别是：</p>
<ul>
<li>放在<code>class</code>上的“类装饰器”。</li>
<li>放在属性上的“属性装饰器”，这需要配合另一个Stage 0的<a href="https://gist.github.com/jeffmo/054df782c05639da2adb" target="_blank" rel="external">类属性语法</a>提案，或者只能放在对象字面量上了。</li>
<li>放在方法上的“方法装饰器”。</li>
<li>放在<code>getter</code>或<code>setter</code>上的“访问器装饰器”。</li>
</ul>
<p>其中类装饰器只能放在<code>class</code>上，而另外3种可以同时放在<code>class</code>和属性或者对象字面量的属性上，比如这样也是可以的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    @memoize</span><br><span class="line">    getFooById(id) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过注意放在对象字面量时，装饰器后面不能写分号，这是个比较怪异的问题，后面还会说到更怪异的情况，我也在和提案的作者沟通这是为啥。</p>
<p>之所以这么分，是因为不同情况下，装饰器接收的3个参数代表的意义并不相同。</p>
<h4 id="装饰器的3个参数是什么">装饰器的3个参数是什么</h4>
<p>装饰器接收3个参数，分别是<code>target</code>、<code>key</code>和<code>descriptor</code>，他们各自分别是什么值，用一段代码就能很容易表达出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(target, key, descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">'constructor'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(target.constructor);</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar &#123;</span><br><span class="line">    @log;</span><br><span class="line">    bar() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// function Bar() &#123; ...</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// &#123;"enumerable":false,"configurable":true,"writable":true&#125;</span></span><br></pre></td></tr></table></figure>
<p>这是使用<a href="babeljs.io">babel</a>转换的JavaScript的输出，从这里可以看到：</p>
<ol style="list-style-type: decimal">
<li><code>key</code>很明显就是当前方法名，我们可以推断出来用于属性的时候就是属性名</li>
<li><code>descriptor</code>显然是一个<code>PropertyDescriptor</code>，就是我们用于<code>defineProperty</code>时的那个东西。</li>
<li><code>target</code>确实不是那么容易看出来，所以我用了3行代码。首先这是一个对象，然后是一个有<code>constructor</code>属性的对象，最后<code>constructur</code>指向的是<code>Bar</code>这个函数。所以我们也能推测出来这货就是<code>Bar.prototype</code>没跑了。</li>
</ol>
<p>那如果装饰器放在对象字面量上，而不是类上呢？这边就不再给代码，直接放结论了：</p>
<ol style="list-style-type: decimal">
<li><code>key</code>和<code>descriptor</code>和放在类属性/方法上一样没变，这当然也不应该变。</li>
<li><code>target</code>是<code>Object</code>对象，相信我你不会想用这个参数的。</li>
</ol>
<p>当装饰器放在属性、方法、访问器上时，都符合上面的原则，但放在类上的时候，有一些不同：</p>
<ol style="list-style-type: decimal">
<li><code>key</code>和<code>descriptor</code>不会提供，只有<code>target</code>参数。</li>
<li><code>target</code>会变成<code>Bar</code>这个方法，而不是其<code>prototype</code>。</li>
</ol>
<p>其实对于属性、方法和访问器，真正有用的就是<code>descriptor</code>，其它几个无视问题也不大就是了。而对于类，由于<code>target</code>是唯一能用的，所以会需要它。</p>
<p>对于这一环节，我们<strong>需要特别注意一点</strong>，由于<code>target</code>是类的<code>prototype</code>，所以往它上面添加属性是，要注意继承时是会被继承下去的，而子类上再加同样属性又会有覆盖甚至对象、数组同引用混在一起的问题。这和我们平时尽量不在<code>prototype</code>上放对象或者数组的思路是一致的，要避免这一问题。</p>
<h4 id="装饰器在什么时候执行">装饰器在什么时候执行</h4>
<p>既然装饰器本身是一个函数，那么自然要有函数被执行的时候。</p>
<p>现阶段，装饰器只能放在一个类或者一个对象上，我们可以用代码看一下什么时候执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 既然装饰器是函数，我当然可以用函数工厂了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before class'</span>);</span><br><span class="line"></span><br><span class="line">@log(<span class="string">'class Bar'</span>)</span><br><span class="line"><span class="keyword">class</span> Bar &#123;</span><br><span class="line">    @log(<span class="string">'class method bar'</span>);</span><br><span class="line">    bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @log(<span class="string">'class getter alice'</span>);</span><br><span class="line">    get alice() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @log(<span class="string">'class property bob'</span>);</span><br><span class="line">    bob = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after class'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">    @log(<span class="string">'object method bar'</span>)</span><br><span class="line">    bar() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before class</span><br><span class="line">class <span class="keyword">method</span> bar</span><br><span class="line">class getter alice</span><br><span class="line">class property bob</span><br><span class="line">class <span class="type">Bar</span></span><br><span class="line">after class</span><br><span class="line"><span class="keyword">object</span> <span class="keyword">method</span> bar</span><br></pre></td></tr></table></figure>
<p>从输出上，我们可以看到几个规则：</p>
<ul>
<li>装饰器是在声明期就起效的，并不需要类进行实例化。类实例化并不会致使装饰器多次执行，因此不会对实例化带来额外的开销。</li>
<li>按编码时的声明顺序执行，并不会将属性、方法、访问器进行重排序。</li>
</ul>
<p>因为以上这2个规则，我们需要<strong>特别注意一点</strong>，在装饰器运行时，你所能得到的环境是空的，在<code>Bar.prototype</code>或者<code>Bar</code>上的属性是获取不到的，也就是说整个<code>target</code>里其实只有<code>constructor</code>这一个属性。换句话说，装饰器运行时所有的属性和方法均<strong>未定义</strong>。</p>
<h4 id="descriptor里有啥">descriptor里有啥</h4>
<p>我们都知道，<code>PropertyDescriptor</code>的基本内容如下：</p>
<ul>
<li><code>configurable</code>控制是不是能删、能修改<code>descriptor</code>本身。</li>
<li><code>writable</code>控制是不是能修改值。</li>
<li><code>enumerable</code>控制是不是能枚举出属性。</li>
<li><code>value</code>控制对应的值，方法只是一个<code>value</code>是函数的属性。</li>
<li><code>get</code>和<code>set</code>控制访问咕噜的读和写逻辑。</li>
</ul>
<p>根据装饰器放的位置不同，<code>descriptor</code>参数中就会有上面的这些属性，其中前3个是必然存在的，随后根据放在属性、方法上还是放在访问器上决定是<code>value</code>还是<code>get/set</code>。</p>
<p>再说说类属性的情况，由于类属性本身是一个比装饰器更不靠谱的Stage 0的提案，所以情况就会变成2个提案的相互作用了。</p>
<p>当装饰器用于类属性时，<code>descriptor</code>将变成一个叫“类属性描述符”的东西，其区别在于没有<code>value</code>和<code>get</code>或<code>set</code>，且多出一个<code>initializer</code>属性，类型是函数，在类构造函数执行时，<code>initializer</code>返回的值作为属性的值，也就是说一个<code>foo</code>属性对应代码是类似这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getPropertyDescriptor(<span class="keyword">this</span>, <span class="string">'foo'</span>);</span><br><span class="line">        <span class="keyword">this</span>.foo = descriptor.initializer.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们也可以写很简单的装饰器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomize</span><span class="params">(target, key, descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> raw = descriptor.initializer;</span><br><span class="line">    descriptor.initializer = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value = raw.call(<span class="keyword">this</span>);</span><br><span class="line">        value += <span class="string">'-'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1e6</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Alice &#123;</span><br><span class="line">    @randomize;</span><br><span class="line">    name = <span class="string">'alice'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> Alice()).name); <span class="comment">// alice-776521</span></span><br></pre></td></tr></table></figure>
<h3 id="再说说怎么用">再说说怎么用</h3>
<p>在基本把概念说完后，其实我们并没有说装饰器怎么用，虽然前面有一些代码，但并不能逻辑完善地说明问题。</p>
<h4 id="descriptor的使用">descriptor的使用</h4>
<p>对于属性、方法、访问器的装饰器，真正的作用在于对<code>descriptor</code>这个属性的修改。我们拿一些原始的例子来看，比如你要给一个对象声明一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> property = &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(foo, <span class="string">'foo'</span>, property);</span><br></pre></td></tr></table></figure>
<p>但是我们现在又不高兴了，我们希望这个属性是只读的，OK这是个非常简单的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> property = &#123;</span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 加一行解决问题</span></span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(foo, <span class="string">'foo'</span>, property);</span><br></pre></td></tr></table></figure>
<p>但是有时候，我们面对几百几千个属性，真心不想一个一个写<code>writable: false</code>，看着也不容易明白。或者这个<code>descriptor</code>根本是其他地方给我们的，我们只有<code>defineProperty</code>的权利，无法修改原来的东西，所以我们希望是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(foo, <span class="string">'foo'</span>, readOnly(property));</span><br></pre></td></tr></table></figure>
<p>通过函数式的编程进行函数转换，既能读代码时就看出来这是只读的，又能用在所有以前的<code>descriptor</code>上而不需要改以前的代码，将“定义”和“使用”分离了开来。</p>
<p>而装饰器无非是将这件事放到了语法的层面上，我们有一个机会在类或者属性、访问器、方法定义的时候去修改它的<code>descriptor</code>，这种对“元数据”的修改使得我们有很大的灵活性，包括但不局限于：</p>
<ol style="list-style-type: decimal">
<li>通过<code>descriptor.value</code>的修改直接给改成不同的值，适用于方法的装饰器。</li>
<li>通过<code>descriptor.get</code>或<code>descriptor.set</code>修改逻辑，适用于访问器的装饰器。</li>
<li>通过<code>descriptor.initializer</code>修改属性值，适用于属性的装饰器。</li>
<li>修改<code>configurable</code>、<code>writable</code>、<code>enumerable</code>控制属性本身的特性，常见的就是修改为只读。</li>
</ol>
<p>装饰器是最后的修改<code>descriptor</code>的机会，再往后如果<code>configurable</code>被设为<code>false</code>的话，就再也没机会去改变这些元数据了。</p>
<h4 id="类装饰器的使用">类装饰器的使用</h4>
<p>类装饰器不大一样，因为没有<code>descriptor</code>给你，你唯一能获得的是<strong>类本身</strong>，也就是一个函数。</p>
<p>但是有了类本身，我们可以做一件事，就是继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countInstance</span><span class="params">(target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> extends target &#123;</span><br><span class="line">        constructor(...args) &#123;</span><br><span class="line">            super(...args);</span><br><span class="line">            <span class="keyword">let</span> count = counter.get(target) || <span class="number">0</span>;</span><br><span class="line">            counter.set(target, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static getInstanceCount() &#123;</span><br><span class="line">            <span class="keyword">return</span> counter.get(target) || <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@countInstance</span><br><span class="line"><span class="keyword">class</span> Bob &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bob();</span><br><span class="line"><span class="keyword">new</span> Bob();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Bob.getInstanceCount()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="实际的使用场景">实际的使用场景</h4>
<p>上面的代码可能都很扯谈，谁会有这种奇怪的需求，所以举一些真正实用的代码来看看。</p>
<p>一个比较可能的场合是在制作一个视图类的时候，我们可以：</p>
<ul>
<li>通过访问器装饰器来声明类属性与DOM元素之间的绑定关系。</li>
<li>通过方法装饰器指定方法处理某个DOM元素的某个事件。</li>
<li>通过类装饰器指定一个类为视图处理类，且在<code>DOMContentLoaded</code>时执行。</li>
</ul>
<p>参考代码如下，以一个简单的登录表单为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DOM_EVENTS = Symbol(<span class="string">'domEvents'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">view</span><span class="params">(ViewClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> AutoView extends ViewClass &#123;</span><br><span class="line">        initialize() &#123;</span><br><span class="line">            super.initialize();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册所有事件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> &#123;id, type, handler&#125; of <span class="keyword">this</span>[DOM_EVENTS]) &#123;</span><br><span class="line">                <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">                element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> executeView = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="keyword">new</span> AutoView();</span><br><span class="line">        view.initialize();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMConentLoaded'</span>, executeView);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AutoView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dom</span><span class="params">(id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(target, key, descriptor)</span> </span>&#123;</span><br><span class="line">        descriptor.get = () =&gt; <span class="built_in">document</span>.getElementById(id || key);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">event</span><span class="params">(id, type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (target, key, descriptor) &#123;</span><br><span class="line">        <span class="comment">// 注意target是prototype，所以如果原来已经有了对象要做复制，不能直接污染</span></span><br><span class="line">        target[DOM_EVENTS] = target.hasOwnProperty(DOM_EVENTS) ? target[DOM_EVENTS].slice() : [];</span><br><span class="line"></span><br><span class="line">        target[DOM_EVENTS].push(&#123;id, type, handler: descriptor.value&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@view</span><br><span class="line"><span class="keyword">class</span> LoginForm &#123;</span><br><span class="line">    @dom()</span><br><span class="line">    get username() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @dom()</span><br><span class="line">    get password() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @dom()</span><br><span class="line">    get captcha() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @dom(<span class="string">'captcha-code'</span>)</span><br><span class="line">    get captchaImage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @event(<span class="string">'form'</span>, <span class="string">'submit'</span>)</span><br><span class="line">    [Symbol()](e) &#123;</span><br><span class="line">        <span class="keyword">let</span> isValid = <span class="keyword">this</span>.validateForm();</span><br><span class="line">        <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @event(<span class="string">'captcha-code'</span>, <span class="string">'click'</span>)</span><br><span class="line">    [Symbol()]() &#123;</span><br><span class="line">        <span class="comment">// 点击刷新验证码</span></span><br><span class="line">        <span class="keyword">this</span>.captchaImage.src = <span class="keyword">this</span>.captchaImage.src + <span class="string">'x'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validateForm() &#123;</span><br><span class="line">        <span class="keyword">let</span> isValid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.username.value.trim()) &#123;</span><br><span class="line">            showError(username, <span class="string">'请输入用户名'</span>);</span><br><span class="line">            isValid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.password.value.trim()) &#123;</span><br><span class="line">            showError(username, <span class="string">'请输入密码'</span>);</span><br><span class="line">            isValid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.captcha.value.trim()) &#123;</span><br><span class="line">            showError(username, <span class="string">'请输入验证码'</span>);</span><br><span class="line">            isValid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种编程方式我们经常称之为“声明式编程”，好处是更为直观，且能够通过装饰器等手段复用逻辑。</p>
<p>这只是一个很简单直观的例子，我们用装饰器可以做更多的事，有待在实际开发中慢慢发掘，同时<a href="https://github.com/mako-taco/DecorateThis" target="_blank" rel="external">DecorateThis</a>项目给我们做了不少的示范，虽然我觉得这个库提供的装饰器并没有什么卯月……</p>
<h3 id="题外话的概念和坑">题外话的概念和坑</h3>
<p>到这边基本把装饰器的概念和使用都讲了，我理解有不少FE一时不好接受这些（QWrap那边的人倒应该能非常迅速地接受这种函数式的玩法），后面说一些题外话，主要是装饰器与其它语言类似功能的比较，以及一些坑爹的坑。</p>
<h4 id="和其它语言的比较">和其它语言的比较</h4>
<p>大部分开发者都会觉得装饰器这个语法很眼熟，因为我们在Java中有<a href="https://en.wikipedia.org/wiki/Java_annotation" target="_blank" rel="external">Annotation</a>这个东西，而在C#中也有<a href="https://msdn.microsoft.com/en-us/library/aa288454(v=vs.71).aspx" target="_blank" rel="external">Attribute</a>这个东西。</p>
<p>所以我说为啥一个语言搞一个东西还要名字不一样啊……我推荐PHP也来一个，就叫<code>GreenHat</code>好了……</p>
<p>不过有些同学可能会受此误导，其实装饰器和Java、C#里的东西不一样。</p>
<p>其区别在于Annotation和Attribute是一种元数据的声明，仅包含信息（数据），而不包含任何逻辑，必须有外部的逻辑来读取这些信息产生分支才有作用，比如<code>@override</code>这个Annotation相对应的逻辑在编译器是实现，而不是在对应的class中实现。</p>
<p>而装饰器，和Python的相同功能同名（赤裸裸的抄袭），其核心是一段逻辑，起源于<a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="external">装饰器设计模式</a>，让你有机会去改变一个方法、属性、类的逻辑，<a href="http://stackoverflow.com/questions/15347136/is-a-python-decorator-the-same-as-java-annotation-or-java-with-aspects" target="_blank" rel="external">StackOverflow上Python的回答</a>能比较好地解释这个区别。</p>
<h4 id="几个坑">几个坑</h4>
<p>在我看来，装饰器现在有几个坑得注意一下。</p>
<p>首先，语法上很奇怪，特别是在装饰器后面的分号上。属性、访问器、方法的装饰器后面是可以加分号的，并且个人推荐加上，不然你可能遇到这样的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    @bar</span><br><span class="line">    [<span class="number">1</span> + <span class="number">2</span>]() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码到底是<code>@bar</code>作为装饰器的方法呢，还是<code>@bar[1 + 2]()</code>后跟着一个空的Block<code>{}</code>呢？</p>
<p>但是，放在类上的装饰器，以及放在对象字面量的属性、访问器、方法上的装饰器，是不能加分号的， 不然就是语法错误。我不明白为啥就不能加分号，以至于这个语法简直精神分裂……</p>
<p>其次，如果你把装饰器用在类的属性上，建议<strong>一定加上分号</strong>，看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    @bar</span><br><span class="line">    foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想一想如果因为特性比较新，压缩工具一个没做好没给补上分号压成了一行，这是一个怎么样的代码……</p>
<h3 id="总结">总结</h3>
<p>我不写总结，就酱。</p>
";s:7:"summary";s:3660:"
    <p>我跟你说，我最讨厌“简介”这种文章了，要不是语文是体育老师教的，早就换标题了！</p>
<p><a href="https://github.com/wycats/javascript-decorators">Decorators</a>是ECMAScript现在处于<a href="https://github.com/tc39/ecma262">Stage 1</a>的一个提案。当然ECMAScript会有很多新的特性，特地介绍这一个是因为它能够在实际的编程中提供很大的帮助，甚至于改变不少功能的设计。</p>
<h3 id="先说说怎么回事">先说说怎么回事</h3>
<p>如果光从概念上来介绍的话，官方是这么说的：</p>
<blockquote>
<p>Decorators make it possible to annotate and modify classes and properties at design time.</p>
</blockquote>
<p>我翻译一下：</p>
<blockquote>
<p>装饰器让你可以在设计时对类和类的属性进行注解和修改。</p>
</blockquote>
<p>什么鬼，说人话！</p>
<p>所以我们还是用一段代码来看一下好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span><span class="params">(target, key, descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Map();</span><br><span class="line">    <span class="keyword">let</span> oldMethod = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="params">(...args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> hash = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (cache.has(hash)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> value = oldMethod.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        cache.set(hash, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    @memoize;</span><br><span class="line">    getFooById(id) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别去试上面的代码，瞎写的，估计跑不起来就是了。这个代码的作用其实看函数的命名就能明白，我们要给<code>Foo#getFooById</code>方法加一个缓存，缓存使用第一个参数作为对应的键。</p>
<p>可以看出来，上面代码的重点在于：</p>
    
    ";}i:5;a:7:{s:5:"title";s:34:"HTML代码风格检查工具对比";s:5:"link_";s:58:"http://efe.baidu.com/blog/comparison-of-html-linting-tool/";s:2:"id";s:58:"http://efe.baidu.com/blog/comparison-of-html-linting-tool/";s:9:"published";s:24:"2015-07-13T16:00:00.000Z";s:7:"updated";s:24:"2015-07-14T07:21:20.000Z";s:12:"atom_content";s:9544:"<p>作为一个前端，不可避免同时与三个语言打交道：JS、CSS 和 HTML。而 HTML，超文本标记语言，是其中可编程性最弱的，一直以来得到的关注都较少。加上浏览器对 HTML 逆天的容错支持，即使是错误百出的文档也可以在浏览器里边表现得中规中矩。这样的背景下，绝大部分被产出的 HTML 代码都存在着各种各样的小问题，比如缺少必要的元信息（meta），比如混乱的 class、id 或属性的取值格式；这些问题或影响页面在不同浏览器下的表现，或增大了页面的开发、维护成本。</p>
<p>因此，选用一个合适的工具对 HTML 代码进行质量控制会是一件很有意义的事情。本文选择了 Bootlint、AriaLinter、htmllint、HTMLHint 及 htmlcs 这五个目前最活跃的相关项目进行对比。除此之外还存在如 tidy、W3C/Mozilla HTML validator 等工具，但它们专注于 HTML 规范，几乎不涉及代码风格上的检查，这里就不做比较。</p>
<p>对比角度将主要包括以下几个方面：</p>
<ul>
<li>使用及配置</li>
<li>规则实现及自定义</li>
<li>性能</li>
<li>亮点</li>
</ul>
<p>为了后续说明的便利，这里先对语法风格的规则进行简单的分类，第一类包括 <code>attr-value-double-quotes</code>（使用双引号包围属性值）， <code>max-length</code>（限制单行最大长度）， <code>tag-pair</code>（要求需要显式闭合的标签显式闭合）等；第二类包括 <code>script-in-tail</code>（JavaScript 内容要求在页面最后嵌入）, <code>title-required</code>（要求 title 标签）, <code>id-class-ad-disabled</code>（不允许在 id 或 class 的值中出现 ad_，ad-，_ad，-ad 等）等。这两类规则有很明显的区别，第一类偏重于代码格式（遵循与否都不影响最终语义），这里叫它格式规则；对应地，第二类偏重语义，即最终 document 的表现，这里叫它语义规则。一般情况下，前者更适合在语法分析阶段做，而后者更适合在分析完后基于分析结果（AST / document）进行。</p>
<a id="more"></a>
<h3 id="bootlint"><a href="https://github.com/twbs/bootlint" target="_blank" rel="external">Bootlint</a></h3>
<p>Bootlint 可能是 github 上 star 数最多的 HTML 代码风格检查工具。不过正如其名所暗示的，它由 Bootstrap 团队开发，专注于基于 Bootstrap 的项目。与受关注程度相对应，项目的完善度较高，文档齐全，使用方式包括在浏览器中引入，作为 Grunt 任务、Nodejs 模块及命令行工具。</p>
<p>Bootlint 支持规则粒度的配置，但仅限于 disable / enable。不支持配置文件或行内配置。</p>
<p>Bootlint 专注于基于 Bootstrap 的项目，这一点在它的<a href="https://github.com/twbs/bootlint/wiki" target="_blank" rel="external">规则列表</a>中体现得较为明显：Bootlint 提供的大多数规则都明显只适用于 Bootstrap 项目，如 W004（插件 Modal 中不允许使用将被废弃的 <code>remote</code>）， W005（如果使用了基于 jQuery 的 Bootstrap 插件，则要求页面中引入 jQuery）等。另外，Bootlint 实现方式是通过 <a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">Cheerio</a> 对 HTML 代码进行解析，获取到类 jQuery 的 <code>$</code>（选择器）接口，其规则均在 <code>$</code> 基础上实现，这决定了目前的 Bootlint 所能提供的仅限语义规则。而且，Bootlint 不支持添加自定义规则。</p>
<p>Bootlint 性能一般，Cheerio 内部使用 htmlparser2 进行 HTML 代码的解析，然后将对节点的操作包装为 <code>$</code> 方法，Bootlint 逐规则通过 <code>$</code> 查找元素，依据结果进行检查。</p>
<p>针对 Bootstrap 相关的检查可以算是 Bootlint 的亮点之一。Bootlint 的另一个独特之处在于，它支持作为一个服务器运行，提供基于 HTTP 请求的 lint 服务。</p>
<h3 id="arialinter"><a href="https://github.com/globant-ui/arialinter" target="_blank" rel="external">AriaLinter</a></h3>
<p>AriaLinter 是一个基于规则（Rule based），面向 HTML document 的检查工具。它支持作为一个 Grunt 任务（最推荐的形式）、Nodejs 模块或命令行工具使用。</p>
<p>作为一个 Grunt 任务或 Nodejs 模块被调用时，支持传入规则配置。但不支持配置文件或行内配置，及作为单独命令行工具使用时是不可配置的。</p>
<p>AriaLinter 强调了它是“for HTML documents”，即偏语义规则的检查，做法是基于 <a href="https://github.com/tmpvar/jsdom" target="_blank" rel="external">jsdom</a> 获取运行时的 document，接着检查其内容、结构。事实上，AriaLinter 几乎没有实现任何格式规则。另外，也不支持自定义规则。</p>
<p>AriaLinter 性能会是个问题，毕竟只是为了得到 document 结构的话，jsdom 太重了。</p>
<p>AriaLinter 的亮点之一是贴心地支持了 template 参数，当开启时部分规则不做检查。该特性在模板语法会对 HTML 语法造成破坏时效果有限。</p>
<h3 id="htmllint"><a href="https://github.com/htmllint/htmllint" target="_blank" rel="external">htmllint</a></h3>
<p>htmllint 是一个2014年开始的项目，它将自己定位为一个“html5 linter and validator”，它提供了较全面的 rule，实现方式也很特别。有不少的人参与了开发，文档也很齐全，奇怪的是它受到的关注度很低。</p>
<p>htmllint 支持作为 Grunt 任务或 Nodejs 模块的使用形式。可传入规则配置。不支持配置文件，支持行内注释配置。</p>
<p>htmllint 较好地同时支持了格式规则及语义规则。做法是将两类规则分两步做：</p>
<ol style="list-style-type: decimal">
<li>对代码进行进行逐行 lint</li>
<li>对代码 parse 完成后，针对 AST 逐节点 lint</li>
</ol>
<p>同时也支持自定义规则。</p>
<p>最后在性能上，使用 htmlparser2 解析代码，性能较好；另外逐节点 lint 的方式避免了重复遍历，也有一定性能上的收益。</p>
<h3 id="htmlhint"><a href="https://github.com/yaniswang/HTMLHint" target="_blank" rel="external">HTMLHint</a></h3>
<p>HTMLHint 是国人出品的 HTML 代码检查工具，定位是“A Static Code Analysis Tool for HTML”。</p>
<p>使用方式包括在浏览器中引入，作为 Nodejs 模块，及命令行工具。支持传入配置或指定配置文件。不过与 Bootlint 类似，其规则配置仅限于 disable / enable。</p>
<p>与 AriaLinter 相反，HTMLHint 仅在对代码进行 parse 的过程中进行检查。这样带来的好处是性能上的，避免了对 AST / document 的操作；当然这也带来局限性：规则偏格式规则。虽然 HTMLHint 也提供一些语义规则，但其实现建立在对 parse 时事件的监听上，显得吃力且不自然。</p>
<p>另外，HTMLHint 支持自定义 rule，当然，自定义 rule 也受到上述限制，仅能接触到 parser 而非 AST / doument。</p>
<p>HTMLHint 的性能应该是能提供语义规则的工具里最好的。仅有一遍 parse 过程，无 AST / Document 的查找过程。</p>
<h3 id="htmlcs"><a href="https://github.com/ecomfe/htmlcs" target="_blank" rel="external">htmlcs</a></h3>
<p>htmlcs 是百度 EFE 出品的的 HTML 代码风格检查工具，项目始于2014年底，应百度内部全面推行代码规范检查的需求而生。</p>
<p>htmlcs 支持以 Nodejs 模块，或命令行工具的形式使用，在 grunt / gulp 中使用时需要手动包装。作为模块调用时，可传入自定义配置对象；作为命令行工具使用时，支持配置文件。另外也支持代码行内配置。</p>
<p>htmlcs 提供了较丰富的规则实现，包括格式规则及语义规则，也支持添加自定义规则。在实现时针对性分为 parse 时规则（类 HTMLHint 实现方式）及面向 document 的规则（类 AriaLinter 的规则行为），前者监听 parser 事件，后者直接读取 document 结构。特别地，这里的 document 结构被进行了包装，依据 <a href="http://www.w3.org/TR/dom/" target="_blank" rel="external">DOM 规范</a>实现了大部分的属性及读操作方法。因此自定义的规则可以以操作规范 DOM 的形式操作 document 结构，实现自然、便利。</p>
<p>另外 htmlcs 支持传入额外 linter 对 HTML 中内嵌的 JS 及 CSS 内容进行检查。</p>
<p>对于可自动修正的规则，htmlcs 提供了 format 方法。自定义规则同样可以自定义对应的 format 行为。页面内嵌的 JS 及 CSS 内容也可以通过传入对应的 format 方法进行格式化。</p>
<p>htmlcs 的性能不是优势，处于可接受的程度。HTML 代码的 parse 基于 htmlparser2，但对结果对象有一个封装的过程；另外规则的实现方式（节点查找的频次）也在一定程度上影响最终表现。</p>
<h3 id="总结">总结</h3>
<p>Bootlint 与 AriaLinter 均短板明显。前者在只针对 Bootstrap 项目时有一定优势；而后者在只关注语义规则时能满足一定需求。</p>
<p>htmllint 在大部分情况下能满足基本需求，但优点不明显。</p>
<p>如果对性能较为敏感，推荐 HTMLHint。</p>
<p>而 htmlcs 在扩展性、自定义能力上表现突出，覆盖的规则可能也是目前最全的，从个人角度看是大部分情况下的推荐选择。</p>
";s:7:"summary";s:2167:"
    <p>作为一个前端，不可避免同时与三个语言打交道：JS、CSS 和 HTML。而 HTML，超文本标记语言，是其中可编程性最弱的，一直以来得到的关注都较少。加上浏览器对 HTML 逆天的容错支持，即使是错误百出的文档也可以在浏览器里边表现得中规中矩。这样的背景下，绝大部分被产出的 HTML 代码都存在着各种各样的小问题，比如缺少必要的元信息（meta），比如混乱的 class、id 或属性的取值格式；这些问题或影响页面在不同浏览器下的表现，或增大了页面的开发、维护成本。</p>
<p>因此，选用一个合适的工具对 HTML 代码进行质量控制会是一件很有意义的事情。本文选择了 Bootlint、AriaLinter、htmllint、HTMLHint 及 htmlcs 这五个目前最活跃的相关项目进行对比。除此之外还存在如 tidy、W3C/Mozilla HTML validator 等工具，但它们专注于 HTML 规范，几乎不涉及代码风格上的检查，这里就不做比较。</p>
<p>对比角度将主要包括以下几个方面：</p>
<ul>
<li>使用及配置</li>
<li>规则实现及自定义</li>
<li>性能</li>
<li>亮点</li>
</ul>
<p>为了后续说明的便利，这里先对语法风格的规则进行简单的分类，第一类包括 <code>attr-value-double-quotes</code>（使用双引号包围属性值）， <code>max-length</code>（限制单行最大长度）， <code>tag-pair</code>（要求需要显式闭合的标签显式闭合）等；第二类包括 <code>script-in-tail</code>（JavaScript 内容要求在页面最后嵌入）, <code>title-required</code>（要求 title 标签）, <code>id-class-ad-disabled</code>（不允许在 id 或 class 的值中出现 ad_，ad-，_ad，-ad 等）等。这两类规则有很明显的区别，第一类偏重于代码格式（遵循与否都不影响最终语义），这里叫它格式规则；对应地，第二类偏重语义，即最终 document 的表现，这里叫它语义规则。一般情况下，前者更适合在语法分析阶段做，而后者更适合在分析完后基于分析结果（AST / document）进行。</p>
    
    ";}i:6;a:7:{s:5:"title";s:40:"IoC 在前端模块化中的实践应用";s:5:"link_";s:46:"http://efe.baidu.com/blog/ioc-in-modulization/";s:2:"id";s:46:"http://efe.baidu.com/blog/ioc-in-modulization/";s:9:"published";s:24:"2015-07-09T16:00:00.000Z";s:7:"updated";s:24:"2015-07-10T07:01:02.000Z";s:12:"atom_content";s:36348:"<h3 id="前端模块化背景">前端模块化背景</h3>
<p>在大部分单页式应用中，前端代码都是以 MV* 的结构来组织的，好处自然不必多说。在开始一个项目时，我们往往会将项目的业务功能纵向切分成多个子业务功能， 以模块的形式分配给团队各个开发人员，以达到最大的并行开发。随着业务的发展，新的项目也越来越多，我们会发现很多新的项目和现有的项目是有不少功能交集的。</p>
<p>从业务角度来看，一个项目就是由各个模块组合而成：A 项目由 m1, m2, m3 组合而成， B 项目则可能由 m1, m3, m4 组合而成。</p>
<p>在业务上将各个功能拆分明确后，很明显的 m1, m3 两个功能在 A 项目都是存在的，从工程角度来说，开发 B 项目的时候如果能够直接将A项目已经开发完毕的 m1, m3 直接复用， 那么必然是能够带来很明显的人力节约。</p>
<p>接下来就是从技术上去实现功能的复用，对于后端来说，通常的做法是服务化接口，而对于前端来说，我们目前的方案正是前端模块化：将功能打包为模块，发布至内部中央仓库， 使用方通过自己的方式（如：npm, bower, link[import], 百度的 edp, fis 等）导入模块包使用。</p>
<p>按照前端模块化的思路，开发新项目时，开发人员的工作从原来的开发所有功能变为：接入已有的功能模块，开发不存在的功能模块。</p>
<a id="more"></a>
<h3 id="前端模块化中遇到的技术障碍">前端模块化中遇到的技术障碍</h3>
<blockquote>
<p>唯一不变的就是变化 – by 马云</p>
</blockquote>
<p>这句话同样适用于技术领域，如果一个功能模块可以无缝引入，而无需做任何适配，那这个世界就完美了，让我们先看看在实际的推进过程中遇到的场景：</p>
<ul>
<li><p>新项目的部分业务功能和现有的模块确实是一致的，但产品经理希望在视图层面上针对新项目的用户群做大幅度调整。</p></li>
<li><p>部分业务功能在视觉层面上一致，但后端还未形成服务化，在数据源上需要请求至新项目的服务端。</p></li>
<li><p>…</p></li>
</ul>
<p>在前端 MVC 的架构中，一个业务模块就是 model + controller + view 的打包组合，映射到上述两个场景则是：</p>
<ul>
<li><p>现有 MVC 模块中的 view 和 controller 部分，新项目有自己的定制化实现</p></li>
<li><p>现有 MVC 模块中的 model 部分，新项目有自己的请求源</p></li>
</ul>
<p>结合以上实际的场景，我们认为对于一个可复用的前端业务模块，至少要满足以下两点：</p>
<ol style="list-style-type: decimal">
<li><p>独立可运行，有自己的一套默认的实现</p></li>
<li><p>可满足扩展的需求，如 MVC 中各层次中的定制和扩展</p></li>
</ol>
<p>对于第一点比较容易解决，对于第二点则是我们面临的主要挑战，举个简单的例子来说明， 假设我们要开发一个 A 项目下的列表页面，按照 MVC 的写法，骨架代码大概如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A/ListModel.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.store = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListModel.prototype.load = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set(<span class="string">'items'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ListModel.prototype.set = <span class="function"><span class="keyword">function</span> <span class="params">(key, value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.store[key] = value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ListModel.prototype.get = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.store[key];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListModel;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A/ListView.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListView</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ListView.prototype.render = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.body.innerHTML = <span class="keyword">this</span>.model.get(<span class="string">'items'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListView;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A/ListController.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'./ListModel'</span>);</span><br><span class="line">        <span class="keyword">var</span> View = <span class="built_in">require</span>(<span class="string">'./ListView'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model = <span class="keyword">new</span> Model();</span><br><span class="line">            <span class="keyword">this</span>.view = <span class="keyword">new</span> View();</span><br><span class="line">            <span class="keyword">this</span>.view.model = <span class="keyword">this</span>.model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListController.prototype.enter = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model.load();</span><br><span class="line">            <span class="keyword">this</span>.view.render();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListController;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A/main.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> List = <span class="built_in">require</span>(<span class="string">'ListController'</span>);</span><br><span class="line">        <span class="keyword">var</span> list = <span class="keyword">new</span> List();</span><br><span class="line">        list.enter();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>运行结果就是在页面中展示列表数据。</p>
<p>过了一段时间，另一个新项目 B 来了，B 项目也要开发一个列表页，但交互展示和A项目的列表页是一致的，不同之处在于数据源要来自B项目的后端。</p>
<p>如何能够让B项目不需要话费太多的经历就能够复用 A 的列表模块，但又满足数据源变更需求？</p>
<h3 id="继承覆写方案">继承覆写方案</h3>
<p>针对上述代码，我们将数据源变化的需求映射到A列表模块的代码中，发现 ListController.js, ListView.js 好像都不用变， 仅仅需要覆写 ListModel.js 的 load 方法，使得其加载的数据来自B项目就解决了数据源变化的需求。</p>
<p>于是我们在B项目中新建一个 ListModel，继承自 A/ListModel，重写 load 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B/ListModel.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> AListModel = <span class="built_in">require</span>(<span class="string">'A/ListModel'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            AListModel.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源设置为了 B 的数据 </span></span><br><span class="line">        ListModel.prototype.load = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set(<span class="string">'items'</span>, [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListModel;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们在 B/ListModel.js中重写了 load 方法，接下来就是怎么去重用A/ListController, A/ListView, 继续看下 A 的代码，我们发现 A/ListController中有这两行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'./ListModel'</span>);</span><br><span class="line"><span class="keyword">var</span> View = <span class="built_in">require</span>(<span class="string">'./ListView'</span>);</span><br></pre></td></tr></table></figure>
<p>这两行代码导致了A/ListController的直接依赖自身的两个 model 和 view， 意味着如果B 项目要接入自己的 ListModel，必须修改 A 模块的源代码，这违背了软件设计的<strong>对扩展开发，对修改关闭</strong>的设计原则。</p>
<p>上述问题的本质在于，<strong>A 项目的代码针对了具体实现编程，而非接口。</strong> A/ListController 直接依赖了具体实现（A/ListModel, A/ListView），这使得其复用性大大降低。</p>
<h3 id="ioc-依赖替换方案">IoC 依赖替换方案</h3>
<p>IoC(Inversion of Control) 即控制反转，将依赖的管理交由外部控制。 IoC在服务端的开发中很常见，而在前端的应用范围暂时还不是太广， 相信很多前端同学是从angular接触到 IoC 和 DI（依赖注入）的概念。</p>
<p>接下来我们利用IoC的理念重构下 A 项目的代码，将依赖外置，由外部传入依赖实例，也就是具体实现，不同的项目有不同的实现，但都遵守同一个接口（js 中则是隐式接口）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A/ListController.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListController</span><span class="params">(model, view)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>.view = view;</span><br><span class="line">            <span class="keyword">this</span>.view.model = <span class="keyword">this</span>.model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListController.prototype.enter = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model.load();</span><br><span class="line">            <span class="keyword">this</span>.view.render();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListController;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A/main.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> List = <span class="built_in">require</span>(<span class="string">'ListController'</span>);</span><br><span class="line">        <span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'ListModel'</span>);</span><br><span class="line">        <span class="keyword">var</span> View = <span class="built_in">require</span>(<span class="string">'ListView'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> model = <span class="keyword">new</span> Model();</span><br><span class="line">        <span class="keyword">var</span> view = <span class="keyword">new</span> View();</span><br><span class="line">        <span class="keyword">var</span> list = <span class="keyword">new</span> List(model, view);</span><br><span class="line">        </span><br><span class="line">        list.enter();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的代码中将 A/ListController 对具体 model 和 view 的依赖都外置了，由外部（这里是 A/main.js）创建好传入构造函数， A/ListController 对 model 和 view 如何构造，是怎么实现的都不需要关心，只要知道 model 实现了 load 接口，view 实现了 render 接口就行了。 好了，到这一步基本解决了对具体依赖的解耦，接下来我们看看 B 项目的代码怎么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/ B/ListModel.js</span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> AListModel = <span class="built_in">require</span>(<span class="string">'A/ListModel'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            AListModel.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继承 A/ListModel</span></span><br><span class="line">        ListModel.prototype = <span class="keyword">new</span> AListModel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数据源设置为了 B 的数据 </span></span><br><span class="line">        ListModel.prototype.load = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set(<span class="string">'items'</span>, [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ListModel;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B/main.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重用 A项目的Controller 和 View</span></span><br><span class="line">        <span class="keyword">var</span> List = <span class="built_in">require</span>(<span class="string">'A/ListController'</span>);</span><br><span class="line">        <span class="keyword">var</span> View = <span class="built_in">require</span>(<span class="string">'A/ListView'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引入自己的定制 Model</span></span><br><span class="line">        <span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'ListModel'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> model = <span class="keyword">new</span> Model();</span><br><span class="line">        <span class="keyword">var</span> view = <span class="keyword">new</span> View();</span><br><span class="line">        <span class="comment">// 由构造函数将 model 和 view 两个依赖注入给控制器</span></span><br><span class="line">        <span class="keyword">var</span> list = <span class="keyword">new</span> List(model, view);</span><br><span class="line"></span><br><span class="line">        list.enter();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们看到，通过依赖注入，B项目的列表开发工作量仅仅是简单的重写 A.ListMdel#load，以及在入口文件处创建好依赖即可。 控制和视图的开发工作量都节约下来了，这无疑是巨大的工作量节约。</p>
<h3 id="ioc-容器---依赖注入的抽象">IoC 容器 - 依赖注入的抽象</h3>
<p>上面的代码中，我们将模块的依赖在 main.js 中手动创建好，然后调用模块的构造函数传入， 这个过程就是依赖反转，依赖的创建转移给了外部 main.js，模块仅仅做获取依赖的工作。 我们发现这一过程也是冗余重复的，当需要创建的依赖多了后，main.js 的代码也要随之冗余膨胀， 于是有了 IoC 容器来做这一过程：<strong>项目声明依赖配置，IoC 容器根据配置做好相关的依赖创建工作即可</strong>。</p>
<p>在 angular 中，依赖声明是在构造函数中或者 $inject 中做的，在构造函数中 angular 根据命名参数去查找依赖声明，并做好依赖的创建工作。</p>
<p>但 angular 的依赖注入存在以下问题：</p>
<ol style="list-style-type: decimal">
<li><p>和 angular 紧密整合，移植成本较大。</p></li>
<li><p>依赖注入方式单一，仅有构造函数注入。要是一个模块依赖很多的话，构造函数中的依赖声明得写脱。 既然我们可以通过构造函数传入依赖，那完全也可以提供另一个函数给 IoC 容器，让 IoC 容器调用这个函数传入依赖，这个注入方式称之为接口注入； 如果函数命名风格为 setter(setXXX)，又可以称之为 setter注入； 再加上 js 语言的动态性，可以动态的给对象赋值新属性，于是我们还可以直接赋值注入：instance.dependency = xxxx， 这个我们暂时称之为属性注入。</p></li>
<li><p>未能和模块加载器结合。 在浏览器环境中，很多场景都是异步的过程，我们需要的依赖模块并不是一开始就加载好的， 或许我们在创建的时候才会去加载依赖模块，再进行依赖创建，而 angular 的 IoC 容器则没法做到这点。</p></li>
</ol>
<p>针对 angular 依赖注入的这些问题，我们自己开发了一套 IoC 框架 <a href="https://github.com/ecomfe/uioc" target="_blank" rel="external">uioc</a> 来解决模块化对依赖注入抽象的需求，主要特点如下：</p>
<ol style="list-style-type: decimal">
<li><p>独立的库，不和任何框架整合，随便用。</p></li>
<li><p>配置上支持 AMD/CMD 规范的异步 Loader (NodeJS 自不必说，同步 loader 更简单了)。</p></li>
<li><p>丰富的 IoC 注入方式：setter 注入，构造函数注入，属性注入。</p></li>
<li><p>简化配置的方案：根据 setter 自动注入，配置导入。</p></li>
<li><p>依赖作用域的管理：单例，多例，静态。</p></li>
<li><p>支持 constructor 和 factory 两种依赖构造方式。</p></li>
</ol>
<p>将上面的B项目用 uioc 改造后如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B/config.js</span></span><br><span class="line">define(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// key 为提供给 ioc 的组件id，值为相关配置</span></span><br><span class="line">        list: &#123;</span><br><span class="line">            <span class="comment">// 组件所在的模块id，这里复用了 A的 ListController</span></span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'A/ListController'</span>,</span><br><span class="line">            <span class="comment">// 构造函数注入，$ref声明依赖，两个依赖id分别为 model 和 view</span></span><br><span class="line">            args: [</span><br><span class="line">                &#123;$ref: <span class="string">'model'</span>&#125;, &#123;$ref: <span class="string">'view'</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用了B定制的 ListModel</span></span><br><span class="line">        model: &#123;<span class="built_in">module</span>: <span class="string">'B/ListModel'</span>&#125;,</span><br><span class="line">        view: &#123;<span class="built_in">module</span>: <span class="string">'A/ListView'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// B/ListModel.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> AListModel = <span class="built_in">require</span>(<span class="string">'A/ListModel'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ListModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            AListModel.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继承 A/ListModel</span></span><br><span class="line">        ListModel.prototype = <span class="keyword">new</span> AListModel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源设置为了 B 的数据 </span></span><br><span class="line">        ListModel.prototype.load = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set(<span class="string">'items'</span>, [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListModel;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B/main.js</span></span><br><span class="line">define(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(require)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> IoC = <span class="built_in">require</span>(<span class="string">'uioc'</span>);</span><br><span class="line">        <span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'config'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化ioc容器，传入配置注册各个组件</span></span><br><span class="line">        <span class="keyword">var</span> ioc = IoC(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 list 组件后，调用对应的 enter 方法</span></span><br><span class="line">        ioc.getComponent(<span class="string">'list'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(list)</span> </span>&#123;</span><br><span class="line">            list.enter();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当有新的项目 C 对 view 层上有定制需求，那么仅需继承或者重写一个 ListView，在配置中将 view 定制为 C/ListView 即可完成新一轮的开发，变的只是配置和定制的部分。</p>
<h3 id="总结">总结</h3>
<p>真正的项目复杂性远不止本文的示例代码这么简单，还包括了数据源对象，模板，对 dom 封装的控件等其他模块。</p>
<p>我们系统原来的 MVC 架构，开发一个业务模块将 M, V,C 等各个依赖紧紧的耦合在了一起。 随着业务的发展，项目也越来越多，我们发现这些项目具有很多共同点，仅仅是局部不同， 于是我们通过控制反转将业务模块中各个容易变化的部件抽象解耦，不同的项目去实现自己的定制需求，而通用代码不要重复开发， 大概的架构演变如下图（Action 对应代码中的 Controller）：</p>
<div class="figure">
<img src="/blog/ioc-in-modulization/ioc.png" alt="mvc"><p class="caption">mvc</p>
</div>
<p>基本思路都躲不过：<strong>封装变化的，固化不变的。但难点又在于区分哪些是变化的，哪些又是不变的</strong>。</p>
";s:7:"summary";s:1519:"
    <h3 id="前端模块化背景">前端模块化背景</h3>
<p>在大部分单页式应用中，前端代码都是以 MV* 的结构来组织的，好处自然不必多说。在开始一个项目时，我们往往会将项目的业务功能纵向切分成多个子业务功能， 以模块的形式分配给团队各个开发人员，以达到最大的并行开发。随着业务的发展，新的项目也越来越多，我们会发现很多新的项目和现有的项目是有不少功能交集的。</p>
<p>从业务角度来看，一个项目就是由各个模块组合而成：A 项目由 m1, m2, m3 组合而成， B 项目则可能由 m1, m3, m4 组合而成。</p>
<p>在业务上将各个功能拆分明确后，很明显的 m1, m3 两个功能在 A 项目都是存在的，从工程角度来说，开发 B 项目的时候如果能够直接将A项目已经开发完毕的 m1, m3 直接复用， 那么必然是能够带来很明显的人力节约。</p>
<p>接下来就是从技术上去实现功能的复用，对于后端来说，通常的做法是服务化接口，而对于前端来说，我们目前的方案正是前端模块化：将功能打包为模块，发布至内部中央仓库， 使用方通过自己的方式（如：npm, bower, link[import], 百度的 edp, fis 等）导入模块包使用。</p>
<p>按照前端模块化的思路，开发新项目时，开发人员的工作从原来的开发所有功能变为：接入已有的功能模块，开发不存在的功能模块。</p>
    
    ";}i:7;a:7:{s:5:"title";s:20:"XHR 和 baidubce-sdk";s:5:"link_";s:61:"http://efe.baidu.com/blog/xhr-compatibility-and-baidubce-sdk/";s:2:"id";s:61:"http://efe.baidu.com/blog/xhr-compatibility-and-baidubce-sdk/";s:9:"published";s:24:"2015-07-05T16:00:00.000Z";s:7:"updated";s:24:"2015-07-06T07:12:09.000Z";s:12:"atom_content";s:4635:"<h3 id="content-type">Content-Type</h3>
<p>在开发 <a href="https://www.npmjs.com/package/baidubce-sdk" target="_blank" rel="external">baidubce-sdk</a> 的时候，遇到了在不同浏览器（主要是 Firefox 和 Chrome）下调用 <code>xhr.setRequestHeader</code> 设置 <code>Request Header</code> 之后，内部的处理逻辑有一些细微的差别，导致<code>baidubce-sdk</code>无法正常的工作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'foo/bar'</span>);</span><br><span class="line"><span class="comment">// 当Method !== 'GET' 的时候</span></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">''</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<p>对于上面这段儿代码，因为我们显式的设置了<code>Content-Type</code>，所以我们期望的是服务器收到的 <code>Request Header</code> 中 <code>Content-Type</code> 应该是 <code>foo/bar</code>，实际上在 <code>Firefox</code> 里面会自动添加 <code>charset=UTF-8</code>，也就是服务器得到的信息是 <code>foo/bar; charset=UTF-8</code></p>
<a id="more"></a>
<p>因为根据 ak 和 sk 计算签名的时候，<code>Content-Type</code>作为其中的一个因子参与计算的。Firefox下面的这个问题，导致 client 和 server 计算出来的签名不一致，所以 server 就拒绝了某些请求。</p>
<h3 id="content-length">Content-Length</h3>
<p>第二个兼容性的问题是关于<code>Content-Length</code>的，因为 <code>baidubce-sdk</code> 最初的是为 <code>Node.js</code> 开发的，通过 <code>browserify</code> 处理之后直接运行在浏览器里面。</p>
<p>在<code>Node.js</code>里面，我们直接使用的<code>require('http')</code>模块，可以任意设置<code>Request Header</code>里面的字段，但是在<a href="http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method" target="_blank" rel="external">XMLHttpRequest的文档</a>里面，限制了一些可以设置的<code>Header</code>。</p>
<p>在<code>GET</code>请求里面，<code>Content-Length</code>值是<code>0</code>，此时 client 是有这个信息的，因此会把<code>Content-Length</code>作为计算签名的一个因子，不过因为<code>xhr</code>的限制，我们无法设置这个 Header，因此 server 收到的 <code>GET</code> 请求里面，<code>Request Header</code> 里面是没有这个<code>Content-Length</code>的，这也就导致了签名计算不一致的问题。</p>
<h3 id="baidubce-sdk">baidubce-sdk</h3>
<p>问题都描述清楚了，对应的解决方案也就有了：</p>
<ul>
<li><code>Content-Type</code>：</li>
</ul>
<ol style="list-style-type: decimal">
<li>在<code>POST</code>的时候<strong>给所有浏览器</strong>下面都加上<code>; charset=UTF-8</code>这部分信息</li>
<li>使用 <code>sendAsBinary</code> 代替 <code>send</code>，不过 <code>browserify</code> 生成的代码里面没有调用这个 <code>API</code>，需要自己去修改一下才可以。</li>
<li>调用<code>xhr.send</code>参数的时候，不要传递<code>string</code>，改成<code>Uint8Array</code>，也可以避免这个问题。</li>
</ol>
<ul>
<li><code>Content-Length</code> 这个问题会判断一下 <code>GET</code> 和 <code>0</code> 的情况来决定是否让 <code>Content-Length</code> 来参与计算签名</li>
</ul>
<p>广告贴来了</p>
<p><code>baidubce-sdk</code>封装了<a href="http://bce.baidu.com/" target="_blank" rel="external">百度开放云</a>提供的一些基础API，比如云存储(BOS)，音视频转码（Media），欢迎有这方面需求的童鞋试用。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="tag">i</span> baidubce-sdk</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=416178" class="uri" target="_blank" rel="external">https://bugzilla.mozilla.org/show_bug.cgi?id=416178</a></li>
</ul>
";s:7:"summary";s:1636:"
    <h3 id="content-type">Content-Type</h3>
<p>在开发 <a href="https://www.npmjs.com/package/baidubce-sdk">baidubce-sdk</a> 的时候，遇到了在不同浏览器（主要是 Firefox 和 Chrome）下调用 <code>xhr.setRequestHeader</code> 设置 <code>Request Header</code> 之后，内部的处理逻辑有一些细微的差别，导致<code>baidubce-sdk</code>无法正常的工作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'foo/bar'</span>);</span><br><span class="line"><span class="comment">// 当Method !== 'GET' 的时候</span></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">''</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<p>对于上面这段儿代码，因为我们显式的设置了<code>Content-Type</code>，所以我们期望的是服务器收到的 <code>Request Header</code> 中 <code>Content-Type</code> 应该是 <code>foo/bar</code>，实际上在 <code>Firefox</code> 里面会自动添加 <code>charset=UTF-8</code>，也就是服务器得到的信息是 <code>foo/bar; charset=UTF-8</code></p>
    
    ";}i:8;a:7:{s:5:"title";s:35:"JavaScript 代码静态质量检查";s:5:"link_";s:35:"http://efe.baidu.com/blog/js-lints/";s:2:"id";s:35:"http://efe.baidu.com/blog/js-lints/";s:9:"published";s:24:"2015-07-01T06:00:00.000Z";s:7:"updated";s:24:"2015-07-24T06:31:31.000Z";s:12:"atom_content";s:9361:"<p>自鸿蒙初判，<a href="http://en.wikipedia.org/wiki/Brendan_Eich" target="_blank" rel="external">Brendan Eich</a> 10 天捏出 Mocha 之后，即便进化成 ECMAScript，这个语言依旧毁誉相随。那些经过重重劫难，侥幸渡劫成功的苦主标识了诸多天坑（见 <a href="http://bonsaiden.github.io/JavaScript-Garden/" target="_blank" rel="external">JavaScript Garden</a>） —— 当然，你也可以称之 feature。据无责任乱猜，Douglas Crockford 也没少踩坑，于是才有了蝴蝶书《JavaScript: The Good Parts》，下雨天与 <code>JSLint</code> 一起使用会更配哟。</p>
<div class="figure">
<img src="/blog/js-lints/guide.vs.good-parts.png">
</div>
<p>《JavaScript: The Definitive Guide》 V.S. 《JavaScript: The Good Parts》</p>
<p>时至今日，代码的静态质量检查在项目质量保障方面的重要性与必要性已毋庸置疑。越来越多的开发者意识到了这一点，纷纷在项目构建流程或者源码控制系统中添加静态检查的 <code>hook</code>。本文将依时间顺序，选出 <code>JavaScript</code> 史上的主要几个 <code>Linter</code> 作横向比较，最终属意谁家，那就见仁见智了。</p>
<a id="more"></a>
<h3 id="jslint"><a href="http://www.jslint.com/" target="_blank" rel="external">JSLint</a></h3>
<p><code>JSLint</code> 的名字源于早期用于检查 <code>C</code> 语言代码质量的 <code>Lint</code>，老道把认为非 <code>Good Parts</code> 、有陷阱的部分全部报 warning，而且绝不允许妥协（当前版本已经允许部分的可配置项），固执得令人心疼。</p>
<p>虽然这个在 2002 年的 JSLint 代表着先进的方向，但是前端的发展一日千里，严格不妥协的 <code>JSLint</code> 开始阻碍前端的发展 —— 例如函数内变量全部集中在顶部定义，推荐一个 <code>var</code> 定义多个变量等。最最最重要的是，老道拒绝开源 <code>JSLint</code>（无责任乱猜，也许 <code>JSLint</code> 的实现代码违反它自己制定的规则）。</p>
<p>截止 2015年6月9日，<code>JSLint</code> 仍然在更新，官网上写着 <strong><code>JSLint edition 2015-06-02 BETA</code></strong>，固执的老道。</p>
<h3 id="jshint"><a href="http://jshint.com/" target="_blank" rel="external">JSHint</a></h3>
<p>鉴于 <code>JSLint</code> 的现状，<a href="http://anton.kovalyov.net/" target="_blank" rel="external">Anton Kovalyov</a> 以 <code>JSLint</code> 为蓝本，在社区力量的帮助下实现了开源的 <code>JSHint</code>。</p>
<p>相较之下，<code>JSHint</code> 更友好，可配置性更高。由于大家受 <code>JSLint</code> 的压迫太久，而且得益于开源的优势，风头很快盖过 <code>JSLint</code>，一时无两，获得大量 IDE/Editor 的支持。然而成败萧何，<code>JSHint</code> 的成功源于对 <code>JSLint</code> 的改进，但同样继承了 <code>JSLint</code> 的诸多缺点，比如不易扩展，难以根据报错信息定位到具体的规则配置等。虽然有专门的文档说明，但是修复的成本仍旧不低，于是出现了 <a href="http://jslinterrors.com/" target="_blank" rel="external">JSLint Error Explanations</a> 这样的网站，针对 <code>JSLint/JSHint/ESLint</code> 报的错误作修复说明 —— “啪啪”，这对 <code>JSHint</code> 团队来说无异于打脸。</p>
<p><code>JSHint</code> 团队也逐渐意识到这个问题的重要性，2012 年时曾有 <a href="https://github.com/jshint/jshint/issues/387" target="_blank" rel="external"><strong>讨论</strong></a> 使用 <code>esprima</code> 生成 <strong>AST</strong>（见 <a href="https://github.com/jshint/jshint-next" target="_blank" rel="external">jshint-next</a>，提示该项目已过期，已 merge 到主项目，但在 2013/5 又从主项目移除，现已难觅芳踪，原因未明），并有专门针对 <code>JSHint</code> 的 warning 作修复的 <a href="https://github.com/jshint/fixmyjs/" target="_blank" rel="external">fixmyjs</a>。</p>
<h3 id="closure-linter"><a href="https://developers.google.com/closure/utilities/index" target="_blank" rel="external">Closure Linter</a></h3>
<p><code>Closure Linter</code> 属于 <code>Closure</code> 家族成员，源于 2004 年的 <code>Gmail</code> 项目，最初只是内部使用，后来觉得应当 <code>兼济天下</code>，于是在 2007 年后作为 <code>Closure Tools</code> 系列开放给外部使用。<code>Closure Linter</code> 主要是按照《<a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml" target="_blank" rel="external">Google JavaScript Style Guide</a>》来作检查与修复。限于 <code>Closure</code> 的家族特性，使用范围并不大。</p>
<h3 id="jscs"><a href="http://jscs.info/" target="_blank" rel="external">JSCS</a></h3>
<p>自 <code>Marat Dulin</code> 于 <code>2003.6.17</code> 日凌晨发布第一个版本开始，<code>JSCS</code> 就专注于代码风格层面的检查，这点从它的名字 <code>JSCS - JavaScript Code Style</code> 中可窥一斑：</p>
<blockquote>
<p>JSCS is a code style linter for programmatically enforcing your style guide. You can configure JSCS for your project in detail using over 90 validation rules, including presets from popular style guides like jQuery, Airbnb, Google, and more.</p>
</blockquote>
<p>再看它的 <code>package.json</code> 中的依赖包：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line"></span><br><span class="line">  "esprima": "^1.2.5",</span><br><span class="line">  "esprima-harmony-jscs": "1.1.0-bin",</span><br><span class="line">  "estraverse": "^1.9.3",</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现它使用了 <code>esprima</code> 生成 <strong>AST</strong>，再通过 <code>estraverse</code> 遍历作检查，因此性能上会逊于 <code>JSLint</code> 与 <code>JSHint</code>，但是带来的收益是易于维护和扩展，相对于性能上的损失，是完全值得的。另外，<code>JSCS</code> 可通过 <code>esprima-harmony-jscs</code> 实现对 <code>ES6</code> 的支持，并且自带错误修复技能。</p>
<p><code>JSCS</code> 与 <code>JSHint</code> 份属同盟，互相使用对方作本项目的代码检查。</p>
<h3 id="eslint"><a href="http://esling.org/" target="_blank" rel="external">ESLint</a></h3>
<p>无独有偶，同样是源于对 <code>JSLint</code> 与 <code>JSHint</code> 的不满，<a href="http://nczonline.net/" target="_blank" rel="external">Nicholas C. Zakas</a> 也在 <code>JSCS</code> 发布的当月开始造另一个新轮子 —— <code>JSCheck</code>（浓浓的山寨感扑面而来有没有），不过几天后即更名为 <code>ESLint</code> —— 再次表明，好名字重要性。</p>
<p>功能方面，<code>ESLint</code> 可以简单的理解成 <code>JSHint + JSCS</code>，基本上集成了两大基友的优点。<code>ESLint</code> 在初期也是依赖于 <code>esprima</code> 生成 <strong>AST</strong>，后来为提高对 <strong>ES6</strong> 的支持，换成 <code>esprima</code> 的分支版本 <code>espree</code>。然而，<code>espree</code> 对 <strong>ES6</strong> 的支持仍然很有限，不过好在还有 <a href="https://npmjs.com/package/babel-eslint" target="_blank" rel="external">Babel-ESLint</a>。</p>
<h3 id="总结">总结</h3>
<p>如果你是<strong>老道</strong>的死忠粉，无条件同意他关于 JavaScript 的一切观点，那么 <code>JSLint</code> 是你的不二选择。只要把 <strong>老道</strong> 换成 <strong>Google</strong> 成立，<code>JSLint</code> 换成 <code>Closure Linter</code> 同样成立。</p>
<p>如果你有良好的单元测试作后续的质量保证，或者只 care 代码风格方面的问题，那么 <code>JSCS</code> 就完全胜任。</p>
<p>如果你要求不高，更注重开发工具和环境的支持，还想顺便检查一下 <strong>HTML</strong> 代码中的 <code>inline script</code>，严重推荐 <code>JSHint</code>。得益于它的高普及度，即使官方文档有隔靴搔痒的无力感，在社区的帮助下也能很快的解决你的问题。</p>
<p>如果你的要求非常高，为团队制定规范非常详细，并且不满足于 <code>JSHint</code> 与 <code>JSCS</code> 的组合，不妨试试 <code>ESLint</code>。严格的贡献参与流程，快速的响应以及丰富的文档都不过是它诸多优点中的冰山一角。</p>
<p>你还要检查 <strong>CSS</strong> 和 <strong>HTML</strong>，甚至还有 <strong>Less</strong>？ 也许只有 <code>fecs</code> 可以拯救你于水火，至于 <code>fecs</code> 是什么，那是另一篇文章的内容了。</p>
<h3 id="补充">补充</h3>
<p>行文未完，微博发现已有类似的比较： <a href="http://www.sitepoint.com/comparison-javascript-linting-tools/" target="_blank" rel="external">A Comparison of JavaScript Linting Tools</a>，可作参考。</p>
";s:7:"summary";s:1174:"
    <p>自鸿蒙初判，<a href="http://en.wikipedia.org/wiki/Brendan_Eich">Brendan Eich</a> 10 天捏出 Mocha 之后，即便进化成 ECMAScript，这个语言依旧毁誉相随。那些经过重重劫难，侥幸渡劫成功的苦主标识了诸多天坑（见 <a href="http://bonsaiden.github.io/JavaScript-Garden/">JavaScript Garden</a>） —— 当然，你也可以称之 feature。据无责任乱猜，Douglas Crockford 也没少踩坑，于是才有了蝴蝶书《JavaScript: The Good Parts》，下雨天与 <code>JSLint</code> 一起使用会更配哟。</p>
<div class="figure">
<img src="/blog/js-lints/guide.vs.good-parts.png" />
</div>
<p>《JavaScript: The Definitive Guide》 V.S. 《JavaScript: The Good Parts》</p>
<p>时至今日，代码的静态质量检查在项目质量保障方面的重要性与必要性已毋庸置疑。越来越多的开发者意识到了这一点，纷纷在项目构建流程或者源码控制系统中添加静态检查的 <code>hook</code>。本文将依时间顺序，选出 <code>JavaScript</code> 史上的主要几个 <code>Linter</code> 作横向比较，最终属意谁家，那就见仁见智了。</p>
    
    ";}i:9;a:7:{s:5:"title";s:21:"扁平化箭形代码";s:5:"link_";s:48:"http://efe.baidu.com/blog/flattening-arrow-code/";s:2:"id";s:48:"http://efe.baidu.com/blog/flattening-arrow-code/";s:9:"published";s:24:"2015-07-01T05:30:00.000Z";s:7:"updated";s:24:"2015-07-06T07:11:06.000Z";s:12:"atom_content";s:9128:"<p>作为<a href="http://efe.baidu.com/blog/replace-nested-conditional-with-guard-clauses/" target="_blank" rel="external">《嵌套条件的重构》</a> 的姊妹篇，补充说明箭形代码的缺点，并以函数分解的方式扁平化箭形代码。</p>
<p>原文：http://blog.codinghorror.com/flattening-arrow-code/</p>
<p>经常看到这种代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rowCount &gt; rowIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (drc[rowIdx].table.columns.contains(<span class="string">"avalId"</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (attributes[attrVal.attributeClassId] == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// do stuff</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(attributes[attrVal.attributeClassId])) &#123;</span><br><span class="line">                  <span class="comment">// do stuff</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!isChecking) &#123;</span><br><span class="line">                      <span class="comment">// do stuff</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// do stuff</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          rowIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rowIdx &lt; rowCount &amp;&amp; <span class="built_in">parseInt</span>(drc[rowIdx], <span class="number">10</span>) === Id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        rowIdx++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rowIdx;</span><br></pre></td></tr></table></figure>
<p>太多的条件嵌套使代码变成一个箭头的样子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">if</span></span><br><span class="line">                <span class="keyword">do</span> something</span><br><span class="line">            <span class="keyword">endif</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>当你在1280x1024 分辨率下阅读代码时会超出右边边界。这就是箭头反模式。</p>
<p>我重构的首要任务之一是把这样的箭形代码 “扁平化”。那些锋利的尖钩很危险！箭形代码有着很高的圈复杂度 – 衡量贯穿代码有多少不同路径：</p>
<blockquote>
<p>研究表明程序的质量与它的圈复杂度（<a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity" target="_blank" rel="external">WIKI</a>, <a href="http://baike.baidu.com/link?url=NhIy14F1G0pKk9NeWcromnkCAJzqZofWwvMweET_R6JolBvlX4Mf2CcLLclZ4GtPqg9Y66SDXzZ09CfIpvd6Ja" target="_blank" rel="external">百度百科</a>）有关。低圈复杂度的程序更简单易懂，修改时的风险也更低。模块的圈复杂度与它的可测试性也是高度相关的。</p>
</blockquote>
<p>在适当的地方，我通过以下方式扁平化箭形代码：</p>
<ol style="list-style-type: decimal">
<li>替换条件为 <code>guard clauses</code>，这个代码..</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SomeNecessaryCondition) &#123;</span><br><span class="line">    <span class="comment">// function body code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.. 改成 <code>guard clause</code> 会更好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SomeNecessaryCondition) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RequiredConditionMissingException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function body code</span></span><br></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li>用函数来分解条件块。在上例中，我们把 do..while 循环里的条件分解。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    validateRowAttribute(drc[rowIdx]);</span><br><span class="line">    rowIdx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (rowIdx &lt; rowCount &amp;&amp; <span class="built_in">parseInt</span>(drc[rowIdx], <span class="number">10</span>) === Id);</span><br></pre></td></tr></table></figure>
<ol start="3" style="list-style-type: decimal">
<li>将否定检查转为肯定检查。主要规则是把肯定比较置前，让否定比较自然落到 else 中。我认为这样可读性肯定更好，更重要的是，避免 “我永远不会不做” 句式。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(attributes[attrVal.attributeClassId])) &#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" style="list-style-type: decimal">
<li>总是尽快从函数返回。一旦工作完成，马上退出。这个并非永远合适的 – 你可能需要清理资源。但无论如何，你必须放弃只应在底部有一个出口的错误想法。</li>
</ol>
<p>目的是让代码在垂直方向滚动多些…而不是在水平方向上。</p>
";s:7:"summary";s:186:"
    <p>作为<a href="http://efe.baidu.com/blog/replace-nested-conditional-with-guard-clauses/" target="_blank" rel="external">《嵌套条件的重构》</a> 的姊妹篇，补充
    ";}i:10;a:7:{s:5:"title";s:44:"position:sticky实现iOS6+下的粘性布局";s:5:"link_";s:42:"http://efe.baidu.com/blog/position-sticky/";s:2:"id";s:42:"http://efe.baidu.com/blog/position-sticky/";s:9:"published";s:24:"2015-06-23T16:00:00.000Z";s:7:"updated";s:24:"2015-06-24T05:48:44.000Z";s:12:"atom_content";s:20420:"<p>用户总是希望在窗口明显的地方方便找到自己想要的操作项，例如停留在浏览器窗口顶端的菜单栏，筛选栏等。所以我们会把用户最常用到或者我们希望用户注意到的内容一直展现在窗口的可视区域，让用户能够一眼就看到。这当中常需要用到一种页面滚动然后元素固定在窗口的某个位置的布局方式（下面简称<strong>粘性布局</strong>）。</p>
<p>要实现这种粘性布局，我们常常都是通过js来模拟，实现方案是通过js监听window的<code>scroll</code>事件，当需要固定的元素滚动到窗口顶部时，把元素的position属性设置为fixed，否则，取消fixed，简单的js代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span>);</span><br><span class="line"><span class="keyword">var</span> navOffsetY = nav.offsetTop;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.scrollY &gt;= navOffsetY ? nav.classList.add(<span class="string">'fixed'</span>) : nav.classList.remove(<span class="string">'fixed'</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll);</span><br></pre></td></tr></table></figure>
<p>上面的实现在桌面浏览器的表现还是挺好的，但是在移动端浏览器上粘顶的效果就显得不那么平滑了。</p>
<a id="more"></a>
<p>特别是在iOS设备上，iOS下的浏览器会在页面滚动的时候，暂停所有js的执行，直到滚动停止才会继续去执行js（注意暂停了所有js的执行，所以考虑用<code>setTimeout</code>或<code>setInterval</code>也是没有用的）。所以页面滚动时，<code>scroll</code>事件在iOS的浏览器下并不会持续被触发，而是在页面滚动停止后，才会去触发一次<code>scroll</code>事件。 在Android 2.3及以下的版本的浏览器<code>scroll</code>事件的响应也是跟iOS一样。而Android 2.3以上的版本中虽然有部分浏览器能持续的触发<code>scroll</code>事件，但由于移动设备上惯性滚动的原因，<code>scroll</code>事件的回调函数执行渲染Dom频率还是赶不上滚动的频率，所以即使是在高版本的Android下，滚动快了，还是会看到原来fixed的元素闪跳归位。</p>
<p>下面我们来做一个<code>scroll</code>事件的测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">document</span>.querySelector(<span class="string">'#num'</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    num.innerHTML = ++count;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下图分别是测试代码在iphone 5s（iOS 7.1.1）和红米 1S（Android 4.3）中的表现：</p>
<p><img src="http://bcscdn.baidu.com/weigou-baidu-com/efe-blog-1434293785019/ios-scroll-test.gif" alt="iOS 7.1.1"> <img src="http://bcscdn.baidu.com/weigou-baidu-com/efe-blog-1434293785019/android-scroll-test.gif" alt="Android 4.3"></p>
<p>正因为iOS的浏览器这样的特性，导致元素要在滚动停止后才被设置为fixed或取消fixed，特别是取消fixed的延迟，元素在页面滚动停止后突然跳回原来的位置，这体验实在是太差了！价值一个肾的水果机，体验可不能这么不流畅啊！总得想点办法优化一下。</p>
<p>尝试监听body的<code>touchmove</code>事件，但还是由于惯性滚动的原因，并不能解决闪跳的问题。<code>iscroll</code>有个试验版本<code>iscroll-probe.js</code>能实时响应<code>touchmove</code>模拟的滚动事件，可是对整页使用iscroll，还要做这么耗cpu性能的事情，想想都可怕。但我还是试验了一下，效果也并不好。</p>
<h2 id="使用positionsticky">使用position:sticky</h2>
<p>position:sticky是属于<a href="http://dev.w3.org/csswg/css-position-3/#sticky-pos" target="_blank" rel="external">W3C Editor’s Draft</a>中的一个属性，目前仍是一个试验性的属性，并不是W3C推荐的标准。它之所以会出现，也是因为监听<code>scroll</code>事件来实现粘性布局使浏览器进入慢滚动的模式，这与浏览器想要通过硬件加速来提升滚动的体验是相悖的。大家可以从<a href="https://lists.w3.org/Archives/Public/www-style/2012Jun/0627.html" target="_blank" rel="external">这里</a>看到该属性的由来。</p>
<p>position:sticky的表现上像是position:fixed和position:relative的结合体，设置了position:sticky的元素，特征如下：</p>
<ul>
<li>元素不会脱离文档流，并保留元素在文档流中占位的大小</li>
<li>元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置</li>
<li>元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量</li>
</ul>
<p>这个有趣的属性，在各个浏览器的兼容性如何呢？看看<a href="http://caniuse.com/#search=sticky" target="_blank" rel="external">caniuse</a>给出的position:sticky在各浏览器的兼容性： <img src="/blog/position-sticky/img/sticky-caniuse.jpg"></p>
<p>上图中可看到，红了一片，大部分的浏览器并不支持该属性。可惜的是，Android下的自带浏览器居然全部都不支持该属性，还好在iOS的浏览器中，从iOS6+开始支持该CSS属性，这让我们感到一丝欣慰。</p>
<p>抱着能做好一点，就努力做好一点的态度，还是应该让大部分的iOS用户体验到平滑的感觉的，所以上面的实现粘性布局的代码可以这样改一下： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.sticky</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> -webkit-sticky</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> sticky</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.fixed</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测iOS版本大于等于6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gtIOS6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userAgent = <span class="built_in">window</span>.navigator.userAgent;</span><br><span class="line">    <span class="keyword">var</span> ios = userAgent.match(<span class="regexp">/(iPad|iPhone|iPod)\s+OS\s([\d_\.]+)/</span>);</span><br><span class="line">    <span class="keyword">return</span> ios &amp;&amp; ios[<span class="number">2</span>] &amp;&amp; (<span class="built_in">parseInt</span>(ios[<span class="number">2</span>].replace(<span class="regexp">/_/g</span>, <span class="string">'.'</span>), <span class="number">10</span>) &gt;= <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span>);</span><br><span class="line"><span class="keyword">if</span> (gtIOS6()) &#123;</span><br><span class="line">    <span class="comment">// 大于等于iOS6版本使用sticky</span></span><br><span class="line">    nav.classList.add(<span class="string">'sticky'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> navOffsetY = nav.offsetTop;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onScroll</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollY &gt;= navOffsetY ? nav.classList.add(<span class="string">'fixed'</span>) : nav.classList.remove(<span class="string">'fixed'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，对于iOS6+我们毫不犹豫的使用position:sticky属性，其实直接判断浏览器是否支持该属性，而不仅限于iOS，因为上面caniuse中提到Firefox for Android也是支持改属性的，所以我们还可以去检测浏览器是否支持sticky属性，从而决定是使用js监听事件去实现还是通过原生CSS去实现，检测代码如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否支持sticky属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSupportSticky</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prefixTestList = [<span class="string">''</span>, <span class="string">'-webkit-'</span>, <span class="string">'-ms-'</span>, <span class="string">'-moz-'</span>, <span class="string">'-o-'</span>];</span><br><span class="line">    <span class="keyword">var</span> stickyText = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prefixTestList.length; i++ ) &#123;</span><br><span class="line">        stickyText += <span class="string">'position:'</span> + prefixTestList[i] + <span class="string">'sticky;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个dom来检查</span></span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    div.style.cssText = <span class="string">'display:none;'</span> + stickyText;</span><br><span class="line">    body.appendChild(div);</span><br><span class="line">    <span class="keyword">var</span> isSupport = <span class="regexp">/sticky/i</span>.test(<span class="built_in">window</span>.getComputedStyle(div).position);</span><br><span class="line">    body.removeChild(div);</span><br><span class="line">    div = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> isSupport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在PC的浏览器测试sticky属性：</p>
<ul>
<li>Firefox 26+: 需要在<code>about:config</code>中把<code>layout.css.sticky.enabled</code>设置为“true”，FireFox 32+ 直接支持。FireFox只支持不带前缀的sticky属性（如：position:sticky）</li>
<li>Safari 6.1+: 支持使用-webkit前缀的sticky属性(如：position: -webkit-sticky)</li>
<li>Chrome 23~36: 需要在<code>chrome://flags</code>将<code>启用实验性网络平台功能</code>启用；Chrome 37+ 不支持该属性，chrome团队暂时将它移除，具体见<a href="https://code.google.com/p/chromium/issues/detail?id=231752#c28" target="_blank" rel="external">Issue</a>（需要梯子）</li>
<li>IE: 不支持。</li>
</ul>
<p>欢迎用手机扫码或者用支持sticky属性的浏览器查看上面的栗子</p>
<p><img src="/blog/position-sticky/img/qrcode.jpg"> or <a href="http://bcscdn.baidu.com/weigou-baidu-com/personal-test-1433858742567/sticky.html" target="_blank" rel="external">demo</a></p>
<h2 id="positionsticky的生效条件">position:sticky的生效条件</h2>
<p>首先，设置了postion:sticky的元素要生效必须要至少设置<code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>中的一个，而且<code>top</code>和<code>bottom</code>同时设置时，<code>top</code>生效的优先级高，<code>left</code>和<code>right</code>同时设置时，<code>left</code>生效的优先级高；其次，sticky元素生效与否有两个临界条件：</p>
<ol style="list-style-type: decimal">
<li>一个是元素自身在文档流中的位置</li>
</ol>
<p>以<code>top:10px</code>为例，当页面滚动到sticky在文档流中位置元素离viewport顶端的距离&lt;=10px时，sticky元素就开始固定了，当sticky元素在文档流中位置离viewport顶端的距离&gt;10px时，元素就不再固定。</p>
<ol start="2" style="list-style-type: decimal">
<li>另一个是该元素的父容器的边缘</li>
</ol>
<p>这种情况还是要用例子来说明（请在FireFox或者Safari查看下面给出的例子）： 
</p><p data-height="268" data-theme-id="15807" data-slug-hash="JdNqqR" data-default-tab="result" data-user="oddjohn" class="codepen">See the Pen <a href="http://codepen.io/oddjohn/pen/JdNqqR/" target="_blank" rel="external">JdNqqR</a> by john chen (<a href="http://codepen.io/oddjohn" target="_blank" rel="external">@oddjohn</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
<p></p>
<p>从上面例子可以看到，当sticky元素碰到父容器的底部时，就会跟随父元素一起滚动了。 所以如果你单纯给sticky元素加一个父容器，但是却不能使父容器的高度大于sticky元素的高度，这样并不会看到元素固定的效果的，因为一开始sticky元素就到达了父元素的边缘，它会跟着父元素滚动。</p>
<p>另外，一旦离sticky元素最近的祖先元素的<code>overflow</code>属性不是默认的<code>visible</code>，那么sticky元素固定的位置将是相对于该祖先元素，所以当改变sticky元素的父容器的<code>overflow</code>默认值时，sticky元素的固定的位置就是相对于它父容器。如设置属性<code>overflow:hidden</code>的父容器，父容器根本就不能滚动，所以sticky元素也不会有滚动然后固定的情况。</p>
<p>还有些童鞋抱怨sticky的<code>bottom</code>和<code>right</code>值设了怎么不能生效呢，那是因为你的元素所处的位置还没满足sticky生效的条件。再看下面的例子： 
</p><p data-height="268" data-theme-id="15807" data-slug-hash="OVgJZG" data-default-tab="result" data-user="oddjohn" class="codepen">See the Pen <a href="http://codepen.io/oddjohn/pen/OVgJZG/" target="_blank" rel="external">OVgJZG</a> by john chen (<a href="http://codepen.io/oddjohn" target="_blank" rel="external">@oddjohn</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>
 明显看出，只要sticky元素在文档流中的的位置超出了容器的可视区域，sticky就开始生效！<p></p>
<h2 id="positionsticky与input">position:sticky与input</h2>
<p>既然sticky拥有像fixed相似的功能，那么能否用它来替代fixed，从而解决iOS下的fixed + input的bug呢？很遗憾，经测试sticky + input在iOS下的表现跟fixed + input的bug差不多。至于怎么解决这个bug，请移步到<a href="http://efe.baidu.com/blog/mobile-fixed-layout/" target="_blank" rel="external">Web移动端Fixed布局的解决方案</a>。</p>
<p>sticky+input的表现如下图：</p>
<p><img src="/blog/position-sticky/img/input-normal.jpg"> <img src="/blog/position-sticky/img/input-bottom.jpg"></p>
<h2 id="使用css实现粘性布局的局限">使用CSS实现粘性布局的局限</h2>
<p>由于是用CSS实现的粘性布局，所以并不能让我们知道元素在什么时候stuck了，什么时候回到文档流中位置了，如果我们希望在元素置顶时改变元素的样式或者置顶的过程加上一些炫酷的动画，这就无能为力了。</p>
<h2 id="polyfill">Polyfill</h2>
<p>关于position:sticky的ployfill还是有挺多的，如下面这些：</p>
<ul>
<li><p><a href="https://github.com/filamentgroup/fixed-sticky" target="_blank" rel="external">fixed-sticky</a></p></li>
<li><p><a href="https://github.com/wilddeer/stickyfill" target="_blank" rel="external">stickyfill</a></p></li>
<li><p><a href="https://github.com/matthewp/position--sticky-" target="_blank" rel="external">position–sticky-</a></p></li>
</ul>
<h2 id="相关文章">相关文章</h2>
<ul>
<li><p><a href="http://dev.w3.org/csswg/css-position-3/#sticky-pos" target="_blank" rel="external">CSS Positioned Layout Module Level 3</a></p></li>
<li><p><a href="http://updates.html5rocks.com/2012/08/Stick-your-landings-position-sticky-lands-in-WebKit" target="_blank" rel="external">Stick your landings! position: sticky lands in WebKit</a>（需要梯子）</p></li>
<li><p><a href="http://www.sitepoint.com/css-position-sticky-introduction-polyfills/" target="_blank" rel="external">CSS “position: sticky” – Introduction and Polyfills</a></p></li>
</ul>
";s:7:"summary";s:2014:"
    <p>用户总是希望在窗口明显的地方方便找到自己想要的操作项，例如停留在浏览器窗口顶端的菜单栏，筛选栏等。所以我们会把用户最常用到或者我们希望用户注意到的内容一直展现在窗口的可视区域，让用户能够一眼就看到。这当中常需要用到一种页面滚动然后元素固定在窗口的某个位置的布局方式（下面简称<strong>粘性布局</strong>）。</p>
<p>要实现这种粘性布局，我们常常都是通过js来模拟，实现方案是通过js监听window的<code>scroll</code>事件，当需要固定的元素滚动到窗口顶部时，把元素的position属性设置为fixed，否则，取消fixed，简单的js代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span>);</span><br><span class="line"><span class="keyword">var</span> navOffsetY = nav.offsetTop;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.scrollY &gt;= navOffsetY ? nav.classList.add(<span class="string">'fixed'</span>) : nav.classList.remove(<span class="string">'fixed'</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll);</span><br></pre></td></tr></table></figure>
<p>上面的实现在桌面浏览器的表现还是挺好的，但是在移动端浏览器上粘顶的效果就显得不那么平滑了。</p>
    
    ";}i:11;a:7:{s:5:"title";s:18:"数字知多少？";s:5:"link_";s:33:"http://efe.baidu.com/blog/number/";s:2:"id";s:33:"http://efe.baidu.com/blog/number/";s:9:"published";s:24:"2015-06-16T16:00:00.000Z";s:7:"updated";s:24:"2015-06-17T03:35:32.000Z";s:12:"atom_content";s:8851:"<p>某天早上阳光明媚，挺风和日丽的，刚嚼一口早餐就被同学问到一个奇怪的问题，大概情况是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'7172328d6ddf0296e7e7d4a8'</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">parseInt</span>(str, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false ...</span></span><br><span class="line"><span class="built_in">console</span>.log(n.toString(<span class="number">16</span>) === str);</span><br></pre></td></tr></table></figure>
<p>一个巨大的16进值字符串转化成数字后再转化成对应的字符串就不相等了，实际输出的值还差得蛮远的… 这个问题的第一反应就是精度丢失啰，不过同学们可不是这么好打发的，都不说一个为什么怎能了事呢？那就让我们稍微挖一挖，看看究竟是为什么吧～</p>
<a id="more"></a>
<p><a href="https://es5.github.io/#x4.3.19" target="_blank" rel="external">根据规范</a> JavaScript 中的数字都是以64位双精度浮点类型存储，遵循<a href="http://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE 754</a>标准。</p>
<p>双精度浮点是个什么货？简单的说就是用科学记数法的形式来表示数字，比如数 N 可以表示为 x * 10 ^ y ，相应的，13000 就可以表示为 1.3 * 10 ^ 4，通过这种方式可以使用有限的存储空间表示很广的值域，比如限定 x 与 y 是两位数，那么这四位数字可以表示的数值范围是 0 ~ 9.9 * 10 ^ 99（99后面98个零 够大吧…）。但同时有限的存储空间必定会导致精度缺失，比如 123 这个数虽然在能被表示的数值范围内，但是却不能被精确的表示，只能近似的表示为 1.2 * 10 ^ 2。这其实就是之前那个问题的答案：在将字符串转化成数字时，由于64位存储空间的限制，只能近似表示为另外一个相近的数，造成了精度的丢失。</p>
<p>进一步看，采用科学记数法的64位双精度浮点类型的内存布局情况如下：</p>
<div class="figure">
<img src="/blog/number/img/layout.jpg">
</div>
<p>从高位到低位依次是 <strong>符号位（1位）</strong>，<strong>指数位（11位）</strong>，<strong>尾数位（52位）</strong></p>
<p><strong>符号位</strong>顾名思义是表示正负号的，<strong>指数位</strong>控制小数点的位置，而<strong>尾数</strong>就是具体的数值，不过它只表示小数部分，实际并不存储整数部分，而是默认整数部分为1。原因嘛，二进制下，整数部分不是1就是0，而对于0的情况可以使用指数部分为负值来控制，所以默认整数部分为1即能保证精度又能减少需要的存储空间。</p>
<p>另外这里的指数并非实际的指数，而是一种编码指数：编码指数 ＝ 实际指数 ＋ 固定值。根据规范，这个固定值是由编码指数的位数 e 来确定的：2 ^ (e - 1) - 1，具体到11位的编码指数的话这个固定值是 2 ^ (11 - 1) - 1 = 1023。由于11位的编码指数的取值范围是 0 ~ 2047（2 ^ 11 - 1）,因此实际指数的取值范围是 -1023 ~ 1024 。注意：根据标准，这里的编码指数取值是开区间 (0, 2047)。</p>
<p>令 s = 符号位，e = 编码指数，m = 尾数，则64位双精度浮点格式二进制数的计算公式为：</p>
<p>N = ((-1) ^ s) * (1 + m * 2 ^ (-52)) * 2 ^ (e - 1023)</p>
<p>其中数值部分那个独立的 1 就是那个默认的整数部分，m * 2 ^ (-52) 是尾数表示的那个小数。</p>
<h2 id="关于最大的准确整数">关于最大的准确整数</h2>
<p>之前提过由于存储空间有限，会有精度的问题。那么64位的浮点能存储的最大精确的整数是多少呢？</p>
<p>指数部分可取的最大值是 1023，即可以将小数点后移1023位，尾数只有52位，所以当编码指数为 1075 （1023 ＋ 52）时正好没有小数部分，整部部分一共53位（52位尾数 ＋ 1位的默认值），所以 2 ^ 53 - 1 ＝ 9007199254740991 就是最大能精确表示的正整数。</p>
<p>怎么来证明呢？其实 <code>Number</code> 有一个常量叫 <code>Number.MAX_SAFE_INTEGER</code> …</p>
<div class="figure">
<img src="/blog/number/img/max-safe-integer.png">
</div>
<p>通过<a href="http://treelite.me/note/make-v8" target="_blank" rel="external">重新编译v8</a>，使其支持调试，我们能查看到运行时的 JavaScript 内存布局：</p>
<div class="figure">
<img src="/blog/number/img/max-safe-integer-dump.png">
</div>
<p>红色划线部分为实际存储的值：0x433fffffffffffff（x86 及其兼容的体系都是使用<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="external">小端法</a>表示字节序滴，所以需要反转一下），换成二进制是这样滴：</p>
<div class="figure">
<img src="/blog/number/img/max-safe-integer-binary.png">
</div>
<p>最高位符号位为0，其次11位的编码指数为：100 0011 0011，也就是 1075，而剩下的尾数位全为1～</p>
<h2 id="大于最大的准确整数会怎样">大于最大的准确整数会怎样？</h2>
<p>当然是精度丢失啰，当 <code>Number.MAX_SAFE_INTEGER</code> + 1 时尾数部分全变成0，编码指数位加1，实际指数为53，相当于有54个整数位（别忘了那个默认的1），这已经超出了整个尾部的长度（52位），低位已经不受控制了（相当于开始在尾部数后面加零了…)，所以实际上 <code>Number.MAX_SAFE_INTEGER</code> + 1 == <code>Number.MAX_SAFE_INTEGER</code> + 2。</p>
<div class="figure">
<img src="/blog/number/img/over-safe-integer.png">
</div>
<h2 id="最大能表示的值">最大能表示的值</h2>
<p>就是除了符号位外，所有都为1啰（当然编码指数部分的最大取值只能是2046）：</p>
<p>根据之前的公式：((-1) ^ s) * (1 + m * 2 ^ (-52)) * 2 ^ (e - 1023)<br> = (-1) ^ 0 * (1 + (2 ^ 52 - 1) * 2 ^ (-52)) * 2 ^ (2046 - 1023)<br> = (1 + (Math.pow(2, 52) - 1) * Math.pow(2, -52)) * Math.pow(2, 2046 - 1023)<br> = 1.7976931348623157e+308</p>
<p>同样滴，也有一个叫 <code>Number.MAX_VALUE</code> 的东东：</p>
<div class="figure">
<img src="/blog/number/img/max-number.png">
</div>
<p>实际内存布局：</p>
<div class="figure">
<img src="/blog/number/img/max-number-dump.png">
</div>
<p>相应的二进制表示：</p>
<div class="figure">
<img src="/blog/number/img/max-number-binary.png">
</div>
<h2 id="关于零">关于零</h2>
<p>由于默认有一个为1的整数位，那双精度浮点数怎么表示零呢？之前有提到编码指数取值是(0, 2047)的开区间，实际这种情况被称之为“规格化值”，而编码指数为0时被特殊称之为“非规范化值”。对于非规范化值规范特殊规定不再默认有一个为1的整数位，而且实际指数调整为：实际指数 = 1 - 固定值。所以只要此时尾数也为0就能真正的表示数零了～（当然还有符号，实际上在某些时候正负零是有区别的…）。另外由于非规范化值的实际指数是一个常量：实际指数 = 1 - 1023 = -1022，所以除了表示零，非规范化值还能表示非常接近于零的数。至于为啥实际指数被指定为 1 - 固定值，是为了让非规格化值与规格化值之间能平滑过渡，这么规定以后最大的非规范化值与最小的规范化值（此处都是指正数范围）的实际指数都为-1022，而两者的数值部分正好相差1（一边儿是52个的1，另一边儿是52个的0加一个默认的1）～</p>
<p>最后，编码指数还有一种特殊的取值是全为1，规范规定此时如果尾数全为0则表示无穷（同样，算上符号位有正负无穷之分），而对于尾数不为0的值则称之为“NaN”。至此，无穷＋规范化值＋非规范化值 就能表示一个完整的数值域了～</p>
<div class="figure">
<img src="/blog/number/img/all.jpg">
</div>
<h2 id="参考">参考</h2>
<ul>
<li>《<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统</a>》</li>
<li><a href="http://zh.wikipedia.org/wiki/IEEE_754" class="uri" target="_blank" rel="external">http://zh.wikipedia.org/wiki/IEEE_754</a></li>
<li><a href="http://segmentfault.com/a/1190000000407658" class="uri" target="_blank" rel="external">http://segmentfault.com/a/1190000000407658</a></li>
</ul>
";s:7:"summary";s:1282:"
    <p>某天早上阳光明媚，挺风和日丽的，刚嚼一口早餐就被同学问到一个奇怪的问题，大概情况是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'7172328d6ddf0296e7e7d4a8'</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">parseInt</span>(str, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false ...</span></span><br><span class="line"><span class="built_in">console</span>.log(n.toString(<span class="number">16</span>) === str);</span><br></pre></td></tr></table></figure>
<p>一个巨大的16进值字符串转化成数字后再转化成对应的字符串就不相等了，实际输出的值还差得蛮远的… 这个问题的第一反应就是精度丢失啰，不过同学们可不是这么好打发的，都不说一个为什么怎能了事呢？那就让我们稍微挖一挖，看看究竟是为什么吧～</p>
    
    ";}i:12;a:7:{s:5:"title";s:13:"1px on retina";s:5:"link_";s:40:"http://efe.baidu.com/blog/1px-on-retina/";s:2:"id";s:40:"http://efe.baidu.com/blog/1px-on-retina/";s:9:"published";s:24:"2015-05-31T16:00:00.000Z";s:7:"updated";s:24:"2015-06-01T05:49:02.000Z";s:12:"atom_content";s:21119:"<p>一直以来我们实现边框的方法都是设置 <code>border: 1px solid #ccc</code>，但是在<code>retina</code>屏上因为设备像素比的不同，边框在移动设备上的表现也不相同：<code>1px</code>可能会被渲染成<code>1.5px, 2px, 2.5px, 3px....</code>，在用户体验上略差，所以现在要解决的问题就是在<code>retina</code>屏幕实现<code>1px</code>边框。</p>
<p>如果你去<code>google</code>类似问题，诚然会找到所谓的”答案“，然后很开森的用到项目中了。运气好的话，Yeah成功模拟1px了，运气不好了可能遇到各种奇葩的表现让你抓狂。</p>
<p>这篇文章总结了目前常用的模拟<code>1px</code>的方法，并分析各个方法的利弊。</p>
<a id="more"></a>
<h3 id="实现方案">实现方案</h3>
<h4 id="软图片">1、软图片</h4>
<p>‘软图片’，即通过<strong>CSS渐变</strong>模拟，代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.retina</span>(<span class="variable">@top</span>: transparent, <span class="variable">@right</span>: transparent, <span class="variable">@bottom</span>: transparent, <span class="variable">@left</span>: transparent, <span class="variable">@w</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">    <span class="at_rule">@media</span> only screen and (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>),</span><br><span class="line">    only screen and (<span class="attribute">min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="attribute">border</span>: none;</span><br><span class="line">        <span class="attribute">background-image</span>:</span><br><span class="line">            <span class="function">linear-gradient</span>(<span class="number">180deg</span>, <span class="variable">@top</span>, <span class="variable">@top</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">            <span class="function">linear-gradient</span>(<span class="number">270deg</span>, <span class="variable">@right</span>, <span class="variable">@right</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">            <span class="function">linear-gradient</span>(<span class="number">0deg</span>, <span class="variable">@bottom</span>, <span class="variable">@bottom</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">            <span class="function">linear-gradient</span>(<span class="number">90deg</span>, <span class="variable">@left</span>, <span class="variable">@left</span> <span class="number">50%</span>, transparent <span class="number">50%</span>);</span><br><span class="line">        <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="variable">@w</span>, <span class="variable">@w</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="variable">@w</span>, <span class="variable">@w</span> <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">        <span class="attribute">background-position</span>: top, right top,  bottom, left top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可能是从网上找到的出现最频繁的代码了，但是这样写是有兼容问题的，</p>
<p>测试小米2自带浏览器、手机百度、百度浏览器都显示不出上边框，如图：</p>
<div class="figure">
<img src="/blog/1px-on-retina/img/xiaomi2.png">
</div>
<p>测试小米2 chrome浏览器正常，如图：</p>
<div class="figure">
<img src="/blog/1px-on-retina/img/xiaomi2-chrome.png">
</div>
<p>这种情况我们会考虑是不是没有写浏览器前缀<code>-webkit-</code>的原因，好，我们加上：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>:</span><br><span class="line">     <span class="function">-webkit-linear-gradient</span>(<span class="number">180deg</span>, <span class="variable">@top</span>, <span class="variable">@top</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">     <span class="function">-webkit-linear-gradient</span>(<span class="number">270deg</span>, <span class="variable">@right</span>, <span class="variable">@right</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">     <span class="function">-webkit-linear-gradient</span>(<span class="number">0</span>, <span class="variable">@bottom</span>, <span class="variable">@bottom</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">     <span class="function">-webkit-linear-gradient</span>(<span class="number">90deg</span>, <span class="variable">@left</span>, <span class="variable">@left</span> <span class="number">50%</span>, transparent <span class="number">50%</span>);</span><br></pre></td></tr></table></figure>
<p>再次检测小米2自带浏览器、手机百度、百度浏览器、chrome，这一次表现都一致！慢着好像有些不对：</p>
<div class="figure">
<img src="/blog/1px-on-retina/img/xiaomi2-bug.png">
</div>
<p>怎么会这样呢？？看样子是渐变方向不对，通过调整渐变方向得到结果：加上<code>-webkit</code>私有前缀的<code>0deg</code>的渐变方向是<strong>从左向右</strong>，而规范定义的<code>0deg</code>的渐变方向是<strong>自下而上</strong>。</p>
<p>知道原因了，我们再改改代码吧：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>:</span><br><span class="line">    <span class="function">-webkit-linear-gradient</span>(<span class="number">270deg</span>, <span class="variable">@top</span>, <span class="variable">@top</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">    <span class="function">-webkit-linear-gradient</span>(<span class="number">180deg</span>, <span class="variable">@right</span>, <span class="variable">@right</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">    <span class="function">-webkit-linear-gradient</span>(<span class="number">90deg</span>, <span class="variable">@bottom</span>, <span class="variable">@bottom</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">    <span class="function">-webkit-linear-gradient</span>(<span class="number">0</span>, <span class="variable">@left</span>, <span class="variable">@left</span> <span class="number">50%</span>, transparent <span class="number">50%</span>);</span><br><span class="line"><span class="attribute">background-image</span>:</span><br><span class="line">    <span class="function">linear-gradient</span>(<span class="number">180deg</span>, <span class="variable">@top</span>, <span class="variable">@top</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">    <span class="function">linear-gradient</span>(<span class="number">270deg</span>, <span class="variable">@right</span>, <span class="variable">@right</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">    <span class="function">linear-gradient</span>(<span class="number">0deg</span>, <span class="variable">@bottom</span>, <span class="variable">@bottom</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</span><br><span class="line">    <span class="function">linear-gradient</span>(<span class="number">90deg</span>, <span class="variable">@left</span>, <span class="variable">@left</span> <span class="number">50%</span>, transparent <span class="number">50%</span>);</span><br></pre></td></tr></table></figure>
<p>Done！</p>
<p>优点：</p>
<ul>
<li>可以实现单个、多个边框，大小、颜色可以配置</li>
<li>对比下面介绍的其他方法，这个方法兼容性比较好，实现效果也相对不错</li>
</ul>
<p>缺点：</p>
<ul>
<li>很明显代码特别长</li>
<li>无法实现圆角</li>
<li>使用时可能需要配合 <code>padding</code>，如设置子元素的背景可能会挡住父元素所设置的1px软图片</li>
<li>如果有背景颜色，要写成<code>background-color</code>，不然会不小心覆盖掉</li>
<li>对于非 <code>retina</code> 屏，需要写 <code>border: 1px solid #f00</code> 进行适配</li>
</ul>
<h4 id="缩放">2、缩放</h4>
<p>‘缩放’，即使用<code>css transform</code>缩放一半的大小，代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.transform-scale</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="keyword">&amp;</span><span class="pseudo">:after</span>,</span><br><span class="line">    <span class="keyword">&amp;</span><span class="pseudo">:before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">-webkit-transform</span>: <span class="function">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="function">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">        <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="hexcolor">#f00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">&amp;</span><span class="pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">top</span>: auto;</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>实现单线条简单</li>
<li>大小、颜色可以配置</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法实现圆角</li>
<li>四条边框比较纠结</li>
<li>依赖DOM，可能会与已有样式冲突，如常用的<code>clearfix</code></li>
</ul>
<h4 id="阴影">3、阴影</h4>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.shadow</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-box-shadow</span>:<span class="value"><span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> <span class="function">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"><span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> <span class="function">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>)</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>没觉得这个方法好用，模拟的效果差强人意，颜色也不好配置，不推荐</p>
<h4 id="px">4、0.5px</h4>
<p>终于等来了<code>0.5px</code>，虽然只有<code>IOS8+</code>才支持</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IOS8 hairline</span></span><br><span class="line"><span class="class">.hairline</span>(<span class="variable">@color</span>, <span class="variable">@style</span>:solid) &#123;</span><br><span class="line">    <span class="at_rule">@media</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">0.5px</span> <span class="variable">@style</span> <span class="variable">@color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>“原生”，支持圆角~</li>
</ul>
<p>缺点：</p>
<ul>
<li>目前只有<code>IOS8+</code>才支持，在IOS7及其以下、安卓系统都是显示为0px</li>
</ul>
<h4 id="viewportrem">5、viewport&amp;&amp;rem</h4>
<p><a href="http://www.ghugo.com/css-retina-hairline/" target="_blank" rel="external">再谈mobile web retina 下 1px 边框解决方案</a>介绍了<code>viewport</code>结合<code>rem</code>解决设备像素比的问题，即让我们像以前写1倍像素那样写页面。</p>
<p>如在<code>devicePixelRatio=2</code>下设置<code>&lt;meta&gt;</code>：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="variable">name=</span><span class="string">"viewport"</span> <span class="variable">content=</span><span class="string">"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>再设置<code>rem</code>，假设header的高度是30px(设备像素比为1的情况)：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">html</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="tag">header</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">3rem</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>没有具体实践过，不知道有神马坑~</p>
<p>PS：淘宝、美团移动端页面都是采用这个方式实现的</p>
<h4 id="border-image">6、border-image</h4>
<p>使用的背景图片：</p>
<div class="figure">
<img src="/blog/1px-on-retina/img/border-image.png">
</div>
<p>代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.border-image-1px</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">1px</span> <span class="number">0px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-border-image</span>:<span class="value"> <span class="function">url</span>(border.png) <span class="number">2</span> <span class="number">0</span> stretch</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">border-image</span>:<span class="value"> <span class="function">url</span>(border.png) <span class="number">2</span> <span class="number">0</span> stretch</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>额，，，</li>
</ul>
<p>缺点：</p>
<ul>
<li>大小、颜色更改不灵活</li>
<li>放到PS里面看边框，是有点模糊的(因为带有颜色部分是1px，在retina屏幕上拉伸到2px肯定会有点模糊)</li>
</ul>
<h3 id="总结">总结</h3>
<p>1、<code>0.5px</code>，相信浏览器肯定是会慢慢支持的；目前而言，如果能用的话，可以hack一下；</p>
<p>2、阴影，<code>border-image</code>的方案不建议使用（用了你就知道。。。）</p>
<p>3、背景图片和缩放可以在项目中配合使用，如单个线条使用缩放，四条框用背景图片模拟，额，如果要圆角的话，无能无力了</p>
<h3 id="其他">其他</h3>
<ul>
<li><p><a href="http://www.ghugo.com/css-retina-hairline/" target="_blank" rel="external">再谈mobile web retina 下 1px 边框解决方案</a></p></li>
<li><p><a href="https://github.com/maxzhang/maxzhang.github.com/issues/4" target="_blank" rel="external">使用border-image实现类似iOS7的1px底边</a></p></li>
</ul>
<h3 id="demo">Demo</h3>
<p><a href="http://jsbin.com/witida/1/edit?html,css,output" target="_blank" rel="external">1px Demo - jsbin</a></p>
<div class="figure">
<img src="/blog/1px-on-retina/img/demo.png">
</div>
";s:7:"summary";s:777:"
    <p>一直以来我们实现边框的方法都是设置 <code>border: 1px solid #ccc</code>，但是在<code>retina</code>屏上因为设备像素比的不同，边框在移动设备上的表现也不相同：<code>1px</code>可能会被渲染成<code>1.5px, 2px, 2.5px, 3px....</code>，在用户体验上略差，所以现在要解决的问题就是在<code>retina</code>屏幕实现<code>1px</code>边框。</p>
<p>如果你去<code>google</code>类似问题，诚然会找到所谓的”答案“，然后很开森的用到项目中了。运气好的话，Yeah成功模拟1px了，运气不好了可能遇到各种奇葩的表现让你抓狂。</p>
<p>这篇文章总结了目前常用的模拟<code>1px</code>的方法，并分析各个方法的利弊。</p>
    
    ";}i:13;a:7:{s:5:"title";s:27:"CSS硬件加速的好与坏";s:5:"link_";s:75:"http://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/";s:2:"id";s:75:"http://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/";s:9:"published";s:24:"2015-05-25T16:00:00.000Z";s:7:"updated";s:24:"2015-05-26T06:46:00.000Z";s:12:"atom_content";s:9895:"<blockquote>
<p>本文翻译自Ariya Hidayat的<a href="http://calendar.perfplanet.com/2014/hardware-accelerated-css-the-nice-vs-the-naughty/" target="_blank" rel="external">Hardware Accelerated CSS: The Nice vs The Naughty</a>。感谢<a href="https://github.com/599316527" target="_blank" rel="external">Kyle He</a>帮助校对。</p>
</blockquote>
<p>每个人都痴迷于<a href="http://paulbakaus.com/tutorials/performance/the-illusion-of-motion/" target="_blank" rel="external">60桢每秒</a>的顺滑动画。为了实现这个顺滑体验现在用的最流行的一个做法就是使用『<a href="http://www.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/" target="_blank" rel="external">CSS硬件加速</a>』。在一些极端例子中，强制使用translate3d意味着大大提高应用程序的性能。</p>
<p>现代浏览器大都可以利用GPU来加速<a href="http://blogs.msdn.com/b/ie/archive/2010/09/10/the-architecture-of-full-hardware-acceleration-of-all-web-page-content.aspx" target="_blank" rel="external">页面渲染</a>。在GPU的众多特性之中，它可以存储一定数量的纹理（一个矩形的像素点集合）并且高效地操作这些纹理（比如进行特定的移动、缩放和旋转操作）。这些特性在实现一个<a href="http://ariya.ofilabs.com/2013/06/optimizing-css3-for-gpu-compositing.html" target="_blank" rel="external">流畅的动画</a>时特别有用。浏览器不会在动画的每一帧都绘制一次，而是生成DOM元素的快照，并作为GPU纹理（也被叫做层）存储起来。之后浏览器只需要告诉GPU去转换指定的纹理来实现DOM元素的动画效果。这就叫做<strong>GPU合成</strong>，也经常被称作『硬件加速』。</p>
<p>不幸的是，浏览器是一个很<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="external">复杂</a>的软件（Firefox有<a href="https://www.openhub.net/p/firefox/analyses/latest/languages_summary" target="_blank" rel="external">几百万行代码</a>）。因此一句简单的『使用translate3d来提高性能』并不能囊括所有的情况。如果碰巧有效那不过是瞎猫碰上死耗子而已。所以有必要知道更多的运行机制，才能更好地处理实际情况。</p>
<a id="more"></a>
<p>想象使用GPU加速的动画就像是Vin Diesel（速度与激情的主角）开着Dominic标志性的汽车 —— Dodge Charger。它的定制900 hp引擎可以让它在一瞬间从0加速到60码。但是如果你开着它在拥挤的高速公路上又有什么用呢？这种情况下你选择的车辆Charger是正确的。但是问题是你还在一个拥堵的高速公路上。</p>
<p>GPU合成也是同样的道理。许多动画还是需要CPU的介入，这毕竟是浏览器工作的方式，你无法改变它。而连接CPU和GPU的总线的带宽不是无限的，所以需要关注数据在CPU和GPU之间的传输，要尽量避免造成通道的拥挤。换句话说你需要一直注意<strong>像素的传输</strong>。</p>
<div class="figure">
<img src="/blog/hardware-accelerated-css-the-nice-vs-the-naughty/1.png">
</div>
<p>首先也是最重要的任务就是了解创建的<strong>合成层的数量</strong>。因为每一个层都对应了一个GPU纹理，所以有太多的层会消耗很多内存。这可能导致出现预期之外的行为，可能会导致潜在的崩溃。幸运的是你很容易就能通过浏览器来检查页面上的合成层数量。</p>
<ul>
<li>对于Firefox，打开<code>about:config</code>然后设置<code>layers.draw-borders</code>为true。</li>
<li>如果是Chrome用户，打开<code>chrome://flags/#composited-layer-borders</code>启用，然后打开开发工具勾选<code>Show composited layer borders</code>。</li>
<li>对于Safari用户，先打开终端运行<code>defaults write com.apple.Safari IncludeInternalDebugMenu 1</code>。然后重新启动下Safari，菜单中找到一个开发菜单打开Web检查器就能在右边看到一个tab叫『层』了。选中之后你就可以在Web检查器的<a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/ResourcesandtheDOM/ResourcesandtheDOM.html#//apple_ref/doc/uid/TP40007874-CH3-SW8" target="_blank" rel="external">边栏</a>中看到每个层的内存消耗。</li>
</ul>
<p>当这些浏览器都正确的配置之后，每个DOM元素的合成层都会被标记一个额外的边框（你可以通过这个<a href="http://ariya.github.io/css/spinningcube/" target="_blank" rel="external">Spinning Cube</a> Demo来测试下）。用这种方法就可以验证你的页面是否有太多的层。</p>
<p>另一个重点就是保持GPU和CPU之间的传输量达到最小值。换句话说，层的更新数量最好是一个理想的常量。每次合成层更新，一堆新的像素就可能需要传输给GPU。因此为了高性能，在动画开始之后避免层的更新也是很重要的（避免动画进行中时有其他层一直更新导致拥堵）。这可以通过选择<a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank" rel="external">恰当的CSS属性</a>实现动画来解决：<a href="http://dev.w3.org/csswg/css-transforms/" target="_blank" rel="external">transformation</a>（translate, scale, rotate）、<a href="http://dev.w3.org/csswg/css-color/#transparency" target="_blank" rel="external">opacity</a>或者<a href="http://dev.w3.org/fxtf/filters/" target="_blank" rel="external">filters</a>。</p>
<p>如果你在使用Safari的web检查器，选择『层』标签后就能在侧栏看到『绘图』区域。这里的数字代表了Safari提交当前层的新纹理次数。在<a href="http://codepen.io/ariya/full/xuwgy" target="_blank" rel="external">Colorful Boxes</a>这个demo上试一试。这个demo中每个box都会不停地修改自己的背景颜色。不幸地是修改box的背景色会强制合成层更新纹理，因此它的『绘图』数量会不停的变大。如果只有一个盒子，那还没什么关系，如果是几百个盒子那就很容易达到GPU的瓶颈。当然这是一个极端的例子，只是提醒下你在这种情况下<code>translate3d</code>也救不了你。</p>
<p>需求是创造之源。合成层的限制也会引导我们创造更多令人惊讶的方法来利用浏览器的硬件加速特性。比如我们可以将UI的初始状态和结束状态放在同一个合成层中，然后通过<a href="https://www.youtube.com/watch?v=RCFQu0hK6bU" target="_blank" rel="external">剪切</a>的方法来显示一部分并隐藏另一部分。还有一个类似的方法是通过<a href="http://ariya.ofilabs.com/2014/02/tricks-for-gpu-composited-css.html" target="_blank" rel="external">两层叠加</a>造成视觉错觉来实现一些特别的效果。通过修改两个层的透明度来实现动画效果，比如这个<a href="http://codepen.io/ariya/full/nFADe" target="_blank" rel="external">Glowing Effect</a> demo。</p>
<p>另外一个常用的方法就是维护一个合成层池，这样也可以减少像素的传输。当有些层不需要的时候，它们不会被销毁。它们会被移到屏幕之外或者设置为透明的。在一些情况下，UI设计时可以规定一个固定的合成层数量。比如下面这个<a href="http://ariya.github.io/kinetic/5/index.html" target="_blank" rel="external">Cover Flow</a>的例子，同时只能显示9张图片。即使它需要可以显示成千上万的书本封面（在左右滑动时），你也不需要一次性构建这么多合成层。只需要一个小小的修改，那就是在滑动时将旧图片的层移出作为新图片的层使用。用户根本不会感觉到变化。</p>
<div class="figure">
<img src="/blog/hardware-accelerated-css-the-nice-vs-the-naughty/2.png">
</div>
<p>同样不要忘记你必须使用性能检测工具（profiler）来检查你的理论是否成立。性能优化是非常严肃的话题，如果只是依靠自己的直觉那就很容易出错。Chrome的用户应该启用<code>chrome://flags/#show-fps-counter</code>。同样Firefox也要在<code>about:config</code>里面启用<code>layers.acceleration.draw-fps</code>。通过帧率来检测你的动画。如果帧率下降到60fps（或者没达到你要的效果），那么就该调查下原因。Chrome的<a href="https://developer.chrome.com/devtools/docs/timeline#frames-mode" target="_blank" rel="external">Timeline特性</a>或者Safari的<a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/Instruments/Instruments.html#//apple_ref/doc/uid/TP40007874-CH4-SW4" target="_blank" rel="external">Timeline面板</a>都可以让你了解渲染过程中的细节：layout、painting和合成。</p>
<p>为了做好性能的回归测试，自动实现如上操作是很有必要的。这时<a href="http://nparashuram.com/" target="_blank" rel="external">Parashuram</a>的<a href="https://github.com/axemclion/browser-perf" target="_blank" rel="external">browser-perf</a>就会变得非常有用。几星期前他已经写过一些<a href="http://calendar.perfplanet.com/2014/automating-web-page-rendering-performance/" target="_blank" rel="external">博文</a>来介绍自动化测试网页性能。对于本文的情况，<a href="http://blog.nparashuram.com/2014/06/gpu-composited-css-and-browser-perf.html" target="_blank" rel="external">测量层数和层更新次数</a>是非常有用的。有了这些数据你就可以在数值超过限制的时候告警。</p>
<p>已经有许多文章讲述过CSS硬件加速这个课题了，希望这篇文章能成为另一个快速帮助手册，教你如何正确地使用GPU合成来加速你的CSS动画。远离麻烦丝般顺滑！</p>
";s:7:"summary";s:2085:"
    <blockquote>
<p>本文翻译自Ariya Hidayat的<a href="http://calendar.perfplanet.com/2014/hardware-accelerated-css-the-nice-vs-the-naughty/">Hardware Accelerated CSS: The Nice vs The Naughty</a>。感谢<a href="https://github.com/599316527">Kyle He</a>帮助校对。</p>
</blockquote>
<p>每个人都痴迷于<a href="http://paulbakaus.com/tutorials/performance/the-illusion-of-motion/">60桢每秒</a>的顺滑动画。为了实现这个顺滑体验现在用的最流行的一个做法就是使用『<a href="http://www.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/">CSS硬件加速</a>』。在一些极端例子中，强制使用translate3d意味着大大提高应用程序的性能。</p>
<p>现代浏览器大都可以利用GPU来加速<a href="http://blogs.msdn.com/b/ie/archive/2010/09/10/the-architecture-of-full-hardware-acceleration-of-all-web-page-content.aspx">页面渲染</a>。在GPU的众多特性之中，它可以存储一定数量的纹理（一个矩形的像素点集合）并且高效地操作这些纹理（比如进行特定的移动、缩放和旋转操作）。这些特性在实现一个<a href="http://ariya.ofilabs.com/2013/06/optimizing-css3-for-gpu-compositing.html">流畅的动画</a>时特别有用。浏览器不会在动画的每一帧都绘制一次，而是生成DOM元素的快照，并作为GPU纹理（也被叫做层）存储起来。之后浏览器只需要告诉GPU去转换指定的纹理来实现DOM元素的动画效果。这就叫做<strong>GPU合成</strong>，也经常被称作『硬件加速』。</p>
<p>不幸的是，浏览器是一个很<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">复杂</a>的软件（Firefox有<a href="https://www.openhub.net/p/firefox/analyses/latest/languages_summary">几百万行代码</a>）。因此一句简单的『使用translate3d来提高性能』并不能囊括所有的情况。如果碰巧有效那不过是瞎猫碰上死耗子而已。所以有必要知道更多的运行机制，才能更好地处理实际情况。</p>
    
    ";}i:14;a:7:{s:5:"title";s:30:"使用ES6进行开发的思考";s:5:"link_";s:47:"http://efe.baidu.com/blog/es6-develop-overview/";s:2:"id";s:47:"http://efe.baidu.com/blog/es6-develop-overview/";s:9:"published";s:24:"2015-05-20T16:00:00.000Z";s:7:"updated";s:24:"2015-05-21T01:39:14.000Z";s:12:"atom_content";s:23270:"<p>ECMAScript6已经于近日进入了RC阶段，而早在其处于社区讨论时，我就开始一直在尝试使用ES6进行开发的方案。在<a href="https://babeljs.io" target="_blank" rel="external">Babel</a>推出后，基于ES6的开发也有了具体可执行的解决方案，无论是Build还是Debug都能得到很好的支持。</p>
<p>而在有了充足的环境、工具之后，我们面临的是对ES6众多新特性的选择和分析，以便选取一个最佳的子集，让我们可以享受ES6带来的便利（减少代码量、提高可读性等）的同时，也可以顺利运行于当前以ES3-ES5为主的浏览器环境中。</p>
<p>经过分析后，本文试图对ES6各个特性得出是否适合应用的初步结论，并一一解释其使用场景。ES6的特性列表选自<a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">es6features</a>。</p>
<ul>
<li>★★★ 推荐使用</li>
<li>★★ 有考虑地使用</li>
<li>★ 慎重地使用</li>
<li>☆ 不使用</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">特性</th>
<th align="center">推荐程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">arrows</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">classes</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">enhanced object literals</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">template strings</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">destructuring</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">default + rest + spread</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">let + const</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">iterators + for..of</td>
<td align="center">★★</td>
</tr>
<tr class="odd">
<td align="left">generators</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">unicode</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">modules</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">module loaders</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">map + set + weakmap + weakset</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">proxies</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">symbols</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">subclassable built-ins</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">promises</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">math + number + string + array + object APIs</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">binary and octal literals</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">reflect api</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">tail calls</td>
<td align="center">★★</td>
</tr>
</tbody>
</table>
<p>接下来我们以上特性挨个进行介绍。需要关注一点：如果你不想使用shim库（如Babel的<code>browser-polyfill.js</code>和<code>generatorsRuntime.js</code>）或者想使用尽可能少的helper（Babel的<code>externalHelpers</code>配置），那么需要按你的需求进一步缩减可使用的ES6特性，如<code>Map</code>、<code>Set</code>这些就不应该使用。</p>
<a id="more"></a>
<h2 id="语法增强类">语法增强类</h2>
<h3 id="arrow-function">Arrow function</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow functions</a>是ES6在语法上提供的一个很好的特性，其特点有：</p>
<ul>
<li>语法更为简洁了。</li>
<li>文法上的固定<code>this</code>对象。</li>
</ul>
<p>我们<strong>鼓励在可用的场景下使用Arrow functions</strong>，并以此代替原有的<code>function</code>关键字。</p>
<p>当然Arrow functions并不是全能的，在一些特别的场景下并不十分适用，最为典型的是Arrow functions无法提供函数名称，因此做递归并不方便。虽然可以使用<a href="http://en.wikipedia.org/wiki/Y_combinator" target="_blank" rel="external">Y combinator</a>来实现函数式的递归，但其可读性会有比较大的损失。</p>
<p>配合后文会提到的对象字面量增强，现在我们定义方法/函数会有多种方式，建议执行以下规范：</p>
<ul>
<li><p>所有的Arrow functions的参数均使用括号<code>()</code>包裹，即便只有一个参数：</p>
<pre><code>// Good
let foo = (x) =&gt; x + 1;

// Bad
let foo = x =&gt; x + 1;</code></pre></li>
<li><p>定义函数尽量使用Arrow functions，而不是<code>function</code>关键字：</p>
<pre><code>// Good
let foo = () =&gt; {
    // code
};

// Bad
function foo() {
    // code
}

// Bad
let foo = function () {
    // code
}</code></pre>
<p>除非当前场景不合适使用Arrow functions，如函数表达式需要自递归、需要运行时可变的<code>this</code>对象等。</p></li>
<li><p>对于对象、类中的方法，使用增强的对象字面量：</p>
<pre><code>// Good
let foo = {
    bar() {
        // code
    }
};

// Bad
let foo = {
    bar: () =&gt; {
        // code
    }
};

// Bad
let foo = {
    bar: function () {
        // code
    }
};</code></pre></li>
</ul>
<h3 id="增强的对象字面量">增强的对象字面量</h3>
<p>对象字面量的增强主要体现在3个方面：</p>
<h4 id="可在对象中直接定义方法">可在对象中直接定义方法</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们<strong>推荐使用</strong>这种方式定义方法。</p>
<h4 id="可使用通过计算得出的键值">可使用通过计算得出的键值</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MY_KEY = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    [MY_KEY + <span class="string">'Hash'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们<strong>推荐在需要的时候使用计算得出的键值</strong>，以便在一个语句中完成整个对象的声明。</p>
<h4 id="与当前scope中同名变量的简写">与当前Scope中同名变量的简写</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    bar <span class="comment">// 相当于bar: bar</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们<strong>并不推荐</strong>这样的用法，这对可读性并没有什么帮助。</p>
<h3 id="模板字符串">模板字符串</h3>
<p>模板字符串的主要作用有2个：</p>
<h3 id="多行字符串">多行字符串</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html =</span><br><span class="line">`&lt;div&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span>`</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出，实际使用多行字符串时，对齐是个比较麻烦的事。如果<code>let html</code>这一行本身又有缩进，那么会让代码更为难受一些。</p>
<p>因此我们<strong>不推荐使用多行字符串</strong>，必要时还是可以使用数组和<code>join('')</code>配合，而生成HTML的场景我们应该尽量使用模板引擎。</p>
<h4 id="字符串变量替换">字符串变量替换</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = `Hello $&#123;name&#125;, it<span class="string">'s $&#123;time&#125; now`;</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常方便的功能，我们<strong>鼓励使用</strong>。但需要注意这些变量并不会被HTML转义，所以在需要HTML转义的场景，还是乖乖使用模板引擎或者其它的模板函数。</p>
<h3 id="解构">解构</h3>
<p>解构（原谅我没什么好的翻译）是个比较复杂的语法，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;id, name, children&#125; = getTreeRoot();</span><br></pre></td></tr></table></figure>
<p>还可以有更复杂的，具体可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">MDN的文档</a>。</p>
<p>对于这样一个复杂且多变的语法，我们要有选择地使用，建议遵循以下原则：</p>
<ul>
<li>不要一次通过解构定义过多的变量，建议不要超过5个。</li>
<li>谨慎在解构中使用“剩余”功能，即<code>let [foo, bar, ...rest] = getValue()</code>这种方式。</li>
<li>不要在对象解构中使用过深层级，建议不要超过2层。</li>
</ul>
<h3 id="函数参数增强">函数参数增强</h3>
<p>ES6为函数参数提供了默认值、剩余参数等功能，同时在调用函数时允许将数组展开为参数，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (x = <span class="number">1</span>) =&gt; x + <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extend = (source, ...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> target <span class="keyword">in</span> args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> <span class="built_in">Object</span>.keys(target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!source.hasOwnProperty(name) &#123;</span><br><span class="line">                source[name] = target[name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extensions = [</span><br><span class="line">    &#123;name: <span class="string">'Zhang'</span>&#125;,</span><br><span class="line">    &#123;age: <span class="number">17</span>&#125;,</span><br><span class="line">    &#123;work: <span class="string">'hard'</span>&#125;</span><br><span class="line">];</span><br><span class="line">extend(&#123;&#125;, ...extensions);</span><br></pre></td></tr></table></figure>
<p>我们<strong>鼓励使用这些特性让函数的声明和调用变得更为简洁</strong>，但有一些细节需要注意：</p>
<ul>
<li>在使用默认参数时，如果参数默认值是固定且不会修改的，建议使用一个常量来作为默认值，避免每一次生成的开销。</li>
<li>不要对<code>arguments</code>对象使用展开运算，这不是一个数组。</li>
</ul>
<h2 id="关键字类">关键字类</h2>
<h3 id="let和const">let和const</h3>
<p>这是2个用来定义变量的关键字，众所周知的，<code>let</code>表示块作用域的变量，而<code>const</code>表示常量。</p>
<p>需要注意的是，<code>const</code>仅表示这个变量不能被再将赋值，但并不表示变量是对象、数组时其内容不能改变。如果需要一个不能改变内容的对象、数组，使用<code>Object.freeze</code>方法定义一个真正的常量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULT_OPTIONS = <span class="built_in">Object</span>.freeze(&#123;id: <span class="number">0</span>, name: <span class="string">'unknown'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>不过如果你在程序中能控制不修改对象的话，这并不具备什么意义，<code>Object.freeze</code>是否会引起执行引擎的进一步优化也尚未得到证实。</p>
<p>我们<strong>推荐使用<code>let</code>全面替代<code>var</code></strong>。同时<strong>建议仅在逻辑上是常量的情况下使用<code>const</code></strong>，不要任何不会被二次赋值的场景均使用<code>const</code>。</p>
<h3 id="迭代器和for..of">迭代器和for..of</h3>
<p>迭代器是个好东西，至少我们可以很简单地遍历数组了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是迭代器本身存在一些细微的缺点：</p>
<ul>
<li>性能稍微差了一些，对于数组来说大致与<code>Array.prototype.forEach</code>相当，比不过原生的<code>for</code>循环。</li>
<li>不能在循环体中得到索引<code>i</code>的值，因此如果需要索引则只能用原生的<code>for</code>循环。</li>
<li>判断一个对象是否可迭代比较烦人，没有原生方法提供，需要自行使用<code>typeof o[Symbol.iterator] === 'function'</code>判断。</li>
</ul>
<p>对于迭代器，我们<strong>鼓励使用并代替原生<code>for</code>循环</strong>，且推荐关注以下原则：</p>
<ul>
<li>对于仅一个语句的循环操作，建议使用<code>forEach</code>方法，配合Arrow functions可非常简单地在一行写下循环逻辑。</li>
<li>对于多个语句的循环操作，建议使用<code>for..of</code>循环。</li>
<li>对于循环的场景，需要注意非数组但可迭代的对象，如<code>Map</code>和<code>Set</code>等，因此除<code>arguments</code>这类对象外，均建议直接判断是否可迭代，而不是<code>length</code>属性。</li>
</ul>
<h3 id="生成器">生成器</h3>
<p>生成器（Generators）也是一个比较复杂的功能，具体可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">MDN的文档</a>。</p>
<p>对于生成器，我的建议是<strong>非常谨慎地使用</strong>，理由如下：</p>
<ul>
<li>生成器不是用来写异步的，虽然他确实有这样一个效果，但这仅仅是一种Hack。异步在未来一定是属于<code>async</code>和<code>await</code>这两个关键字的，但太多人眼里生成器就是写异步用的，这会导致滥用。</li>
<li>生成器经过Babel转换后生成的代码较多，同时还需要<code>generatorsRuntime</code>库的支持，成本较高。</li>
<li>我们实际写应用的大部分场景下暂时用不到。</li>
</ul>
<p>生成器最典型的应用可以参考<a href="https://msdn.microsoft.com/en-us/library/bb397926.aspx" target="_blank" rel="external">C#的LINQ</a>获取一些经验，将对一个数组的多次操作合并为一个循环是其最大的贡献。</p>
<h3 id="模块和模块加载器">模块和模块加载器</h3>
<p>ES6终于在语言层面上定义了模块的语法，但这并不代表我们现在可以使用ES6的模块，因为实际在ES6定稿的时候，它把模块加载器的规范给移除了。因此我们现在有的仅仅是一个模块的<code>import</code>和<code>export</code>语法，但具体如“模块名如何对应到URL”、“如何异步/同步加载模块”、“如何按需加载模块”等这些均没有明确的定义。</p>
<p>因此，在模块这一块，我们的建议是<strong>使用标准语法书写模块，但使用AMD作为运行时模块解决方案</strong>，其特点有：</p>
<ul>
<li>保持使用<code>import</code>和<code>export</code>进行模块的引入和定义，可以安全地使用命名<code>export</code>和默认<code>export</code>。</li>
<li>在使用Babel转换时，配置<code>modules: 'amd'</code>转换为AMD的模块定义。</li>
<li>假定模块的URL解析是AMD的标准，<code>import</code>对应的模块名均以AMD标准书写。</li>
<li>不要依赖<code>SystemJS</code>这样的ES6模块加载器。</li>
</ul>
<p>这虽然很可能导致真正模块加载器规范定型后，我们的<code>import</code>模块路径是不规范的。但出于ES6的模块不配合HTTP/2简直没法完的考虑，AMD一定很长一段时间内持续存在，我们的应用基本上都是等不到HTTP/2实际可用的日子的，所以无需担心。</p>
<h2 id="类型增强类">类型增强类</h2>
<h3 id="unicode支持">Unicode支持</h3>
<p>这个东西基本没什么影响，我们很少遇到这些情况且已经习惯了这些情况，所以可以认为这个特性不存在而继续开发。</p>
<h3 id="map和set">Map和Set</h3>
<p>两个非常有用的类型，但对不少开发者来说，会困惑于其跟普通对象的区别，毕竟我们已经拿普通对象当<code>Map</code>和<code>Set</code>玩了这么多年了，也很少自己写一个类型出来。</p>
<p>对于此，我们的建议是：</p>
<ul>
<li>当你的元素或者键值有可能不是字符串时，无条件地使用<code>Map</code>和<code>Set</code>。</li>
<li>有移除操作的需求时，使用<code>Map</code>和<code>Set</code>。</li>
<li>当仅需要一个不可重复的集合时，使用<code>Set</code>优先于普通对象，而不要使用<code>{foo: true}</code>这样的对象。</li>
<li>当需要遍历功能时，使用<code>Map</code>和<code>Set</code>，因为其可以简单地使用<code>for..of</code>进行遍历。</li>
</ul>
<p>因此，事实上仅有一种情况我们会使用普通的对象，即使用普通对象来表达一个仅有增量<code>Map</code>，且这个<code>Map</code>的键值是字符串。</p>
<p>另外，<code>WeakMap</code>和<code>WeakSet</code>是没有办法模拟实现的，因此<strong>不要使用</strong>。</p>
<h3 id="proxy">Proxy</h3>
<p>这不是一个可以模拟实现的功能，没法用，因此<strong>不要使用Proxy</strong>。</p>
<h3 id="symbol">Symbol</h3>
<p><code>Symbol</code>最简单的解释是“可用于键值的对象”，最大的用处可能就是用来定义一些私有属性了。</p>
<p>我们建议<strong>谨慎使用<code>Symbol</code></strong>，如果你使用它来定义私有属性，那么请保持整个项目内是一致的，不要混用<code>Symbol</code>和闭包定义私有属性等手段。</p>
<h3 id="可继承的内置类型">可继承的内置类型</h3>
<p>按照ES6的规范，内置类型如<code>Array</code>、<code>Function</code>、<code>Date</code>等都是可以继承且没有什么坑的。但是我们的代码要跑在ES3-5的环境下，显然这一特性是不能享受的。</p>
<h3 id="promise">Promise</h3>
<p>这个真没什么好说的，即便不是ES6，我们也已经满地用着<code>Promise</code>了。</p>
<p>建议<strong>所有异步均使用Promise实现</strong>，以便在未来享受<code>async</code>和<code>await</code>关键字带来的便携性。</p>
<p>另外，虽然Babel可以转换<code>async</code>和<code>await</code>的代码，但<strong>不建议使用</strong>，因为转换出来的代码比较繁琐，且依赖于<code>generatorsRuntime</code>。</p>
<h3 id="各内置类型的方法增强">各内置类型的方法增强</h3>
<p>如<code>Array.from</code>、<code>String.prototype.repeat</code>等，这些方法都可以通过shim库支持，因此放心使用即可。</p>
<h3 id="二进制和八进制数字字面量">二进制和八进制数字字面量</h3>
<p>这个特性基本上是留给算法一族用的，因此我们的建议是<strong>除非数字本身在二/八进制下才有含义，否则不要使用</strong>。</p>
<h3 id="反射api">反射API</h3>
<p><code>Reflect</code>对象是ES6提供的反射对象，但其实没有什么方法是必要的。</p>
<p>其中的<code>delete(name)</code>和<code>has(name)</code>方法相当于<code>delete</code>和<code>in</code>运算符，而<code>defineProperty</code>等在<code>Object</code>上本身就有一套了，因此<strong>不建议使用该对象</strong>。</p>
<h3 id="尾递归">尾递归</h3>
<p>当作不存在就好了……</p>
";s:7:"summary";s:3496:"
    <p>ECMAScript6已经于近日进入了RC阶段，而早在其处于社区讨论时，我就开始一直在尝试使用ES6进行开发的方案。在<a href="https://babeljs.io">Babel</a>推出后，基于ES6的开发也有了具体可执行的解决方案，无论是Build还是Debug都能得到很好的支持。</p>
<p>而在有了充足的环境、工具之后，我们面临的是对ES6众多新特性的选择和分析，以便选取一个最佳的子集，让我们可以享受ES6带来的便利（减少代码量、提高可读性等）的同时，也可以顺利运行于当前以ES3-ES5为主的浏览器环境中。</p>
<p>经过分析后，本文试图对ES6各个特性得出是否适合应用的初步结论，并一一解释其使用场景。ES6的特性列表选自<a href="https://github.com/lukehoban/es6features">es6features</a>。</p>
<ul>
<li>★★★ 推荐使用</li>
<li>★★ 有考虑地使用</li>
<li>★ 慎重地使用</li>
<li>☆ 不使用</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">特性</th>
<th align="center">推荐程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">arrows</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">classes</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">enhanced object literals</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">template strings</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">destructuring</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">default + rest + spread</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">let + const</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">iterators + for..of</td>
<td align="center">★★</td>
</tr>
<tr class="odd">
<td align="left">generators</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">unicode</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">modules</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">module loaders</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">map + set + weakmap + weakset</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">proxies</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">symbols</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">subclassable built-ins</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">promises</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">math + number + string + array + object APIs</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">binary and octal literals</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">reflect api</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">tail calls</td>
<td align="center">★★</td>
</tr>
</tbody>
</table>
<p>接下来我们以上特性挨个进行介绍。需要关注一点：如果你不想使用shim库（如Babel的<code>browser-polyfill.js</code>和<code>generatorsRuntime.js</code>）或者想使用尽可能少的helper（Babel的<code>externalHelpers</code>配置），那么需要按你的需求进一步缩减可使用的ES6特性，如<code>Map</code>、<code>Set</code>这些就不应该使用。</p>
    
    ";}i:15;a:7:{s:5:"title";s:37:"使用FontEditor创建web字体图标";s:5:"link_";s:58:"http://efe.baidu.com/blog/use-fonteditor-to-build-webfont/";s:2:"id";s:58:"http://efe.baidu.com/blog/use-fonteditor-to-build-webfont/";s:9:"published";s:24:"2015-05-18T16:00:00.000Z";s:7:"updated";s:24:"2015-05-19T07:58:05.000Z";s:12:"atom_content";s:6697:"<p>关于web字体图标，市面上已经有一些好的在线工具来管理和生成，<code>iconfont</code>和<code>icomoon</code>都可以将svg图标转换成font图标以便在网页上使用。但是如果你想要更多：ttf、woff、eot、otf统统拿来用，svg、图片统统可导入，图标效果实时可调整，只需要在线动动鼠标，就可以完成呢。 那就需要一个好用的在线font编辑工具，<strong><a href="http://font.baidu.com/editor/" target="_blank" rel="external">FontEditor</a></strong>，你需要的东西都在这里。</p>
<a id="more"></a>
<h3 id="为什么会出现fonteditor">为什么会出现FontEditor</h3>
<blockquote>
<p>Everything Happens for a Reason</p>
</blockquote>
<p>FontEditor会出现只是因为我比较懒。如果我想用webfont做图标，又不想了解一大堆专业术语，又不想一次一次的导入和导出，又不想一次一次的调整fontsize以适应图标变化，又踏破铁鞋无觅处，那只能自己整一个了。FontEditor是一款<strong>纯前端</strong>字体编辑和管理软件，支持字体项目管理，支持导入ttf、woff、eot、otf格式字体，支持svg和图片导入，支持生成ttf、woff、eot、svg格式字体，支持批量调整字形和单个字形轮廓编辑，支持实时预览，支持实时同步字体到本地。</p>
<h3 id="如何使用svg制作webfont">如何使用svg制作webfont</h3>
<p>打开<code>chrome</code>浏览器，输入<a href="http://font.baidu.com/" class="uri" target="_blank" rel="external">http://font.baidu.com/</a>，创建名为<code>fonteditor</code>（看个人喜好）的项目，开始制作字体。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/new.png">
</div>
<p>在主菜单点击<code>导入-&gt;导入svg</code>按钮，打开文件选择框，拖选svg文件将svg图标导入到主面板；点击主面板<code>设置代码点</code>按钮，批量设置unicode代码点；点击主菜单<code>ttf</code>、<code>woff</code>、<code>zip</code>按钮，导出ttf、woff或其他格式字体；一个webfont制作完成，so easy。 保存项目，点击<code>预览</code>按钮查看图标预览，以及嵌入代码，如果你熟悉这一步，算我没说。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/import-svg.png">
</div>
<p>其他格式字形的导入，请参考FontEditor帮助文档，simple and stupid。</p>
<h3 id="如何调整字形">如何调整字形</h3>
<p>在主面板工具栏点击<code>调整位置</code>和<code>调整字形</code>按钮，对图标进行批量调整，也可以选中单个或多个字形进行单独调整。 这里需要普及一下相关知识： * <strong>左边轴</strong>：字形左边留白 * <strong>右边轴</strong>：字形右边留白，左右留白决定两个字形之间的间距 * <strong>基线</strong>：字体的baseline，对应于css中的<code>baseline</code> * <strong>上下边界</strong>：字体的ascent和descent，对应于css中的<code>text-top</code>和<code>text-bottom</code> * <strong>unicode代码点</strong>：Font Engine根据会代码点查找到相应的字形进行渲染，webfont可以使用私有区域 <code>0xE000</code>~<code>0XF8FF</code> 作为图标的代码点，详情：<a href="http://en.wikipedia.org/wiki/Unicode" target="_blank" rel="external">unicode</a></p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/glyf.png">
</div>
<h3 id="如何编辑单个字形">如何编辑单个字形</h3>
<p>对于webfont，使用FontEditor<strong>调整左右边轴为0，缩放字形到上下边界</strong>，即可满足大部分图标制作需求。如果需要精确调整字形，点击主面板字形上面的<code>铅笔</code>按钮可打开字形编辑面板，对单个字形进行调整： 拖选需要调整的轮廓，点击工具栏中的相关菜单可以对轮廓进行对齐、翻转、镜像、切割、求交、求并等操作，拖拽轮廓边界控制点调整轮廓大小。 双击单个轮廓进入轮廓点编辑模式，拖拽轮廓点改变字形，右键可增加、删除轮廓点，按<code>esc</code>退出轮廓点编辑。 点击工具栏中的<code>保存</code>按钮，保存当前轮廓。 按<code>F2</code>可以去切换<code>打开/关闭</code>字形编辑面板，也可以点击工具栏右侧的<code>退出</code>按钮退出字形编辑。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/adjust-contours.png">
</div>
<h3 id="如何同步字体到本地">如何同步字体到本地</h3>
<p>点击主面板工具栏<code>同步字体</code>按钮，设置同步选项。设置接收文件的服务地址，设置字体名称和需要同步的字体类型。在保存项目的时候FontEditor会发送数据到接收地址，然后就需要服务端接收字体数据。 关于如何保存FontEditor发送的字体，查看<a href="https://github.com/ecomfe/fonteditor/blob/master/demo/sync/font.php" target="_blank" rel="external">PHP版同步示例</a>。不会php？算我没说。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/sync.png">
</div>
<h3 id="脑补">脑补</h3>
<p>字体相关的文档和技术非常多，多到让人眼花缭乱无所适从，这里只列举了技术相关的文档，其他请自行补脑。</p>
<ul>
<li><a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM02/Chap2.html" target="_blank" rel="external">The Font Engine</a> 字体引擎工作原理</li>
<li><a href="http://www.microsoft.com/typography/otspec/" target="_blank" rel="external">OpenType specification</a> OpenType官方文档</li>
<li><a href="http://www.w3.org/TR/2012/REC-WOFF-20121213/" target="_blank" rel="external">WOFF Font</a> WOFF字体格式</li>
<li><a href="http://www.w3.org/TR/SVG11/fonts.html" target="_blank" rel="external">SVG Font</a> SVG字体格式</li>
</ul>
<p>想贡献代码？移步这里： <iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&repo=fonteditor&type=fork&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe> 只想点个赞，在这： <iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&repo=fonteditor&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe></p>
<h3 id="相关项目">相关项目</h3>
<ul>
<li><a href="https://github.com/ecomfe/fontmin" target="_blank" rel="external">fontmin</a> 第一个纯 JS 字体解决方案</li>
<li><a href="https://github.com/kekee000/fonteditor-ttf" target="_blank" rel="external">fonteditor-ttf</a> FontEditor的nodejs版本基础库</li>
</ul>
";s:7:"summary";s:561:"
    <p>关于web字体图标，市面上已经有一些好的在线工具来管理和生成，<code>iconfont</code>和<code>icomoon</code>都可以将svg图标转换成font图标以便在网页上使用。但是如果你想要更多：ttf、woff、eot、otf统统拿来用，svg、图片统统可导入，图标效果实时可调整，只需要在线动动鼠标，就可以完成呢。 那就需要一个好用的在线font编辑工具，<strong><a href="http://font.baidu.com/editor/">FontEditor</a></strong>，你需要的东西都在这里。</p>
    
    ";}i:16;a:7:{s:5:"title";s:22:"VIM的JavaScript补全";s:5:"link_";s:52:"http://efe.baidu.com/blog/vim-javascript-completion/";s:2:"id";s:52:"http://efe.baidu.com/blog/vim-javascript-completion/";s:9:"published";s:24:"2015-05-04T16:00:00.000Z";s:7:"updated";s:24:"2015-05-05T00:36:16.000Z";s:12:"atom_content";s:10094:"<p>最近微软出了个Visual Studio Code，听说很diao，尤其是对JavaScript的补全支持很令人惊艳！</p>
<p>如果你是一个vim党，那么请淡定！</p>
<p>在JavaScript开发过程中，使用vim内置的<code>ins-completion</code>再加上一些插件，我们同样可以获得很牛逼的completion支持！</p>
<a id="more"></a>
<h2 id="ins-completion">ins-completion</h2>
<p>vim其实已经提供了很好的代码补全支持。</p>
<h3 id="整行">整行</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-L&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-l.gif">
</div>
<h3 id="文件名">文件名</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-F&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-f.gif">
</div>
<h3 id="当前文件中的关键字">当前文件中的关键字</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-P&gt;</code>或<code>&lt;C-X&gt;&lt;C-N&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-pn.gif">
</div>
<h3 id="complete选项所指定的范围中的关键字"><code>complete</code>选项所指定的范围中的关键字</h3>
<p>快捷键：<code>&lt;C-N&gt;</code>或<code>&lt;C-P&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-pn.gif">
</div>
<p><code>&lt;C-N&gt;</code>、<code>&lt;C-P&gt;</code>跟<code>&lt;C-X&gt;&lt;C-N&gt;</code>、<code>&lt;C-X&gt;&lt;C-P&gt;</code>类似，但是查找范围更广，不局限于当前文件。</p>
<p>如上图所示，我打开两个文件，在<code>src/echarts.js</code>中补全<code>src/component.js</code>中的关键字，就可以使用<code>&lt;C-N&gt;</code>或<code>&lt;C-P&gt;</code>。</p>
<p>具体查找范围由<code>complete</code>选项所规定，详见<code>:help E535</code>。</p>
<h3 id="dictionary中的关键字"><code>dictionary</code>中的关键字</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-K&gt;</code></p>
<p>假设你有一个<code>javascript.dict</code>文件，其内容如下： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise&#10;Proxy&#10;let&#10;class&#10;extends</span><br></pre></td></tr></table></figure></p>
<p>设置<code>:set dictionary+=/path/to/es6.dict</code>之后就可以用<code>&lt;C-X&gt;&lt;C-K&gt;</code>来补全这些关键字了。</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-k.gif">
</div>
<h3 id="omni-completion">omni completion</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-O&gt;</code></p>
<p>这个是基于语义上的补全，vim会猜测光标之前的关键词，然后给出补全。</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-o.gif">
</div>
<p>更多补全方式，请看<code>:help ins-completion</code>。</p>
<h2 id="youcompleteme">YouCompleteMe</h2>
<p>按键太多了，真不开心…</p>
<p>先上一个自动打开候选菜单的插件，再继续吹牛逼吧…</p>
<p>YouCompleteMe是一个不错的选择，补全速度比neocomplete快。</p>
<p>基本配置如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let g:ycm_min_num_of_chars_for_completion = 3 </span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=1</span><br><span class="line">let g:ycm_complete_in_comments = 1</span><br><span class="line">let g:ycm_key_list_select_completion = ['&lt;c-n&gt;', '&lt;Down&gt;']</span><br><span class="line">let g:ycm_key_list_previous_completion = ['&lt;c-p&gt;', '&lt;Up&gt;']</span><br><span class="line">" 比较喜欢用tab来选择补全...</span><br><span class="line">function! MyTabFunction ()</span><br><span class="line">    let line = getline('.')</span><br><span class="line">    let substr = strpart(line, -1, col('.')+1)</span><br><span class="line">    let substr = matchstr(substr, "[^ \t]*$")</span><br><span class="line">    if strlen(substr) == 0</span><br><span class="line">        return "\&lt;tab&gt;"</span><br><span class="line">    endif</span><br><span class="line">    return pumvisible() ? "\&lt;c-n&gt;" : "\&lt;c-x&gt;\&lt;c-o&gt;"</span><br><span class="line">endfunction</span><br><span class="line">inoremap &lt;tab&gt; &lt;c-r&gt;=MyTabFunction()&lt;cr&gt;</span><br></pre></td></tr></table></figure>
<p>现在，对于关键字补全、路径补全、<code>omni completion</code>，YouCompleteMe可以自动打开补全菜单了。</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/ycm.gif">
</div>
<p>恩，看起来<code>ins-completion</code>还不错，但是跟vscode比起来还不够！</p>
<p>vim的<code>omni completion</code>实际上可以支持更牛逼的completion，于是有了<a href="http://ternjs.net" target="_blank" rel="external">tern</a>。</p>
<h2 id="tern_for_vim">tern_for_vim</h2>
<p><code>tern_for_vim</code>是ternjs给vim量身定做的插件，它实际上是给javascript实现了一个新的<code>omnifunc</code>，叫做<code>tern#Complete</code>。</p>
<p>当我们按下<code>&lt;C-X&gt;&lt;C-O&gt;</code>时，vim实际上就是调用<code>omnifunc</code>。</p>
<p><code>tern_for_vim</code>改写了<code>omnifunc</code>，接管了vim的<code>omni completion</code>。</p>
<p>vim安装了<code>tern_for_vim</code>之后，在项目的根目录中新建一个配置文件<code>.tern-project</code>，以echarts为例，配置如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">libs</span>": <span class="value">[</span><br><span class="line">        <span class="string">"browser"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">plugins</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">requirejs</span>": <span class="value">&#123;</span><br><span class="line">            "<span class="attribute">baseUrl</span>": <span class="value"><span class="string">"./src"</span></span>,</span><br><span class="line">            "<span class="attribute">paths</span>": <span class="value">&#123;</span><br><span class="line">                "<span class="attribute">zrender</span>": <span class="value"><span class="string">"bower_components/zrender/src"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">        </span>&#125;</span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>libs</code>字段指明要导入哪些库，tern内置了以下几种库：</p>
<ul>
<li>browser</li>
<li>chai</li>
<li>ecma5，默认自动导入</li>
<li>ecma6</li>
<li>jquery</li>
<li>underscore</li>
</ul>
<p>我们现在只配置了browser，看看会发生什么事情？</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-browser.gif">
</div>
<p>如果你的项目还用到了jquery，那么你可以把jquery加到<code>.tern-project</code>的libs字段中，效果如下：</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-jquery.gif">
</div>
<p><code>plugins</code>更猛，可以补全模块化的代码，tern支持以下几种插件：</p>
<ul>
<li>angular.js</li>
<li>complete_string.js</li>
<li>component.js</li>
<li>doc_comment.js，默认自动启用</li>
<li>nodejs</li>
<li>requirejs</li>
</ul>
<p>看看echarts项目配置了requirejs插件之后会怎么样？</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-requirejs.gif">
</div>
<p>碉堡了，有木有！</p>
<p>我们再也不用担心某个模块到底提供了哪些方法，require它，输入点号，然后提示，你所要做的就是选择！</p>
<p>如果第三方库在代码中提供足够的文档注释，我们甚至都不需要再去查文档了！</p>
<p>哦，稍等，听说vscode还支持nodejs的补全。</p>
<p>在nodejs项目下配置一下<code>.tern-project</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">libs</span>": <span class="value">[]</span>,</span><br><span class="line">    "<span class="attribute">plugins</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">node</span>": <span class="value">&#123;&#125;</span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>看看tern对nodejs项目的支持如何？</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-node.gif">
</div>
<p>嗯，貌似还可以！</p>
<h2 id="小结">小结</h2>
<p>如果你是一个vim粉丝，那希望本文对你有所帮助！</p>
";s:7:"summary";s:351:"
    <p>最近微软出了个Visual Studio Code，听说很diao，尤其是对JavaScript的补全支持很令人惊艳！</p>
<p>如果你是一个vim党，那么请淡定！</p>
<p>在JavaScript开发过程中，使用vim内置的<code>ins-completion</code>再加上一些插件，我们同样可以获得很牛逼的completion支持！</p>
    
    ";}i:17;a:7:{s:5:"title";s:20:"ECharts 发布 2.2.2";s:5:"link_";s:40:"http://efe.baidu.com/blog/echarts-2.2.2/";s:2:"id";s:40:"http://efe.baidu.com/blog/echarts-2.2.2/";s:9:"published";s:24:"2015-04-29T16:00:00.000Z";s:7:"updated";s:24:"2015-04-30T03:22:04.000Z";s:12:"atom_content";s:2762:"<p>在五一劳动节的前一天，ECharts发布了一个非常2的版本，2.2.2。在本版本中，我们一共做了以下重大升级：</p>
<ul>
<li>新增韦恩图(venn)及Treemap</li>
<li>发布 ECharts 在线构建工具</li>
<li>新增对数轴</li>
</ul>
<p>并且修复了一些反馈较多、优先级较高的问题：</p>
<ul>
<li>增加了大规模折线图添加数据抽希策略配置。<a href="https://github.com/ecomfe/echarts/issues/1370" target="_blank" rel="external">解决原有抽希策略导致的数据精度缺失问题</a></li>
<li>symbolSize 支持通过数组分别设置宽高</li>
<li>修复 <a href="https://github.com/ecomfe/echarts/issues/1308" target="_blank" rel="external">mac safari饼图性能问题</a></li>
<li>支持 z, zlevel 的配置</li>
</ul>
<a id="more"></a>
<h2 id="韦恩图">韦恩图</h2>
<p>韦恩图（维恩图），也叫文氏图，用于显示元素集合重叠区域的图示。诞生于1880年，韦恩（Venn）在《论命题和推理的图表化和机械化表现》一文中首次采用固定位置的交叉环形式用封闭曲线（内部区域）表示集合及其关系的图形。</p>
<div class="figure">
<img src="/blog/echarts-2.2.2/venn.jpg" alt="韦恩图"><p class="caption">韦恩图</p>
</div>
<p>可以通过访问ECharts官网的<a href="http://echarts.baidu.com/doc/example/venn.html" target="_blank" rel="external">示例</a>了解如何使用ECharts制作韦恩图</p>
<h2 id="treemap">Treemap</h2>
<p>这是一个中文名很长的图表类型，比如叫做：矩形式树状结构绘图法，或矩形式树状结构图绘制法，或者树状结构矩形图绘制法，或者甚至称为树状结构映射。其实指的是一种利用嵌套式矩形来显示树状结构数据的方法。</p>
<div class="figure">
<img src="/blog/echarts-2.2.2/treemap.jpg" alt="Treemap"><p class="caption">Treemap</p>
</div>
<p>可以通过访问ECharts官网的<a href="http://echarts.baidu.com/doc/example/treemap.html" target="_blank" rel="external">示例</a>了解如何使用ECharts制作Treemap。</p>
<h2 id="echarts在线发布工具">ECharts在线发布工具</h2>
<p>我们提供了最新的ECharts在线发布工具，方便用户可以自由的选择，仅仅打包你在项目中使用到的图表及组件代码。减少整体需要加载的ECharts文件大小，提高您产品的网络加载速度及用户体验。</p>
<p>入口最ECharts官网主导航的下载栏目中，或者直接访问 <a href="http://ecomfe.github.io/echarts-builder-web/" class="uri" target="_blank" rel="external">http://ecomfe.github.io/echarts-builder-web/</a></p>
<div class="figure">
<img src="/blog/echarts-2.2.2/pub.jpg" alt="发布工具"><p class="caption">发布工具</p>
</div>
";s:7:"summary";s:748:"
    <p>在五一劳动节的前一天，ECharts发布了一个非常2的版本，2.2.2。在本版本中，我们一共做了以下重大升级：</p>
<ul>
<li>新增韦恩图(venn)及Treemap</li>
<li>发布 ECharts 在线构建工具</li>
<li>新增对数轴</li>
</ul>
<p>并且修复了一些反馈较多、优先级较高的问题：</p>
<ul>
<li>增加了大规模折线图添加数据抽希策略配置。<a href="https://github.com/ecomfe/echarts/issues/1370">解决原有抽希策略导致的数据精度缺失问题</a></li>
<li>symbolSize 支持通过数组分别设置宽高</li>
<li>修复 <a href="https://github.com/ecomfe/echarts/issues/1308">mac safari饼图性能问题</a></li>
<li>支持 z, zlevel 的配置</li>
</ul>
    
    ";}i:18;a:7:{s:5:"title";s:66:"当我们谈论颜色时，我们在谈论什么 - 基础知识篇";s:5:"link_";s:76:"http://efe.baidu.com/blog/what-we-talk-about-when-we-talk-about-color-basic/";s:2:"id";s:76:"http://efe.baidu.com/blog/what-we-talk-about-when-we-talk-about-color-basic/";s:9:"published";s:24:"2015-04-28T16:00:00.000Z";s:7:"updated";s:24:"2015-04-29T04:28:24.000Z";s:12:"atom_content";s:11167:"<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/cover.png">
</div>
<p>谈到 <strong>颜色</strong>，前端工程师首先想起的便是基于 RGB 的 16 进制颜色代码，这也是我们工作中最常用到的 <strong>数值表示</strong> 方式。但是当我们的谈话再深入一些，话题远不止这些：</p>
<blockquote>
<p>前端：「我在 hackathon 时做了个网站，配色怎么看都丑，你帮我看看？」<br>设计：「这俩颜色不搭，光晕现象都出来了，还有把这里的饱和度调低一点，亮度调高一点。」<br>前端：「……」（你™在说什么！）</p>
</blockquote>
<p>这时你应该去向设计小伙伴要最熟悉的 16 进制颜色代码了，但被抱怨缺乏 <strong>设计感</strong> 的挫折还是有一点的。</p>
<p>想要和小伙伴愉快的交流下去，我们要了解颜色的「基础知识」，还要对「色彩空间」、「颜色搭配」、「颜色与情感」等各个方面都有些了解。<del>作为一个边看书边查百科的伪设计师，</del> 我想通过这个系列与大家一起从 <strong>颜色</strong> 开始，培养点 <strong>设计感</strong>。</p>
<p>本篇我们一起复习一下基础知识。</p>
<a id="more"></a>
<h2 id="原理">原理</h2>
<p>我们在中学的 <strong>物理</strong> 课上学过，颜色本质上是特定范围的 <a href="http://zh.wikipedia.org/wiki/电磁波" target="_blank" rel="external">电磁波</a>（如下图<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>）。</p>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/spectrum.png" alt="我们看到的色彩，是电磁波谱的一小部分"><p class="caption">我们看到的色彩，是电磁波谱的一小部分</p>
</div>
<p>但从 <strong>生理</strong> 来看，人们能看到颜色，是因为人类每只眼球视网膜大约有 600-700 万的 <a href="http://en.wikipedia.org/wiki/Cone_cell" target="_blank" rel="external">视锥细胞</a>，他们是处理可见光谱颜色的 <strong>感光器</strong><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>。 人类的视锥细胞有三种，分别是 <strong>短波（S 或蓝色）视锥细胞</strong>、<strong>中波（M 或绿色）视锥细胞</strong>、<strong>长波（L 或红色）视锥细胞</strong>；这些视锥细胞响应的组合，让我们能够分辨出大约一千万种颜色。</p>
<h2 id="无障碍">无障碍</h2>
<p>我们能够看到色彩，是我们的 <em>身体硬件</em> 附带了相应功能的 <em>传感器</em>。其他生物与我们的 <em>硬件构造</em> 不同，看到的世界也是不同的，比如：大多数哺乳动物只有两种感光器，许多鸟类与有袋动物有四种感光器。</p>
<p>人类对颜色的感受也存在 <strong>较大</strong> 的 <strong>个体差异</strong>，根据网上的公开数据，色盲和色弱在人群中占有很大比率：</p>
<blockquote>
<p>红绿色盲人口占全球男性人口约 8%，女性人口约 0.5%，他们能看到多种颜色，但是会混淆识别某些颜色，尤其是红色与绿色。 另外全球约6%人口为三色视觉(色弱)，约 2% 人口为二色视觉(色盲)，极少数为单色视觉(全色盲)。</p>
<p>–维基百科<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
</blockquote>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/colorblind.png" alt="红、绿、蓝、黑 在人们眼中的样子"><p class="caption">红、绿、蓝、黑 在人们眼中的样子</p>
</div>
<p>所以我们在做 <strong>无障碍</strong> 产品的时候请将 <strong>色彩</strong> 的 <strong>可用性</strong> 也纳入考虑范围（比如数据可视化的色彩搭配）。<br>这里推荐一个叫做 <a href="https://chrome.google.com/webstore/detail/colorblinding/dgbgleaofjainknadoffbjkclicbbgaa" target="_blank" rel="external">Colorblinding</a> 的 Chrome 插件，你可以看看自己的作品，在 <strong>8%+ 的用户</strong> 眼中是什么样子的。</p>
<h2 id="原色">原色</h2>
<p>我们知道，<strong>原色</strong> 是指不能透过其他颜色的混合调配而得出的 <strong>基本色</strong>。<br><strong>原色</strong> 是个生物学的概念，所以我们看到 <strong>三原色</strong> 与我们三种类型的视锥细胞是基本吻合的。</p>
<p>有的同学会有疑惑，我小学美术老师教的三原色是 <strong>红</strong>、<strong>黄</strong>、<strong>蓝</strong> 又是怎么回事儿呢？<br>这得从 <strong>反射色</strong> 与 <strong>透过色</strong> 之间，不同的混色原理说起。</p>
<hr>
<p>以 <strong>反射光源</strong> 或 <strong>颜料着色</strong> 时使用的色彩，属于 <strong>消减型</strong> 的原色系统。</p>
<p>我们身边的物体大多数都无法自行发光，必须借助光源的 <strong>反射</strong> 才能被看见。 当光源照射物体时，对物体而言，可分为被吸收的波长与反射的波长，反射后的波长即是我们所看到的颜色。</p>
<p>CMYK（印刷四分色模式）是彩色印刷时采用的一种套色模式，它利用色料的 <strong>减色混合法</strong> 原理，加上黑色油墨<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>，共计四种颜色叠加，形成所谓 <strong>全彩印刷</strong>。 四种标准颜色是 <strong>青色（Cyan）</strong>、<strong>品红色（Magenta）</strong>、<strong>黄色（Yellow）</strong> 和 <strong>黑色（blacK）</strong>。</p>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/subtractive-primaries.png" alt="消减型原色系统"><p class="caption">消减型原色系统</p>
</div>
<p>对前端来说，我们的主要产出是用各种屏幕来展示的，CYMK 和我们关系不大，就不展开了。</p>
<hr>
<p>以 <strong>光源投射</strong> 时使用的色彩，属于 <strong>叠加型</strong> 的原色系统。</p>
<p>此系统中包含了 <strong>红</strong>、<strong>绿</strong>、<strong>蓝</strong> 三种原色，使用这三种原色可以产生其他颜色，例如红色与绿色混合可以产生黄色或橙色，绿色与蓝色混合可以产生青色，蓝色与红色混合可以产生紫色或品红色。 当这三种原色以等比例叠加在一起时，会变成灰色；若将此三原色的强度均调至最大并且等量重叠时，则会呈现白色。这套原色系统常被称为「RGB 色彩空间」。<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/additive-primaries.png" alt="叠加型原色系统"><p class="caption">叠加型原色系统</p>
</div>
<p>电视、显示器、手机屏幕都是基于 <strong>RGB 色彩模型</strong> 来运转的，所以我们用 <code>RGB</code> 来表述颜色是最贴近硬件的方式。</p>
<p>很显然，作为前端的你已经非常熟悉 RGB 了。<br>你经常通过调整 <code>#RRGGBB</code> 中代表 红、绿、蓝 的值，调整设计细节；<br>你看到一个颜色的 HEX 代码就能够想象出它偏向哪种色彩，颜色是深是浅。<br>所以我也没必要再啰嗦一遍，耽误你们的时间。</p>
<h2 id="这些我都知道了然后呢">这些我都知道了，然后呢？</h2>
<p>用 <strong>RGB 色彩空间</strong> 调整颜色是让你 <strong>像显示器一样思考</strong>，或者 <strong>不思考</strong> 直接拿来用。</p>
<p>但我们设计时需要的是符合 <strong>语义</strong> 的、像人类一样思考的 <strong>色彩空间</strong>，比如：</p>
<ul>
<li>孟塞尔色彩空间 (HVC)：拥有一百多年历史，至今仍被广泛使用的系统</li>
<li>HSB (HSV)：各种图形应用程序中最常用的色彩空间</li>
<li>HSL：从 <a href="http://www.w3.org/TR/css3-color/#hsl-color" target="_blank" rel="external">CSS Color Module Level 3</a> 起支持的色彩空间</li>
<li>HWB：在 <a href="http://dev.w3.org/csswg/css-color/#the-hwb-notation" target="_blank" rel="external">CSS Color Module Level 4</a> 中将要支持的色彩空间</li>
<li>HuSL 与 HuSLp：改进了 HSL 的缺陷，用户友好的色彩空间</li>
</ul>
<p>上面这些内容我会在 <del>作者不忙的时候再写</del> 的本系列下一篇「色彩空间」中向大家介绍，本篇就到这里 <del>，因为听说博客太长没人看</del>。</p>
<p>最后，推荐一下 <a href="http://weibo.com/justineo" target="_blank" rel="external">Justineo</a> 同学写的颜色操作库 <a href="http://justineo.github.io/kolor/" target="_blank" rel="external">Kolor</a>，据说读懂源码看 <strong>下一篇</strong> 就会很轻松，路过就顺手给个 <strong>star</strong> 呗：</p>
<iframe src="https://ghbtns.com/github-btn.html?user=Justineo&amp;repo=kolor&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
<h2 id="书目">书目</h2>
<p>以下是本系列博客的主要参考的书目，以及我根据 <strong>主观印象</strong> 给的评分，供参考。</p>
<ul>
<li><a href="http://dwz.cn/hacker-design" target="_blank" rel="external">黑客与设计：剖析设计之美的秘密</a>，评分：★★★★★，作者：[美] David Kadavy，ISBN：9787115345370</li>
<li><a href="http://dwz.cn/color-design" target="_blank" rel="external">色彩设计的原理</a>，评分：★★★★★，作者：[日] 伊达千代，ISBN：9787508629902</li>
<li><a href="http://dwz.cn/interaction-of-color" target="_blank" rel="external">色彩构成</a>，评分：★★★★☆，作者：[美] Josef Albers，ISBN：9787562463450</li>
<li><a href="http://dwz.cn/color-schemes" target="_blank" rel="external">配色设计原理</a>，评分：★★★☆☆，作者：[日] 奥博斯科编辑部，ISBN：9787500690351</li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>可见光谱在电磁波中的范围，原作者：<a href="http://en.wikipedia.org/wiki/File:EM_spectrum.svg" target="_blank" rel="external">Philip Ronan</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>视细胞中还有一种 <a href="http://en.wikipedia.org/wiki/Rod_cell" target="_blank" rel="external">视杆细胞</a>，他们在黑暗条件下比较敏感，但几乎不参与对颜色的处理。<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>来自维基百科「色盲」词条：<a href="http://zh.wikipedia.org/wiki/色盲" class="uri" target="_blank" rel="external">http://zh.wikipedia.org/wiki/色盲</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>理论上只用上述三种颜色能够混合成黑色，但实际印刷时三种颜色的相加只能形成一种深灰色或深褐色。<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>来自维基百科「原色」词条：<a href="http://zh.wikipedia.org/wiki/原色" class="uri" target="_blank" rel="external">http://zh.wikipedia.org/wiki/原色</a><a href="#fnref5">↩</a></p></li>
</ol>
</div>
";s:7:"summary";s:1293:"
    <div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/cover.png" />
</div>
<p>谈到 <strong>颜色</strong>，前端工程师首先想起的便是基于 RGB 的 16 进制颜色代码，这也是我们工作中最常用到的 <strong>数值表示</strong> 方式。但是当我们的谈话再深入一些，话题远不止这些：</p>
<blockquote>
<p>前端：「我在 hackathon 时做了个网站，配色怎么看都丑，你帮我看看？」<br />设计：「这俩颜色不搭，光晕现象都出来了，还有把这里的饱和度调低一点，亮度调高一点。」<br />前端：「……」（你™在说什么！）</p>
</blockquote>
<p>这时你应该去向设计小伙伴要最熟悉的 16 进制颜色代码了，但被抱怨缺乏 <strong>设计感</strong> 的挫折还是有一点的。</p>
<p>想要和小伙伴愉快的交流下去，我们要了解颜色的「基础知识」，还要对「色彩空间」、「颜色搭配」、「颜色与情感」等各个方面都有些了解。<del>作为一个边看书边查百科的伪设计师，</del> 我想通过这个系列与大家一起从 <strong>颜色</strong> 开始，培养点 <strong>设计感</strong>。</p>
<p>本篇我们一起复习一下基础知识。</p>
    
    ";}i:19;a:7:{s:5:"title";s:20:"Fontmin 快速指南";s:5:"link_";s:50:"http://efe.baidu.com/blog/fontmin-getting-started/";s:2:"id";s:50:"http://efe.baidu.com/blog/fontmin-getting-started/";s:9:"published";s:24:"2015-04-16T16:00:00.000Z";s:7:"updated";s:24:"2015-04-17T04:57:41.000Z";s:12:"atom_content";s:12932:"<p><a href="http://ecomfe.github.io/fontmin/" target="_blank" rel="external">Fontmin</a> 是一个纯 JavaScript 实现的字体子集化方案。</p>
<p>提供了 <code>ttf</code> 子集化，<code>eot/woff/svg</code> 格式转换，<code>css</code> 生成 等功能，助推 webfont 发展，提升网页文字体验。</p>
<p data-height="350" data-theme-id="0" data-slug-hash="raEXBX" data-default-tab="result" data-user="firede" class="codepen">
See the Pen <a href="http://codepen.io/firede/pen/raEXBX/" target="_blank" rel="external">Fontmin Example</a> by Firede (<a href="http://codepen.io/firede" target="_blank" rel="external"><span class="citation">@firede</span></a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.
</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
<a id="more"></a>
<h2 id="why-fontmin">Why Fontmin</h2>
<p>浏览器的季风已撩拨起 webfont 的热浪，中文字体却依旧寂寞如雪。</p>
<p>与西文字体不同，由于字符集过大，中文字体无法享受 webfont 带来的便利。</p>
<p>为了让中文字体也乘上这道风，我们需要对其进行 <code>min</code>:</p>
<ul>
<li>子集化：提取字体中的部分字型，最小化打包字体</li>
<li>webfont 格式化：利用 <code>@font-face</code>，把自定义字体嵌入到网页中，支持 <code>ttf</code>、<code>woff</code>、<code>eot</code>、<code>svg</code> 等格式</li>
</ul>
<p>已有工具 <a href="https://code.google.com/p/sfntly/" target="_blank" rel="external">sfnttool.jar</a> (Java)，<a href="https://github.com/fontforge/fontforge" target="_blank" rel="external">Fontforge</a> (Python)，<a href="https://bitbucket.org/philip/font-optimizer/src/" target="_blank" rel="external">Font Optimizer</a> (Perl)，为什么还要造轮子呢?</p>
<blockquote>
<p>Any application that can be written in JavaScript, will eventually be written in JavaScript. – Jeff Atwood</p>
</blockquote>
<p>噗，开个玩笑。靠谱的说，是这样的：</p>
<ul>
<li>专注，面向前端工程师，专注字体的 web 应用</li>
<li>工程化，自动化开发流程，告别刀耕火种的人肉操作</li>
<li>社区，依靠社区的力量，可以有更多的玩法，如：<a href="http://efe.baidu.com/blog/chinese-font-build/" target="_blank" rel="external">edp-build-fontmin</a>, <a href="https://github.com/ecomfe/gulp-fontmin" target="_blank" rel="external">gulp-fontmin</a>, <a href="https://github.com/aui/font-spider" target="_blank" rel="external">font-spider</a></li>
</ul>
<p>以上，<a href="http://ecomfe.github.io/fontmin/" target="_blank" rel="external">Fontmin</a> 提供了多种方式，带你玩转字体。</p>
<h2 id="node-模块">node 模块</h2>
<p>npm 模块 <a href="https://www.npmjs.com/package/fontmin" target="_blank" rel="external">fontmin</a>，基于 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">stream</a> 处理字体文件，简单高效，方便扩展。可以与 <a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">gulp</a> 插件 自由搭配。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fontmin = <span class="keyword">require</span>(<span class="string">'fontmin'</span>);</span><br><span class="line"><span class="keyword">var</span> rename = <span class="keyword">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="keyword">new</span> Fontmin()</span><br><span class="line">    .src(<span class="string">'fonts/big.ttf'</span>)</span><br><span class="line">    .<span class="keyword">use</span>(rename(<span class="string">'small.ttf'</span>));</span><br></pre></td></tr></table></figure>
<p>提供细粒度 <a href="https://github.com/ecomfe/fontmin#plugins" target="_blank" rel="external">plugins</a>，你可以自由定制专属的 webfont 压缩方案，比如：把字体转为 base64 嵌入到 css 中：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fontmin = <span class="keyword">require</span>(<span class="string">'fontmin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="keyword">new</span> Fontmin()</span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.css(&#123;</span><br><span class="line">        base64: <span class="keyword">true</span>		<span class="comment">// 开启 base64 嵌入，默认关闭</span></span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>输出 css：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"eduSong"</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="function">url</span>(<span class="string">"eduSong.eot"</span>); <span class="comment">/* IE9 */</span></span><br><span class="line">    <span class="attribute">src</span>: <span class="function">url</span>(<span class="string">"eduSong.eot?#iefix"</span>) <span class="function">format</span>(<span class="string">"embedded-opentype"</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">    <span class="function">url</span>(<span class="string">data:application/x-font-ttf;charset=utf-8;base64,AAEAAAAKAIAAAwA....</span>) <span class="function">format</span>(<span class="string">"truetype"</span>), <span class="comment">/* chrome、firefox、opera、Safari, Android，iOS 4.2+ */</span></span><br><span class="line">    <span class="function">url</span>(<span class="string">"eduSong.svg#eduSong"</span>) <span class="function">format</span>(<span class="string">"svg"</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为方便大家使用，提供一个最基本的 webfont 工作流 snippet：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fontmin = <span class="keyword">require</span>(<span class="string">'fontmin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> srcPath = <span class="string">'src/font/*.ttf'</span>; <span class="comment">// 字体源文件</span></span><br><span class="line"><span class="keyword">var</span> destPath = <span class="string">'asset/font'</span>;    <span class="comment">// 输出路径</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'我说你是人间的四月天；笑响点亮了四面风；轻灵在春的光艳中交舞着变。'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="keyword">new</span> Fontmin()</span><br><span class="line">    .src(srcPath)               <span class="comment">// 输入配置</span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.glyph(&#123;        <span class="comment">// 字型提取插件</span></span><br><span class="line">        text: text              <span class="comment">// 所需文字</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.ttf2eot())     <span class="comment">// eot 转换插件</span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.ttf2woff())    <span class="comment">// woff 转换插件     </span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.ttf2svg())     <span class="comment">// svg 转换插件</span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.css())         <span class="comment">// css 生成插件</span></span><br><span class="line">    .dest(destPath);            <span class="comment">// 输出配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">fontmin.run(<span class="function"><span class="keyword">function</span> <span class="params">(err, files, stream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;                  <span class="comment">// 异常捕捉</span></span><br><span class="line">        console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(<span class="string">'done'</span>);        <span class="comment">// 成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>大家可以这个基础上，自由扩展，玩法多多。</p>
<h2 id="命令行">命令行</h2>
<p>极客范儿? 就是喜欢弹奏键盘这种飘逸的感觉～</p>
<p>全局安装 fontmin</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g fontmin</span><br></pre></td></tr></table></figure>
<div class="figure">
<img src="/blog/fontmin-getting-started/img/terminal.png">
</div>
<h2 id="客户端">客户端</h2>
<p>懒得写代码? 直接把 <code>TTF</code> 拖进来，左侧输入需要文字，右侧实时看效果。点击生成，duang 一下，就搞定了~</p>
<div class="figure">
<img src="/blog/fontmin-getting-started/img/app.png">
</div>
<p>可以在 <a href="https://github.com/ecomfe/fontmin-app/releases" target="_blank" rel="external">这里</a> 找到最新版本。</p>
<h2 id="eof">EOF</h2>
<ul>
<li>本文封面：<a href="http://codepen.io/firede/pen/raEXBX" target="_blank" rel="external">Fontmin Example</a> by <span class="citation">[@Firede]</span>(http://weibo.com/firede)，<a href="http://codepen.io/lbebber/pen/dalKF" target="_blank" rel="external">Kinda Realistic Text</a> by <span class="citation">[@lucasbebber]</span>(https://twitter.com/lucasbebber)</li>
<li>字体支持：<a href="http://www.sentyfont.com/" target="_blank" rel="external">新蒂字体</a>，<a href="http://weibo.com/eonway" target="_blank" rel="external">浙江民间书刻体</a>，<a href="https://github.com/adobe-fonts/source-han-sans" target="_blank" rel="external">思源字体</a>，<a href="http://www.edu.tw/pages/detail.aspx?Node=3691&amp;Page=17009&amp;Index=6" target="_blank" rel="external">台湾教育部標準宋體</a></li>
</ul>
<p>如果您觉得 Fontmin 还不错，请给个 star 呗 ヾ(◍°∇°◍)ﾉﾞ</p>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=fontmin&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
";s:7:"summary";s:720:"
    <p><a href="http://ecomfe.github.io/fontmin/">Fontmin</a> 是一个纯 JavaScript 实现的字体子集化方案。</p>
<p>提供了 <code>ttf</code> 子集化，<code>eot/woff/svg</code> 格式转换，<code>css</code> 生成 等功能，助推 webfont 发展，提升网页文字体验。</p>
<p data-height="350" data-theme-id="0" data-slug-hash="raEXBX" data-default-tab="result" data-user="firede" class="codepen">
See the Pen <a href='http://codepen.io/firede/pen/raEXBX/'>Fontmin Example</a> by Firede (<a href='http://codepen.io/firede'><span class="citation">@firede</span></a>) on <a href='http://codepen.io'>CodePen</a>.
</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
    
    ";}}s:7:"channel";a:9:{s:5:"title";s:8:"EFE Tech";s:8:"subtitle";s:45:"百度EFE（Excellent FrontEnd）技术体系";s:9:"link_self";s:9:"/atom.xml";s:5:"link_";s:21:"http://efe.baidu.com/";s:7:"updated";s:24:"2015-08-24T05:08:00.000Z";s:2:"id";s:21:"http://efe.baidu.com/";s:6:"author";s:13:"
    
    
  ";s:11:"author_name";s:3:"efe";s:9:"generator";s:4:"Hexo";}s:9:"textinput";a:0:{}s:5:"image";a:0:{}s:9:"feed_type";s:4:"Atom";s:12:"feed_version";N;s:8:"encoding";s:5:"UTF-8";s:16:"_source_encoding";s:0:"";s:5:"ERROR";s:0:"";s:7:"WARNING";s:0:"";s:19:"_CONTENT_CONSTRUCTS";a:6:{i:0;s:7:"content";i:1;s:7:"summary";i:2;s:4:"info";i:3;s:5:"title";i:4;s:7:"tagline";i:5;s:9:"copyright";}s:16:"_KNOWN_ENCODINGS";a:3:{i:0;s:5:"UTF-8";i:1;s:8:"US-ASCII";i:2;s:10:"ISO-8859-1";}s:5:"stack";a:0:{}s:9:"inchannel";b:0;s:6:"initem";b:0;s:9:"incontent";b:0;s:11:"intextinput";b:0;s:7:"inimage";b:0;s:17:"current_namespace";b:0;s:13:"last_modified";s:31:"Mon, 24 Aug 2015 05:08:45 GMT
";}